# -*- coding: utf-8 -*-

from xml.etree import ElementTree

from .expr import parse_expression
from .predicates import *
from .types import *

MANUAL_COMPOUNDS = ("SizedString", "SizedString16", "BoundingVolume", "Key", "KeyGroup")

HEADER = """// This file is auto-generated by nifgen
// based on nifxml version {0}.
// Do not edit manually.

#![allow(
    clippy::eq_op,
    clippy::identity_op,
    non_camel_case_types,
    non_upper_case_globals,
    unused_imports,
    unused_parens
)]

use bitflags::bitflags;
use binrw::BinRead;

use crate::{{basic::*, parse}};
"""

DATA_STREAM_PARSER = """
str if str.starts_with("NiDataStream") => {
    let mut parts = str.split('_');

    let _ = parts.next();
    match (parts.next(), parts.next(), parts.next()) {
        (Some(usage), Some(access), None) => {
            let usage = usage.parse::<u32>().map_err(|e| Error::Custom {
                pos,
                err: Box::new(e),
            })?;
            let access = access.parse::<u32>().map_err(|e| Error::Custom {
                pos,
                err: Box::new(e),
            })?;

            NiDataStreamTheSadWay::read_options(r, o, (usage, access))
                .map(|o| NiObject::NiDataStream(o.into()))
        }
        _ => Err(Error::Custom {
            pos,
            err: Box::new("unknown NiDataStream type encountered"),
        }),
    }
}
"""


def emit_bitflags(f, obj):
    f.write(f"bitflags! {{\n")
    f.write(f"{obj.doc}")
    f.write(f"#[derive(BinRead)]\n")
    f.write(f"pub struct {obj.name}: {obj.storage} {{\n")
    for field, value in obj.flags.items():
        f.write(f"const {field} = {value};\n")
    f.write(f"}}\n")
    f.write(f"}}\n\n")


def emit_enum(f, obj):
    # Generate the enum definition itself.
    f.write(f"{obj.doc}")
    f.write(f"#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]\n")
    f.write(f"#[repr({obj.storage})]\n")
    f.write(f"pub enum {obj.name} {{\n")
    for name, value in obj.options.items():
        f.write(f"#[br(magic = {value}_{obj.storage})]\n")
        f.write(f"{name} = {value},\n")
    f.write(f"}}\n\n")

    # Generate a TryFrom impl as bitfields need a conversion strategy.
    f.write(f"impl TryFrom<usize> for {obj.name} {{\n")
    f.write(f"type Error = ();\n")
    f.write(f"fn try_from(value: usize) -> Result<Self, Self::Error> {{\n")
    f.write(f"match value {{\n")

    for name, value in obj.options.items():
        f.write(f"{value} => Ok({obj.name}::{name}),\n")
    f.write(f"_ => Err(()),\n")

    f.write(f"}}\n")
    f.write(f"}}\n")
    f.write(f"}}\n\n")


def emit_bitfield(f, obj):
    # Generate the raw structure with underlying storage.
    f.write(f"{obj.doc}")
    f.write(f"#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]\n")
    f.write(f"pub struct {obj.name}(pub {obj.storage});\n\n")

    # Generate an impl body with bit extraction methods.
    f.write(f"impl {obj.name} {{\n")
    for name, data in obj.fields.items():
        ty, pos, mask, _ = data
        f.write(f"pub fn {name}(&self) -> {ty} {{\n")
        f.write(f"let value = (self.0 as usize & {mask}) >> {pos};\n")
        if ty.ty == "bool":
            f.write(f"value != 0")
        else:
            f.write(f"value.try_into().unwrap()")
        f.write(f"\n}}\n")
    f.write(f"}}\n\n")

    # Generate a Default trait impl with default bits.
    f.write(f"impl Default for {obj.name} {{\n")
    f.write(f"fn default() -> Self {{\n")

    defaults = []
    for data in obj.fields.values():
        ty, pos, _, default = data
        if not default:
            default = "0"
        if not default.isnumeric():
            default = f"({ty}::{default} as {obj.storage})"
        defaults.append(f"({default} << {pos})")

    f.write(f"Self({'|'.join(defaults)})\n")
    f.write(f"}}\n")
    f.write(f"}}\n\n")


def emit_compound(f, ctx, obj):
    if obj.name in MANUAL_COMPOUNDS:
        return

    f.write(f"{obj.doc}")
    f.write(f"#[derive(Clone, Debug, PartialEq, BinRead)]\n")
    f.write(obj.get_import_attr())
    f.write(f"pub struct {obj.name}")
    if obj.generic:
        f.write(f"<T: BinRead> where T::Args: Default")
    f.write(f" {{\n")

    for name, ty in obj.fields.items():
        if_attr = ty.get_vercond_attr()
        if if_attr.strip() != "":
            if_attr = f"({if_attr})"
        if ty.cond:
            if if_attr.strip() != "":
                if_attr += " && "
            if_attr += f"({parse_expression(ty.cond)})"
        if if_attr.strip() != "":
            f.write(f"#[br(if({if_attr}))]\n")

        arg = ty.get_arg()
        if arg is not None:
            f.write(f"#[br(args({arg}, _header_version))]\n")
        elif ty.ty in ctx.compounds or ty.ty in ctx.niobjects:
            f.write(f"#[br(args(_header_version))]\n")

        f.write(ty.get_count_attr())
        f.write(ty.get_parse_with_attr())
        f.write(f"pub {name}: {ty},\n")

    f.write(f"}}\n\n")


def emit_niobject_impl(f, ctx):
    # Generate a tagged union holding all NiObject types.
    f.write(f"#[derive(Clone, Debug, PartialEq)]\n")
    f.write(f"pub enum NiObject {{\n")
    for obj in ctx.niobjects.values():
        f.write(f"{obj.name}({obj.name}),\n")
    f.write(f"}}\n\n")

    # Generate a manual deserialization impl that respects variant names.
    f.write(f"impl NiObject {{\n")
    f.write(f"pub fn read_options<R: Read + Seek>(r: &mut R, o: &ReadOptions, a: &str, v: FileVersion) -> BinResult<Self> {{\n")
    f.write(f"let pos = r.stream_position()?;\n")
    f.write(f"match a {{\n")
    for obj in ctx.niobjects.values():
        f.write(f'"{obj.name}" => {obj.name}::read_options(r, o, (v,)).map(NiObject::{obj.name}),\n')
    f.write(DATA_STREAM_PARSER)
    f.write(f'_ => Err(Error::Custom {{ pos, err: Box::new("unknown block type encountered") }}),\n')
    f.write(f"}}\n")
    f.write(f"}}\n")
    f.write(f"}}\n\n")


def emit_object(f, ctx, obj):
    f.write(f"{obj.doc}")
    f.write(f"#[derive(Clone, Debug, PartialEq, BinRead)]\n")
    f.write(f"#[br(import(_header_version: FileVersion))]")
    f.write(f"pub struct {obj.name} {{\n")

    if obj.parent != "NiObject":
        f.write(f"#[br(args(_header_version))]\n")
        f.write(f"pub base: {obj.parent},\n")

    for name, ty in obj.fields.items():
        if_attr = ty.get_vercond_attr()
        if if_attr.strip() != "":
            if_attr = f"({if_attr})"
        if ty.cond:
            if if_attr.strip() != "":
                if_attr += " && "
            if_attr += f"({parse_expression(ty.cond)})"
        if if_attr.strip() != "":
            f.write(f"#[br(if({if_attr}))]\n")

        arg = ty.get_arg()
        if arg is not None:
            f.write(f"#[br(args({arg}, _header_version))]\n")
        elif ty.ty in ctx.compounds or ty.ty in ctx.niobjects:
            f.write(f"#[br(args(_header_version))]\n")

        f.write(ty.get_count_attr())
        f.write(ty.get_parse_with_attr())
        f.write(f"pub {name}: {ty},\n")

    f.write(f"}}\n\n")


class Context:
    def __init__(self, version):
        self.version = version

        self.bitflags = {}
        self.enums = {}
        self.bitfields = {}
        self.compounds = {}
        self.niobjects = {}

    def get_header(self):
        return HEADER.format(self.version)

    @classmethod
    def parse(cls, nifxml):
        tree = ElementTree.parse(nifxml).getroot()

        obj = cls(tree.attrib["version"])
        prefixes = {}

        for entry in filter(lambda s: should_emit_struct(s.attrib), tree):
            if "prefix" in entry.attrib:
                prefixes[entry.attrib["name"]] = entry.attrib["prefix"]

            if entry.tag == "bitflags":
                ty = BitFlags.from_xml(entry)
                obj.bitflags[ty.name] = ty

            elif entry.tag == "enum":
                ty = Enum.from_xml(entry)
                obj.enums[ty.name] = ty

            elif entry.tag == "bitfield":
                ty = BitField.from_xml(entry, prefixes)
                obj.bitfields[ty.name] = ty

            elif entry.tag == "compound":
                ty = Compound.from_xml(entry)
                obj.compounds[ty.name] = ty

            elif entry.tag == "niobject" and entry.attrib["name"] != "NiObject":
                ty = NiObject.from_xml(entry)
                obj.niobjects[ty.name] = ty

        return obj
