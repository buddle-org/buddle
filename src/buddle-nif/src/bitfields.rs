// This file is auto-generated by nifgen
// based on nifxml version 0.9.3.0.
// Do not edit manually.

#![allow(
    clippy::eq_op,
    clippy::identity_op,
    non_camel_case_types,
    non_upper_case_globals,
    unused_imports,
    unused_parens
)]

use binrw::BinRead;
use bitflags::bitflags;

use crate::enums::*;
use crate::{basic::*, parse};

/// Flags for NiTimeController
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
pub struct TimeControllerFlags(pub u16);

impl TimeControllerFlags {
    pub fn anim_type(&self) -> AnimType {
        let value = (self.0 as usize & 0x0001) >> 0;
        value.try_into().unwrap()
    }
    pub fn cycle_type(&self) -> CycleType {
        let value = (self.0 as usize & 0x0006) >> 1;
        value.try_into().unwrap()
    }
    pub fn active(&self) -> bool {
        let value = (self.0 as usize & 0x0008) >> 3;
        value != 0
    }
    pub fn play_backwards(&self) -> bool {
        let value = (self.0 as usize & 0x0010) >> 4;
        value != 0
    }
    pub fn manager_controlled(&self) -> bool {
        let value = (self.0 as usize & 0x0020) >> 5;
        value != 0
    }
    pub fn compute_scaled_time(&self) -> bool {
        let value = (self.0 as usize & 0x0040) >> 6;
        value != 0
    }
    pub fn forced_update(&self) -> bool {
        let value = (self.0 as usize & 0x0080) >> 7;
        value != 0
    }
}

impl Default for TimeControllerFlags {
    fn default() -> Self {
        Self(
            (0 << 0)
                | ((CycleType::CYCLE_CLAMP as u16) << 1)
                | (1 << 3)
                | (0 << 4)
                | (0 << 5)
                | (1 << 6)
                | (0 << 7),
        )
    }
}

/// Flags for NiAlphaProperty
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
pub struct AlphaFlags(pub u16);

impl AlphaFlags {
    pub fn alpha_blend(&self) -> bool {
        let value = (self.0 as usize & 0x0001) >> 0;
        value != 0
    }
    pub fn source_blend_mode(&self) -> AlphaFunction {
        let value = (self.0 as usize & 0x001E) >> 1;
        value.try_into().unwrap()
    }
    pub fn destination_blend_mode(&self) -> AlphaFunction {
        let value = (self.0 as usize & 0x01E0) >> 5;
        value.try_into().unwrap()
    }
    pub fn alpha_test(&self) -> bool {
        let value = (self.0 as usize & 0x0200) >> 9;
        value != 0
    }
    pub fn test_func(&self) -> TestFunction {
        let value = (self.0 as usize & 0x1C00) >> 10;
        value.try_into().unwrap()
    }
    pub fn no_sorter(&self) -> bool {
        let value = (self.0 as usize & 0x2000) >> 13;
        value != 0
    }
    pub fn clone_unique(&self) -> bool {
        let value = (self.0 as usize & 0x4000) >> 14;
        value != 0
    }
    pub fn editor_alpha_threshold(&self) -> bool {
        let value = (self.0 as usize & 0x8000) >> 15;
        value != 0
    }
}

impl Default for AlphaFlags {
    fn default() -> Self {
        Self(
            (0 << 0)
                | ((AlphaFunction::ALPHA_SRC_ALPHA as u16) << 1)
                | ((AlphaFunction::ALPHA_INV_SRC_ALPHA as u16) << 5)
                | (1 << 9)
                | ((TestFunction::TEST_GREATER as u16) << 10)
                | (0 << 13)
                | (0 << 14)
                | (0 << 15),
        )
    }
}

/// Flags for NiFogProperty
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
pub struct FogFlags(pub u16);

impl FogFlags {
    pub fn enable(&self) -> bool {
        let value = (self.0 as usize & 0x0001) >> 0;
        value != 0
    }
    pub fn fog_function(&self) -> FogFunction {
        let value = (self.0 as usize & 0x0006) >> 1;
        value.try_into().unwrap()
    }
}

impl Default for FogFlags {
    fn default() -> Self {
        Self((0 << 0) | (0 << 1))
    }
}

/// Flags for NiStencilProperty
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
pub struct StencilFlags(pub u16);

impl StencilFlags {
    pub fn enable(&self) -> bool {
        let value = (self.0 as usize & 0x0001) >> 0;
        value != 0
    }
    pub fn fail_action(&self) -> StencilAction {
        let value = (self.0 as usize & 0x000E) >> 1;
        value.try_into().unwrap()
    }
    pub fn zfail_action(&self) -> StencilAction {
        let value = (self.0 as usize & 0x0070) >> 4;
        value.try_into().unwrap()
    }
    pub fn pass_action(&self) -> StencilAction {
        let value = (self.0 as usize & 0x0380) >> 7;
        value.try_into().unwrap()
    }
    pub fn draw_mode(&self) -> StencilDrawMode {
        let value = (self.0 as usize & 0x0C00) >> 10;
        value.try_into().unwrap()
    }
    pub fn test_func(&self) -> StencilTestFunc {
        let value = (self.0 as usize & 0xF000) >> 12;
        value.try_into().unwrap()
    }
}

impl Default for StencilFlags {
    fn default() -> Self {
        Self(
            (0 << 0)
                | ((StencilAction::ACTION_KEEP as u16) << 1)
                | ((StencilAction::ACTION_KEEP as u16) << 4)
                | ((StencilAction::ACTION_INCREMENT as u16) << 7)
                | ((StencilDrawMode::DRAW_BOTH as u16) << 10)
                | ((StencilTestFunc::STENCIL_TEST_GREATER as u16) << 12),
        )
    }
}

/// Flags for NiTexturingProperty
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
pub struct TexturingFlags(pub u16);

impl TexturingFlags {
    pub fn multitexture(&self) -> bool {
        let value = (self.0 as usize & 0x0001) >> 0;
        value != 0
    }
    pub fn apply_mode(&self) -> ApplyMode {
        let value = (self.0 as usize & 0x000E) >> 1;
        value.try_into().unwrap()
    }
    pub fn decal_count(&self) -> u16 {
        let value = (self.0 as usize & 0x0FF0) >> 4;
        value.try_into().unwrap()
    }
}

impl Default for TexturingFlags {
    fn default() -> Self {
        Self((0 << 0) | (0 << 1) | (0 << 4))
    }
}

/// Flags for NiTexturingProperty
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
pub struct TexturingMapFlags(pub u16);

impl TexturingMapFlags {
    pub fn texture_index(&self) -> u16 {
        let value = (self.0 as usize & 0x00FF) >> 0;
        value.try_into().unwrap()
    }
    pub fn filter_mode(&self) -> TexFilterMode {
        let value = (self.0 as usize & 0x0F00) >> 8;
        value.try_into().unwrap()
    }
    pub fn clamp_mode(&self) -> TexClampMode {
        let value = (self.0 as usize & 0x3000) >> 12;
        value.try_into().unwrap()
    }
}

impl Default for TexturingMapFlags {
    fn default() -> Self {
        Self((0 << 0) | (0 << 8) | (0 << 12))
    }
}

/// Flags for NiVertexColorProperty
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
pub struct VertexColorFlags(pub u16);

impl VertexColorFlags {
    pub fn color_mode(&self) -> u16 {
        let value = (self.0 as usize & 0x0007) >> 0;
        value.try_into().unwrap()
    }
    pub fn lighting_mode(&self) -> LightingMode {
        let value = (self.0 as usize & 0x0008) >> 3;
        value.try_into().unwrap()
    }
    pub fn source_vertex_mode(&self) -> SourceVertexMode {
        let value = (self.0 as usize & 0x0030) >> 4;
        value.try_into().unwrap()
    }
}

impl Default for VertexColorFlags {
    fn default() -> Self {
        Self((0 << 0) | (0 << 3) | (0 << 4))
    }
}

/// Flags for NiZBufferProperty
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
pub struct ZBufferFlags(pub u16);

impl ZBufferFlags {
    pub fn zbuffer_test(&self) -> bool {
        let value = (self.0 as usize & 0x0001) >> 0;
        value != 0
    }
    pub fn zbuffer_write(&self) -> bool {
        let value = (self.0 as usize & 0x0002) >> 1;
        value != 0
    }
    pub fn test_func(&self) -> TestFunction {
        let value = (self.0 as usize & 0x003C) >> 2;
        value.try_into().unwrap()
    }
}

impl Default for ZBufferFlags {
    fn default() -> Self {
        Self((0 << 0) | (0 << 1) | (0 << 2))
    }
}

/// Flags for NiAGDDataStream
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
pub struct NiAGDDataStreamFlags(pub u8);

impl NiAGDDataStreamFlags {
    pub fn keep(&self) -> bool {
        let value = (self.0 as usize & 0x0001) >> 0;
        value != 0
    }
    pub fn consistency_type(&self) -> AGDConsistencyType {
        let value = (self.0 as usize & 0x0006) >> 1;
        value.try_into().unwrap()
    }
}

impl Default for NiAGDDataStreamFlags {
    fn default() -> Self {
        Self((0 << 0) | ((AGDConsistencyType::AGD_MUTABLE as u8) << 1))
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
pub struct NiGeometryDataFlags(pub u16);

impl NiGeometryDataFlags {
    pub fn num_uv_sets(&self) -> bool {
        let value = (self.0 as usize & 0x003F) >> 0;
        value != 0
    }
    pub fn havok_material(&self) -> u16 {
        let value = (self.0 as usize & 0x0FC0) >> 6;
        value.try_into().unwrap()
    }
    pub fn nbt_method(&self) -> NiNBTMethod {
        let value = (self.0 as usize & 0xF000) >> 12;
        value.try_into().unwrap()
    }
}

impl Default for NiGeometryDataFlags {
    fn default() -> Self {
        Self((0 << 0) | (0 << 6) | (0 << 12))
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
pub struct BSGeometryDataFlags(pub u16);

impl BSGeometryDataFlags {
    pub fn has_uv(&self) -> bool {
        let value = (self.0 as usize & 0x0001) >> 0;
        value != 0
    }
    pub fn havok_material(&self) -> u16 {
        let value = (self.0 as usize & 0x0FC0) >> 6;
        value.try_into().unwrap()
    }
    pub fn has_tangents(&self) -> bool {
        let value = (self.0 as usize & 0x1000) >> 12;
        value != 0
    }
}

impl Default for BSGeometryDataFlags {
    fn default() -> Self {
        Self((0 << 0) | (0 << 6) | (0 << 12))
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
pub struct CollisionFilterFlags(pub u8);

impl CollisionFilterFlags {
    pub fn biped_part(&self) -> BipedPart {
        let value = (self.0 as usize & 0x001F) >> 0;
        value.try_into().unwrap()
    }
    pub fn mopp_scaled(&self) -> bool {
        let value = (self.0 as usize & 0x0020) >> 5;
        value != 0
    }
    pub fn no_collision(&self) -> bool {
        let value = (self.0 as usize & 0x0040) >> 6;
        value != 0
    }
    pub fn linked_group(&self) -> bool {
        let value = (self.0 as usize & 0x0080) >> 7;
        value != 0
    }
}

impl Default for CollisionFilterFlags {
    fn default() -> Self {
        Self((0 << 0) | (0 << 5) | (0 << 6) | (0 << 7))
    }
}
