// This file is auto-generated by nifgen
// based on nifxml version 0.9.3.0.
// Do not edit manually.

#![allow(
    clippy::eq_op,
    clippy::identity_op,
    non_camel_case_types,
    non_upper_case_globals,
    unused_imports,
    unused_parens
)]

use binrw::{binread, BinRead};
use bitflags::bitflags;

use crate::{basic::*, parse};

use crate::{bitfields::*, bitflags::*, enums::*, objects::*};

mod impls;

mod manual;
pub use self::manual::*;

/// A string type.
#[derive(Clone, Debug, PartialEq, BinRead)]
pub struct NiString {
    pub index: NiFixedString,
}

/// Currently, #T# must be a basic type due to nif.xml restrictions.
#[derive(Clone, Debug, PartialEq, BinRead)]
pub struct NiTFixedStringMapItem<T: BinRead>
where
    for<'a> T::Args<'a>: Default,
{
    pub string: NiFixedString,
    pub value: T,
}

/// A mapping or hash table between NiFixedString keys and a generic value.
/// Currently, #T# must be a basic type due to nif.xml restrictions.
#[binread]
#[derive(Clone, Debug, PartialEq)]
pub struct NiTFixedStringMap<T>
    where
            for<'a> T: BinRead<Args<'a>=()> + 'a,
{
    #[br(temp)]
    num_strings: u32,

    #[br(count = num_strings)]
    pub strings: Vec<NiTFixedStringMapItem<T>>,
}

/// An array of bytes.
#[binread]
#[derive(Clone, Debug, PartialEq)]
pub struct ByteArray {
    #[br(temp)]
    data_size: u32,
    #[br(count = data_size)]
    pub data: Vec<u8>,
}

/// An array of bytes.
#[binread]
#[derive(Clone, Debug, PartialEq)]
pub struct ByteMatrix {
    #[br(temp)]
    data_size_1: u32,
    #[br(temp)]
    data_size_2: u32,

    #[br(count = data_size_2)]
    pub data: Vec<u8>,
}

/// A color without alpha (red, green, blue).
#[derive(Clone, Debug, PartialEq, BinRead)]
pub struct Color3 {
    pub r: f32,
    pub g: f32,
    pub b: f32,
}

/// A color without alpha (red, green, blue).
#[derive(Clone, Debug, PartialEq, BinRead)]
pub struct ByteColor3 {
    pub r: u8,
    pub g: u8,
    pub b: u8,
}

/// A color with alpha (red, green, blue, alpha).
#[derive(Clone, Debug, PartialEq, BinRead)]
pub struct Color4 {
    pub r: f32,
    pub g: f32,
    pub b: f32,
    pub a: f32,
}

/// A color with alpha (red, green, blue, alpha).
#[derive(Clone, Debug, PartialEq, BinRead)]
pub struct ByteColor4 {
    pub r: u8,
    pub g: u8,
    pub b: u8,
    pub a: u8,
}

/// A string that contains the path to a file.
#[derive(Clone, Debug, PartialEq, BinRead)]
pub struct FilePath {
    pub index: NiFixedString,
}

/// The NIF file footer.
#[binread]
#[derive(Clone, Debug, PartialEq)]
pub struct Footer {
    #[br(temp)]
    num_roots: u32,
    #[br(count = num_roots)]
    pub roots: Vec<Ref<NiObject>>,
}

/// The distance range where a specific level of detail applies.
#[derive(Clone, Debug, PartialEq, BinRead)]
pub struct LODRange {
    pub near_extent: f32,
    pub far_extent: f32,
}

/// Group of vertex indices of vertices that match.
#[binread]
#[derive(Clone, Debug, PartialEq)]
pub struct MatchGroup {
    #[br(temp)]
    num_vertices: u16,
    #[br(count = num_vertices)]
    pub vertex_indices: Vec<u16>,
}

/// A vector in 3D space (x,y,z).
#[derive(Clone, Debug, PartialEq, BinRead)]
pub struct Vector3 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}

/// A vector in 3D space (x,y,z).
#[derive(Clone, Debug, PartialEq, BinRead)]
pub struct HalfVector3 {
    pub x: f16,
    pub y: f16,
    pub z: f16,
}

/// A vector in 3D space (x,y,z).
#[derive(Clone, Debug, PartialEq, BinRead)]
pub struct ByteVector3 {
    pub x: u8,
    pub y: u8,
    pub z: u8,
}

/// A 4-dimensional vector.
#[derive(Clone, Debug, PartialEq, BinRead)]
pub struct Vector4 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}

/// A quaternion.
#[derive(Clone, Debug, PartialEq, BinRead)]
pub struct Quaternion {
    pub w: f32,
    pub x: f32,
    pub y: f32,
    pub z: f32,
}

/// A 2x2 matrix of float values.  Stored in OpenGL column-major format.
#[derive(Clone, Debug, PartialEq, BinRead)]
pub struct Matrix22 {
    pub m11: f32,
    pub m21: f32,
    pub m12: f32,
    pub m22: f32,
}

/// A 3x3 rotation matrix; M^T M=identity, det(M)=1.    Stored in OpenGL column-major format.
#[derive(Clone, Debug, PartialEq, BinRead)]
pub struct Matrix33 {
    pub m11: f32,
    pub m21: f32,
    pub m31: f32,
    pub m12: f32,
    pub m22: f32,
    pub m32: f32,
    pub m13: f32,
    pub m23: f32,
    pub m33: f32,
}

/// A 3x4 transformation matrix.
#[derive(Clone, Debug, PartialEq, BinRead)]
pub struct Matrix34 {
    pub m11: f32,
    pub m21: f32,
    pub m31: f32,
    pub m12: f32,
    pub m22: f32,
    pub m32: f32,
    pub m13: f32,
    pub m23: f32,
    pub m33: f32,
    pub m14: f32,
    pub m24: f32,
    pub m34: f32,
}

/// A 4x4 transformation matrix.
#[derive(Clone, Debug, PartialEq, BinRead)]
pub struct Matrix44 {
    pub m11: f32,
    pub m21: f32,
    pub m31: f32,
    pub m41: f32,
    pub m12: f32,
    pub m22: f32,
    pub m32: f32,
    pub m42: f32,
    pub m13: f32,
    pub m23: f32,
    pub m33: f32,
    pub m43: f32,
    pub m14: f32,
    pub m24: f32,
    pub m34: f32,
    pub m44: f32,
}

/// Description of a mipmap within an NiPixelData object.
#[derive(Clone, Debug, PartialEq, BinRead)]
pub struct MipMap {
    pub width: u32,
    pub height: u32,
    pub offset: u32,
}

/// A set of NiNode references.
#[binread]
#[derive(Clone, Debug, PartialEq)]
pub struct NodeSet {
    #[br(temp)]
    num_nodes: u32,
    #[br(count = num_nodes)]
    pub nodes: Vec<Ptr<NiNode>>,
}

/// Specific to Bethesda-specific header export strings.
#[binread]
#[derive(Clone, Debug, PartialEq)]
pub struct ExportString {
    #[br(temp)]
    length: u8,
    #[br(count = length)]
    pub value: Vec<i8>,
}

/// NiBoneLODController::SkinInfo. Reference to shape and skin instance.
#[derive(Clone, Debug, PartialEq, BinRead)]
pub struct SkinInfo {
    pub shape: Ptr<NiTriBasedGeom>,
    pub skin_instance: Ref<NiSkinInstance>,
}

/// A set of NiBoneLODController::SkinInfo.
#[binread]
#[derive(Clone, Debug, PartialEq)]
pub struct SkinInfoSet {
    #[br(temp)]
    num_skin_info: u32,
    #[br(count = num_skin_info)]
    pub skin_info: Vec<SkinInfo>,
}

/// NiSkinData::BoneVertData. A vertex and its weight.
#[derive(Clone, Debug, PartialEq, BinRead)]
pub struct BoneVertData {
    pub index: u16,
    pub weight: f32,
}

/// Used in NiDefaultAVObjectPalette.
#[derive(Clone, Debug, PartialEq, BinRead)]
pub struct AVObject {
    pub name: SizedString,
    pub av_object: Ptr<NiAVObject>,
}

/// In a .kf file, this links to a controllable object, via its name (or for version 10.2.0.0 and up, a link and offset to a NiStringPalette that contains the name), and a sequence of interpolators that apply to this controllable object, via links.
/// For Controller ID, NiInterpController::GetCtlrID() virtual function returns a string formatted specifically for the derived type.
/// For Interpolator ID, NiInterpController::GetInterpolatorID() virtual function returns a string formatted specifically for the derived type.
/// The string formats are documented on the relevant niobject blocks.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct ControlledBlock {
    pub interpolator: Ref<NiInterpolator>,
    #[br(if((_header_version <= FileVersion(20,5,0,0))))]
    pub controller: Option<Ref<NiTimeController>>,
    pub node_name: NiString,
    pub property_type: NiString,
    pub controller_type: NiString,
    pub controller_id: NiString,
    pub interpolator_id: NiString,
}

/// The NIF file header.
#[binread]
#[derive(Clone, Debug, PartialEq)]
pub struct Header {
    pub header_string: HeaderString,
    pub version: FileVersion,
    pub endian_type: EndianType,
    pub user_version: u32,
    pub num_blocks: u32,
    #[br(temp)]
    num_block_types: u16,
    #[br(count = num_block_types)]
    pub block_types: Vec<SizedString>,
    #[br(count = num_blocks)]
    pub block_type_index: Vec<BlockTypeIndex>,
    #[br(if(FileVersion(20,2,0,5) <= version))]
    #[br(count = num_blocks)]
    pub block_size: Option<Vec<u32>>,
    #[br(temp)]
    num_strings: u32,
    pub max_string_length: u32,
    #[br(count = num_strings)]
    pub strings: Vec<SizedString>,
    #[br(temp)]
    num_groups: u32,
    #[br(count = num_groups)]
    pub groups: Vec<u32>,
}

/// A list of \\0 terminated strings.
#[derive(Clone, Debug, PartialEq, BinRead)]
pub struct StringPalette {
    pub palette: SizedString,
    pub length: u32,
}

/// Tension, bias, continuity.
#[derive(Clone, Debug, PartialEq, BinRead)]
pub struct TBC {
    pub t: f32,
    pub b: f32,
    pub c: f32,
}

/// A special version of the key type used for quaternions. Never has tangents. #T# should always be Quaternion.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(rotation_type: Option<KeyType>))]
pub struct QuatKey<T> where for<'a> T: BinRead<Args<'a>=()> {
    #[br(if(rotation_type != Some(KeyType::XYZ_ROTATION_KEY)))]
    pub time: Option<f32>,
    #[br(if(rotation_type != Some(KeyType::XYZ_ROTATION_KEY)))]
    pub value: Option<T>,
    #[br(if(rotation_type == Some(KeyType::TBC_KEY)))]
    pub tbc: Option<TBC>,
}

/// Texture coordinates (u,v). As in OpenGL; image origin is in the lower left corner.
#[derive(Clone, Debug, PartialEq, BinRead)]
pub struct TexCoord {
    pub u: f32,
    pub v: f32,
}

/// Texture coordinates (u,v).
#[derive(Clone, Debug, PartialEq, BinRead)]
pub struct HalfTexCoord {
    pub u: f16,
    pub v: f16,
}

/// NiTexturingProperty::Map. Texture description.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct TexDesc {
    pub source: Ref<NiSourceTexture>,
    pub flags: TexturingMapFlags,
    #[br(if(FileVersion(20,5,0,4) <= _header_version))]
    pub max_anisotropy: Option<u16>,
    #[br(map = |b: u8| b != 0)]
    pub has_texture_transform: bool,
    #[br(if(has_texture_transform))]
    pub translation: Option<TexCoord>,
    #[br(if(has_texture_transform))]
    pub scale: Option<TexCoord>,
    #[br(if(has_texture_transform))]
    pub rotation: Option<f32>,
    #[br(if(has_texture_transform))]
    pub transform_method: Option<TransformMethod>,
    #[br(if(has_texture_transform))]
    pub center: Option<TexCoord>,
}

/// NiTexturingProperty::ShaderMap. Shader texture description.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct ShaderTexDesc {
    #[br(map = |b: u8| b != 0)]
    pub has_map: bool,
    #[br(if(has_map))]
    #[br(args(_header_version))]
    pub map: Option<TexDesc>,
    #[br(if(has_map))]
    pub map_id: Option<u32>,
}

/// List of three vertex indices.
#[derive(Clone, Debug, PartialEq, BinRead)]
pub struct Triangle {
    pub v1: u16,
    pub v2: u16,
    pub v3: u16,
}

/// Skinning data for a submesh, optimized for hardware skinning. Part of NiSkinPartition.
#[binread]
#[derive(Clone, Debug, PartialEq)]
pub struct SkinPartition {
    #[br(temp)]
    num_vertices: u16,
    #[br(temp)]
    num_triangles: u16,
    #[br(temp)]
    num_bones: u16,
    #[br(temp)]
    num_strips: u16,
    #[br(temp)]
    num_weights_per_vertex: u16,
    #[br(count = num_bones)]
    pub bones: Vec<u16>,
    #[br(map = |b: u8| b != 0, temp)]
    has_vertex_map: bool,
    #[br(if(has_vertex_map))]
    #[br(count = num_vertices)]
    pub vertex_map: Option<Vec<u16>>,
    #[br(map = |b: u8| b != 0, temp)]
    has_vertex_weights: bool,
    #[br(if(has_vertex_weights))]
    #[br(
        args(has_vertex_weights, num_vertices as usize, num_weights_per_vertex as usize),
        parse_with = parse::fixed_option_vec_vec
    )]
    pub vertex_weights: Option<Vec<Vec<f32>>>,
    #[br(count = num_strips)]
    pub strip_lengths: Vec<u16>,
    #[br(map = |b: u8| b != 0, temp)]
    has_faces: bool,
    #[br(
        args(has_faces && (num_strips != 0), strip_lengths.as_ref()),
        parse_with = parse::var_option_vec_vec
    )]
    pub strips: Option<Vec<Vec<u16>>>,
    #[br(if(has_faces && (num_strips == 0)))]
    #[br(count = num_triangles)]
    pub triangles: Option<Vec<Triangle>>,
    #[br(map = |b: u8| b != 0)]
    pub has_bone_indices: bool,
    #[br(if(has_bone_indices))]
    #[br(
        args(has_bone_indices, num_vertices as usize, num_weights_per_vertex as usize),
        parse_with = parse::fixed_option_vec_vec
    )]
    pub bone_indices: Option<Vec<Vec<u8>>>,
}

/// A plane.
#[derive(Clone, Debug, PartialEq, BinRead)]
pub struct NiPlane {
    pub normal: Vector3,
    pub constant: f32,
}

/// Divinity 2 specific NiBound extension.
#[derive(Clone, Debug, PartialEq, BinRead)]
pub struct NiBoundAABB {
    pub num_corners: u16,
    pub corners: [Vector3; 2],
}

/// A sphere.
#[derive(Clone, Debug, PartialEq, BinRead)]
pub struct NiBound {
    pub center: Vector3,
    pub radius: f32,
}

/// A 3D curve made up of control points and knots.
#[binread]
#[derive(Clone, Debug, PartialEq)]
pub struct NiCurve3 {
    pub degree: u32,
    #[br(temp)]
    num_control_points: u32,
    #[br(count = num_control_points)]
    pub control_points: Vec<Vector3>,
    #[br(temp)]
    num_knots: u32,
    #[br(count = num_knots)]
    pub knots: Vec<f32>,
}

#[derive(Clone, Debug, PartialEq, BinRead)]
pub struct NiQuatTransform {
    pub translation: Vector3,
    pub rotation: Quaternion,
    pub scale: f32,
}

#[derive(Clone, Debug, PartialEq, BinRead)]
pub struct NiTransform {
    pub rotation: Matrix33,
    pub translation: Vector3,
    pub scale: f32,
}

/// Geometry morphing data component.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(num_vertices: u32))]
pub struct Morph {
    pub frame_name: NiString,
    #[br(count = num_vertices)]
    pub vectors: Vec<Vector3>,
}

/// Called NiPerParticleData in NiOldParticles.
/// Holds the state of a particle at the time the system was saved.
#[derive(Clone, Debug, PartialEq, BinRead)]
pub struct NiParticleInfo {
    pub velocity: Vector3,
    pub age: f32,
    pub life_span: f32,
    pub last_update: f32,
    pub spawn_generation: u16,
    pub code: u16,
}

/// NiSkinData::BoneData. Skinning data component.
#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(has_vertex_weights: bool))]
pub struct BoneData {
    pub skin_transform: NiTransform,
    pub bounding_sphere: NiBound,
    #[br(temp)]
    num_vertices: u16,
    #[br(if(has_vertex_weights))]
    #[br(count = num_vertices)]
    pub vertex_weights: Option<Vec<BoneVertData>>,
}

/// Used to store skin weights in NiTriShapeSkinController.
#[derive(Clone, Debug, PartialEq, BinRead)]
pub struct OldSkinData {
    pub vertex_weight: f32,
    pub vertex_index: u16,
    pub unknown_vector: Vector3,
}

/// Box Bounding Volume
#[derive(Clone, Debug, PartialEq, BinRead)]
pub struct BoxBV {
    pub center: Vector3,
    pub axis: [Vector3; 3],
    pub extent: Vector3,
}

/// Capsule Bounding Volume
#[derive(Clone, Debug, PartialEq, BinRead)]
pub struct CapsuleBV {
    pub center: Vector3,
    pub origin: Vector3,
    pub extent: f32,
    pub radius: f32,
}

#[derive(Clone, Debug, PartialEq, BinRead)]
pub struct HalfSpaceBV {
    pub plane: NiPlane,
    pub center: Vector3,
}

#[binread]
#[derive(Clone, Debug, PartialEq)]
pub struct UnionBV {
    #[br(temp)]
    num_bv: u32,
    #[br(count = num_bv)]
    pub bounding_volumes: Vec<BoundingVolume>,
}

#[derive(Clone, Debug, PartialEq, BinRead)]
pub struct MorphWeight {
    pub interpolator: Ref<NiInterpolator>,
    pub weight: f32,
}

/// Interpolator item for array in NiBlendInterpolator.
#[derive(Clone, Debug, PartialEq, BinRead)]
pub struct InterpBlendItem {
    pub interpolator: Ref<NiInterpolator>,
    pub weight: f32,
    pub normalized_weight: f32,
    pub priority: u8,
    pub ease_spinner: f32,
}

/// Extra Data for pre-3.0 versions
#[derive(Clone, Debug, PartialEq, BinRead)]
pub struct LegacyExtraData {
    #[br(map = |b: u8| b != 0)]
    pub has_extra_data: bool,
    #[br(if(has_extra_data))]
    pub extra_prop_name: Option<SizedString>,
    #[br(if(has_extra_data))]
    pub extra_ref_id: Option<u32>,
    #[br(if(has_extra_data))]
    pub extra_string: Option<SizedString>,
    pub unknown_byte_1: u8,
}

#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct MaterialData {
    #[br(if(_header_version <= FileVersion(20,1,0,3)))]
    #[br(map = |b: Option<u8>| b.map(|b| b != 0))]
    pub has_shader: Option<bool>,
    #[br(if(_header_version <= FileVersion(20,1,0,3)))]
    pub shader_name: Option<NiString>,
    #[br(if(has_shader.unwrap_or(false)))]
    pub shader_extra_data: Option<i32>,
    #[br(if(FileVersion(20,2,0,5) <= _header_version))]
    pub num_materials: Option<u32>,
    #[br(count = num_materials.unwrap_or(0))]
    pub material_name: Vec<NiFixedString>,
    #[br(count = num_materials.unwrap_or(0))]
    pub material_extra_data: Vec<i32>,
    #[br(if(FileVersion(20,2,0,5) <= _header_version))]
    pub active_material: Option<i32>,
    #[br(if(FileVersion(20,2,0,7) <= _header_version))]
    #[br(map = |b: Option<u8>| b.map(|b| b != 0))]
    pub material_needs_update: Option<bool>,
}

#[derive(Clone, Debug, PartialEq, BinRead)]
pub struct PixelFormatComponent {
    pub r#type: PixelComponent,
    pub convention: PixelRepresentation,
    pub bits_per_channel: u8,
    #[br(map = |b: u8| b != 0)]
    pub is_signed: bool,
}

/// NiTexture::FormatPrefs. These preferences are a request to the renderer to use a format the most closely matches the settings and may be ignored.
#[derive(Clone, Debug, PartialEq, BinRead)]
pub struct FormatPrefs {
    pub pixel_layout: PixelLayout,
    pub use_mipmaps: MipMapFormat,
    pub alpha_format: AlphaFormat,
}

#[derive(Clone, Debug, PartialEq, BinRead)]
pub struct NxCompartmentDescMap {
    pub id: u32,
    pub r#type: NxCompartmentType,
    pub device_code: NxDeviceCode,
    pub grid_hash_cell_size: f32,
    pub grid_hash_table_power: u32,
}

#[derive(Clone, Debug, PartialEq, BinRead)]
pub struct NxJointLimitSoftDesc {
    pub value: f32,
    pub restitution: f32,
    pub spring: f32,
    pub damping: f32,
}

#[derive(Clone, Debug, PartialEq, BinRead)]
pub struct NxJointDriveDesc {
    pub drive_type: NxD6JointDriveType,
    pub spring: f32,
    pub damping: f32,
    pub force_limit: f32,
}

#[derive(Clone, Debug, PartialEq, BinRead)]
pub struct NxPlane {
    pub val_1: f32,
    pub point_1: Vector3,
}

#[derive(Clone, Debug, PartialEq, BinRead)]
pub struct NxCapsule {
    pub val_1: f32,
    pub val_2: f32,
    pub capsule_flags: u32,
}

#[derive(Clone, Debug, PartialEq, BinRead)]
pub struct NxSpringDesc {
    pub spring: f32,
    pub damper: f32,
    pub target_value: f32,
}

#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NxMaterialDesc {
    pub dynamic_friction: f32,
    pub static_friction: f32,
    pub restitution: f32,
    pub dynamic_friction_v: f32,
    pub static_friction_v: f32,
    pub direction_of_anisotropy: Vector3,
    pub flags: NxMaterialFlag,
    pub friction_combine_mode: NxCombineMode,
    pub restitution_combine_mode: NxCombineMode,
    #[br(if((_header_version <= FileVersion(20,2,3,0))))]
    #[br(map = |b: Option<u8>| b.map(|b| b != 0))]
    pub has_spring: Option<bool>,
    #[br(if((_header_version <= FileVersion(20,2,3,0)) && has_spring.unwrap_or(false)))]
    pub spring: Option<NxSpringDesc>,
}

/// Two dimensional screen elements.
#[derive(Clone, Debug, PartialEq, BinRead)]
pub struct Polygon {
    pub num_vertices: u16,
    pub vertex_offset: u16,
    pub num_triangles: u16,
    pub triangle_offset: u16,
}

#[derive(Clone, Debug, PartialEq, BinRead)]
pub struct NiAGDDataStream {
    pub r#type: u32,
    pub unit_size: u32,
    pub total_size: u32,
    pub stride: u32,
    pub block_index: u32,
    pub block_offset: u32,
    pub flags: NiAGDDataStreamFlags,
}

#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(arg: usize))]
pub struct NiAGDDataBlock {
    pub block_size: u32,
    #[br(temp)]
    num_blocks: u32,
    #[br(count = num_blocks)]
    pub block_offsets: Vec<u32>,
    #[br(temp)]
    num_data: u32,
    #[br(count = num_data)]
    pub data_sizes: Vec<u32>,
    #[br(count = num_data)]
    pub data: Vec<u8>,
    #[br(if(arg == 1))]
    pub shader_index: Option<u32>,
    #[br(if(arg == 1))]
    pub total_size: Option<u32>,
}

#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(arg: usize))]
pub struct NiAGDDataBlocks {
    #[br(map = |b: u8| b != 0)]
    pub has_data: bool,
    #[br(if(has_data))]
    #[br(args(arg))]
    pub data_block: Option<NiAGDDataBlock>,
}

/// A range of indices, which make up a region (such as a submesh).
#[derive(Clone, Debug, PartialEq, BinRead)]
pub struct Region {
    pub start_index: u32,
    pub num_indices: u32,
}

#[derive(Clone, Debug, PartialEq, BinRead)]
pub struct SemanticData {
    pub name: NiFixedString,
    pub index: u32,
}

#[binread]
#[derive(Clone, Debug, PartialEq)]
pub struct DataStreamRef {
    pub stream: Ref<NiDataStream>,
    #[br(map = |b: u8| b != 0)]
    pub is_per_instance: bool,
    #[br(temp)]
    num_submeshes: u16,
    #[br(count = num_submeshes)]
    pub submesh_to_region_map: Vec<u16>,
    #[br(temp)]
    num_components: u32,
    #[br(count = num_components)]
    pub component_semantics: Vec<SemanticData>,
}

#[derive(Clone, Debug, PartialEq, BinRead)]
pub struct ElementReference {
    pub semantic: SemanticData,
    pub normalize_flag: u32,
}

#[binread]
#[derive(Clone, Debug, PartialEq)]
pub struct LODInfo {
    pub num_bones: u32,
    #[br(temp)]
    num_active_skins: u32,
    #[br(count = num_active_skins)]
    pub skin_indices: Vec<u32>,
}

#[derive(Clone, Debug, PartialEq, BinRead)]
pub struct PSSpawnRateKey {
    pub value: f32,
    pub time: f32,
}
