// This file is auto-generated by nifgen
// based on nifxml version 0.9.3.0.
// Do not edit manually.

#![allow(
    clippy::eq_op,
    clippy::identity_op,
    non_camel_case_types,
    non_upper_case_globals,
    unused_imports,
    unused_parens
)]

use binrw::BinRead;
use bitflags::bitflags;

use crate::{basic::*, parse};

/// Describes how the vertex colors are blended with the filtered texture color.
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum ApplyMode {
    #[br(magic = 0_u32)]
    APPLY_REPLACE = 0,
    #[br(magic = 1_u32)]
    APPLY_DECAL = 1,
    #[br(magic = 2_u32)]
    APPLY_MODULATE = 2,
    #[br(magic = 3_u32)]
    APPLY_HILIGHT = 3,
    #[br(magic = 4_u32)]
    APPLY_HILIGHT2 = 4,
}

impl TryFrom<usize> for ApplyMode {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(ApplyMode::APPLY_REPLACE),
            1 => Ok(ApplyMode::APPLY_DECAL),
            2 => Ok(ApplyMode::APPLY_MODULATE),
            3 => Ok(ApplyMode::APPLY_HILIGHT),
            4 => Ok(ApplyMode::APPLY_HILIGHT2),
            _ => Err(()),
        }
    }
}

/// The type of texture.
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum TexType {
    #[br(magic = 0_u32)]
    BASE_MAP = 0,
    #[br(magic = 1_u32)]
    DARK_MAP = 1,
    #[br(magic = 2_u32)]
    DETAIL_MAP = 2,
    #[br(magic = 3_u32)]
    GLOSS_MAP = 3,
    #[br(magic = 4_u32)]
    GLOW_MAP = 4,
    #[br(magic = 5_u32)]
    BUMP_MAP = 5,
    #[br(magic = 6_u32)]
    NORMAL_MAP = 6,
    #[br(magic = 7_u32)]
    PARALLAX_MAP = 7,
    #[br(magic = 8_u32)]
    DECAL_0_MAP = 8,
    #[br(magic = 9_u32)]
    DECAL_1_MAP = 9,
    #[br(magic = 10_u32)]
    DECAL_2_MAP = 10,
    #[br(magic = 11_u32)]
    DECAL_3_MAP = 11,
}

impl TryFrom<usize> for TexType {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(TexType::BASE_MAP),
            1 => Ok(TexType::DARK_MAP),
            2 => Ok(TexType::DETAIL_MAP),
            3 => Ok(TexType::GLOSS_MAP),
            4 => Ok(TexType::GLOW_MAP),
            5 => Ok(TexType::BUMP_MAP),
            6 => Ok(TexType::NORMAL_MAP),
            7 => Ok(TexType::PARALLAX_MAP),
            8 => Ok(TexType::DECAL_0_MAP),
            9 => Ok(TexType::DECAL_1_MAP),
            10 => Ok(TexType::DECAL_2_MAP),
            11 => Ok(TexType::DECAL_3_MAP),
            _ => Err(()),
        }
    }
}

/// The type of animation interpolation (blending) that will be used on the associated key frames.
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum KeyType {
    #[br(magic = 1_u32)]
    LINEAR_KEY = 1,
    #[br(magic = 2_u32)]
    QUADRATIC_KEY = 2,
    #[br(magic = 3_u32)]
    TBC_KEY = 3,
    #[br(magic = 4_u32)]
    XYZ_ROTATION_KEY = 4,
    #[br(magic = 5_u32)]
    CONST_KEY = 5,
}

impl TryFrom<usize> for KeyType {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            1 => Ok(KeyType::LINEAR_KEY),
            2 => Ok(KeyType::QUADRATIC_KEY),
            3 => Ok(KeyType::TBC_KEY),
            4 => Ok(KeyType::XYZ_ROTATION_KEY),
            5 => Ok(KeyType::CONST_KEY),
            _ => Err(()),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u8)]
pub enum BipedPart {
    #[br(magic = 0_u8)]
    P_OTHER = 0,
    #[br(magic = 1_u8)]
    P_HEAD = 1,
    #[br(magic = 2_u8)]
    P_BODY = 2,
    #[br(magic = 3_u8)]
    P_SPINE1 = 3,
    #[br(magic = 4_u8)]
    P_SPINE2 = 4,
    #[br(magic = 5_u8)]
    P_L_UPPER_ARM = 5,
    #[br(magic = 6_u8)]
    P_L_FOREARM = 6,
    #[br(magic = 7_u8)]
    P_L_HAND = 7,
    #[br(magic = 8_u8)]
    P_L_THIGH = 8,
    #[br(magic = 9_u8)]
    P_L_CALF = 9,
    #[br(magic = 10_u8)]
    P_L_FOOT = 10,
    #[br(magic = 11_u8)]
    P_R_UPPER_ARM = 11,
    #[br(magic = 12_u8)]
    P_R_FOREARM = 12,
    #[br(magic = 13_u8)]
    P_R_HAND = 13,
    #[br(magic = 14_u8)]
    P_R_THIGH = 14,
    #[br(magic = 15_u8)]
    P_R_CALF = 15,
    #[br(magic = 16_u8)]
    P_R_FOOT = 16,
    #[br(magic = 17_u8)]
    P_TAIL = 17,
    #[br(magic = 18_u8)]
    P_SHIELD = 18,
    #[br(magic = 19_u8)]
    P_QUIVER = 19,
    #[br(magic = 20_u8)]
    P_WEAPON = 20,
    #[br(magic = 21_u8)]
    P_PONYTAIL = 21,
    #[br(magic = 22_u8)]
    P_WING = 22,
    #[br(magic = 23_u8)]
    P_PACK = 23,
    #[br(magic = 24_u8)]
    P_CHAIN = 24,
    #[br(magic = 25_u8)]
    P_ADDON_HEAD = 25,
    #[br(magic = 26_u8)]
    P_ADDON_CHEST = 26,
    #[br(magic = 27_u8)]
    P_ADDON_LEG = 27,
    #[br(magic = 28_u8)]
    P_ADDON_ARM = 28,
}

impl TryFrom<usize> for BipedPart {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(BipedPart::P_OTHER),
            1 => Ok(BipedPart::P_HEAD),
            2 => Ok(BipedPart::P_BODY),
            3 => Ok(BipedPart::P_SPINE1),
            4 => Ok(BipedPart::P_SPINE2),
            5 => Ok(BipedPart::P_L_UPPER_ARM),
            6 => Ok(BipedPart::P_L_FOREARM),
            7 => Ok(BipedPart::P_L_HAND),
            8 => Ok(BipedPart::P_L_THIGH),
            9 => Ok(BipedPart::P_L_CALF),
            10 => Ok(BipedPart::P_L_FOOT),
            11 => Ok(BipedPart::P_R_UPPER_ARM),
            12 => Ok(BipedPart::P_R_FOREARM),
            13 => Ok(BipedPart::P_R_HAND),
            14 => Ok(BipedPart::P_R_THIGH),
            15 => Ok(BipedPart::P_R_CALF),
            16 => Ok(BipedPart::P_R_FOOT),
            17 => Ok(BipedPart::P_TAIL),
            18 => Ok(BipedPart::P_SHIELD),
            19 => Ok(BipedPart::P_QUIVER),
            20 => Ok(BipedPart::P_WEAPON),
            21 => Ok(BipedPart::P_PONYTAIL),
            22 => Ok(BipedPart::P_WING),
            23 => Ok(BipedPart::P_PACK),
            24 => Ok(BipedPart::P_CHAIN),
            25 => Ok(BipedPart::P_ADDON_HEAD),
            26 => Ok(BipedPart::P_ADDON_CHEST),
            27 => Ok(BipedPart::P_ADDON_LEG),
            28 => Ok(BipedPart::P_ADDON_ARM),
            _ => Err(()),
        }
    }
}

/// Target platform for NiPersistentSrcTextureRendererData (later than 30.1).
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum PlatformID {
    #[br(magic = 0_u32)]
    PLATFORM_ANY = 0,
    #[br(magic = 1_u32)]
    PLATFORM_XENON = 1,
    #[br(magic = 2_u32)]
    PLATFORM_PS3 = 2,
    #[br(magic = 3_u32)]
    PLATFORM_DX9 = 3,
    #[br(magic = 4_u32)]
    PLATFORM_WII = 4,
    #[br(magic = 5_u32)]
    PLATFORM_D3D10 = 5,
}

impl TryFrom<usize> for PlatformID {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(PlatformID::PLATFORM_ANY),
            1 => Ok(PlatformID::PLATFORM_XENON),
            2 => Ok(PlatformID::PLATFORM_PS3),
            3 => Ok(PlatformID::PLATFORM_DX9),
            4 => Ok(PlatformID::PLATFORM_WII),
            5 => Ok(PlatformID::PLATFORM_D3D10),
            _ => Err(()),
        }
    }
}

/// Describes the pixel format used by the NiPixelData object to store a texture.
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum PixelFormat {
    #[br(magic = 0_u32)]
    PX_FMT_RGB = 0,
    #[br(magic = 1_u32)]
    PX_FMT_RGBA = 1,
    #[br(magic = 2_u32)]
    PX_FMT_PAL = 2,
    #[br(magic = 3_u32)]
    PX_FMT_PALA = 3,
    #[br(magic = 4_u32)]
    PX_FMT_DXT1 = 4,
    #[br(magic = 5_u32)]
    PX_FMT_DXT3 = 5,
    #[br(magic = 6_u32)]
    PX_FMT_DXT5 = 6,
    #[br(magic = 7_u32)]
    PX_FMT_RGB24NONINT = 7,
    #[br(magic = 8_u32)]
    PX_FMT_BUMP = 8,
    #[br(magic = 9_u32)]
    PX_FMT_BUMPLUMA = 9,
    #[br(magic = 10_u32)]
    PX_FMT_RENDERSPEC = 10,
    #[br(magic = 11_u32)]
    PX_FMT_1CH = 11,
    #[br(magic = 12_u32)]
    PX_FMT_2CH = 12,
    #[br(magic = 13_u32)]
    PX_FMT_3CH = 13,
    #[br(magic = 14_u32)]
    PX_FMT_4CH = 14,
    #[br(magic = 15_u32)]
    PX_FMT_DEPTH_STENCIL = 15,
    #[br(magic = 16_u32)]
    PX_FMT_UNKNOWN = 16,
}

impl TryFrom<usize> for PixelFormat {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(PixelFormat::PX_FMT_RGB),
            1 => Ok(PixelFormat::PX_FMT_RGBA),
            2 => Ok(PixelFormat::PX_FMT_PAL),
            3 => Ok(PixelFormat::PX_FMT_PALA),
            4 => Ok(PixelFormat::PX_FMT_DXT1),
            5 => Ok(PixelFormat::PX_FMT_DXT3),
            6 => Ok(PixelFormat::PX_FMT_DXT5),
            7 => Ok(PixelFormat::PX_FMT_RGB24NONINT),
            8 => Ok(PixelFormat::PX_FMT_BUMP),
            9 => Ok(PixelFormat::PX_FMT_BUMPLUMA),
            10 => Ok(PixelFormat::PX_FMT_RENDERSPEC),
            11 => Ok(PixelFormat::PX_FMT_1CH),
            12 => Ok(PixelFormat::PX_FMT_2CH),
            13 => Ok(PixelFormat::PX_FMT_3CH),
            14 => Ok(PixelFormat::PX_FMT_4CH),
            15 => Ok(PixelFormat::PX_FMT_DEPTH_STENCIL),
            16 => Ok(PixelFormat::PX_FMT_UNKNOWN),
            _ => Err(()),
        }
    }
}

/// Describes whether pixels have been tiled from their standard row-major format to a format optimized for a particular platform.
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum PixelTiling {
    #[br(magic = 0_u32)]
    PX_TILE_NONE = 0,
    #[br(magic = 1_u32)]
    PX_TILE_XENON = 1,
    #[br(magic = 2_u32)]
    PX_TILE_WII = 2,
    #[br(magic = 3_u32)]
    PX_TILE_NV_SWIZZLED = 3,
}

impl TryFrom<usize> for PixelTiling {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(PixelTiling::PX_TILE_NONE),
            1 => Ok(PixelTiling::PX_TILE_XENON),
            2 => Ok(PixelTiling::PX_TILE_WII),
            3 => Ok(PixelTiling::PX_TILE_NV_SWIZZLED),
            _ => Err(()),
        }
    }
}

/// Describes the pixel format used by the NiPixelData object to store a texture.
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum PixelComponent {
    #[br(magic = 0_u32)]
    PX_COMP_RED = 0,
    #[br(magic = 1_u32)]
    PX_COMP_GREEN = 1,
    #[br(magic = 2_u32)]
    PX_COMP_BLUE = 2,
    #[br(magic = 3_u32)]
    PX_COMP_ALPHA = 3,
    #[br(magic = 4_u32)]
    PX_COMP_COMPRESSED = 4,
    #[br(magic = 5_u32)]
    PX_COMP_OFFSET_U = 5,
    #[br(magic = 6_u32)]
    PX_COMP_OFFSET_V = 6,
    #[br(magic = 7_u32)]
    PX_COMP_OFFSET_W = 7,
    #[br(magic = 8_u32)]
    PX_COMP_OFFSET_Q = 8,
    #[br(magic = 9_u32)]
    PX_COMP_LUMA = 9,
    #[br(magic = 10_u32)]
    PX_COMP_HEIGHT = 10,
    #[br(magic = 11_u32)]
    PX_COMP_VECTOR_X = 11,
    #[br(magic = 12_u32)]
    PX_COMP_VECTOR_Y = 12,
    #[br(magic = 13_u32)]
    PX_COMP_VECTOR_Z = 13,
    #[br(magic = 14_u32)]
    PX_COMP_PADDING = 14,
    #[br(magic = 15_u32)]
    PX_COMP_INTENSITY = 15,
    #[br(magic = 16_u32)]
    PX_COMP_INDEX = 16,
    #[br(magic = 17_u32)]
    PX_COMP_DEPTH = 17,
    #[br(magic = 18_u32)]
    PX_COMP_STENCIL = 18,
    #[br(magic = 19_u32)]
    PX_COMP_EMPTY = 19,
}

impl TryFrom<usize> for PixelComponent {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(PixelComponent::PX_COMP_RED),
            1 => Ok(PixelComponent::PX_COMP_GREEN),
            2 => Ok(PixelComponent::PX_COMP_BLUE),
            3 => Ok(PixelComponent::PX_COMP_ALPHA),
            4 => Ok(PixelComponent::PX_COMP_COMPRESSED),
            5 => Ok(PixelComponent::PX_COMP_OFFSET_U),
            6 => Ok(PixelComponent::PX_COMP_OFFSET_V),
            7 => Ok(PixelComponent::PX_COMP_OFFSET_W),
            8 => Ok(PixelComponent::PX_COMP_OFFSET_Q),
            9 => Ok(PixelComponent::PX_COMP_LUMA),
            10 => Ok(PixelComponent::PX_COMP_HEIGHT),
            11 => Ok(PixelComponent::PX_COMP_VECTOR_X),
            12 => Ok(PixelComponent::PX_COMP_VECTOR_Y),
            13 => Ok(PixelComponent::PX_COMP_VECTOR_Z),
            14 => Ok(PixelComponent::PX_COMP_PADDING),
            15 => Ok(PixelComponent::PX_COMP_INTENSITY),
            16 => Ok(PixelComponent::PX_COMP_INDEX),
            17 => Ok(PixelComponent::PX_COMP_DEPTH),
            18 => Ok(PixelComponent::PX_COMP_STENCIL),
            19 => Ok(PixelComponent::PX_COMP_EMPTY),
            _ => Err(()),
        }
    }
}

/// Describes how each pixel should be accessed on NiPixelFormat.
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum PixelRepresentation {
    #[br(magic = 0_u32)]
    PX_REP_NORM_INT = 0,
    #[br(magic = 1_u32)]
    PX_REP_HALF = 1,
    #[br(magic = 2_u32)]
    PX_REP_FLOAT = 2,
    #[br(magic = 3_u32)]
    PX_REP_INDEX = 3,
    #[br(magic = 4_u32)]
    PX_REP_COMPRESSED = 4,
    #[br(magic = 5_u32)]
    PX_REP_UNKNOWN = 5,
    #[br(magic = 6_u32)]
    PX_REP_INT = 6,
}

impl TryFrom<usize> for PixelRepresentation {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(PixelRepresentation::PX_REP_NORM_INT),
            1 => Ok(PixelRepresentation::PX_REP_HALF),
            2 => Ok(PixelRepresentation::PX_REP_FLOAT),
            3 => Ok(PixelRepresentation::PX_REP_INDEX),
            4 => Ok(PixelRepresentation::PX_REP_COMPRESSED),
            5 => Ok(PixelRepresentation::PX_REP_UNKNOWN),
            6 => Ok(PixelRepresentation::PX_REP_INT),
            _ => Err(()),
        }
    }
}

/// Describes the color depth in an NiTexture.
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum PixelLayout {
    #[br(magic = 0_u32)]
    PX_LAY_PALETTIZED_8 = 0,
    #[br(magic = 1_u32)]
    PX_LAY_HIGH_COLOR_16 = 1,
    #[br(magic = 2_u32)]
    PX_LAY_TRUE_COLOR_32 = 2,
    #[br(magic = 3_u32)]
    PX_LAY_COMPRESSED = 3,
    #[br(magic = 4_u32)]
    PX_LAY_BUMPMAP = 4,
    #[br(magic = 5_u32)]
    PX_LAY_PALETTIZED_4 = 5,
    #[br(magic = 6_u32)]
    PX_LAY_DEFAULT = 6,
    #[br(magic = 7_u32)]
    PX_LAY_SINGLE_COLOR_8 = 7,
    #[br(magic = 8_u32)]
    PX_LAY_SINGLE_COLOR_16 = 8,
    #[br(magic = 9_u32)]
    PX_LAY_SINGLE_COLOR_32 = 9,
    #[br(magic = 10_u32)]
    PX_LAY_DOUBLE_COLOR_32 = 10,
    #[br(magic = 11_u32)]
    PX_LAY_DOUBLE_COLOR_64 = 11,
    #[br(magic = 12_u32)]
    PX_LAY_FLOAT_COLOR_32 = 12,
    #[br(magic = 13_u32)]
    PX_LAY_FLOAT_COLOR_64 = 13,
    #[br(magic = 14_u32)]
    PX_LAY_FLOAT_COLOR_128 = 14,
    #[br(magic = 15_u32)]
    PX_LAY_SINGLE_COLOR_4 = 15,
    #[br(magic = 16_u32)]
    PX_LAY_DEPTH_24_X8 = 16,
}

impl TryFrom<usize> for PixelLayout {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(PixelLayout::PX_LAY_PALETTIZED_8),
            1 => Ok(PixelLayout::PX_LAY_HIGH_COLOR_16),
            2 => Ok(PixelLayout::PX_LAY_TRUE_COLOR_32),
            3 => Ok(PixelLayout::PX_LAY_COMPRESSED),
            4 => Ok(PixelLayout::PX_LAY_BUMPMAP),
            5 => Ok(PixelLayout::PX_LAY_PALETTIZED_4),
            6 => Ok(PixelLayout::PX_LAY_DEFAULT),
            7 => Ok(PixelLayout::PX_LAY_SINGLE_COLOR_8),
            8 => Ok(PixelLayout::PX_LAY_SINGLE_COLOR_16),
            9 => Ok(PixelLayout::PX_LAY_SINGLE_COLOR_32),
            10 => Ok(PixelLayout::PX_LAY_DOUBLE_COLOR_32),
            11 => Ok(PixelLayout::PX_LAY_DOUBLE_COLOR_64),
            12 => Ok(PixelLayout::PX_LAY_FLOAT_COLOR_32),
            13 => Ok(PixelLayout::PX_LAY_FLOAT_COLOR_64),
            14 => Ok(PixelLayout::PX_LAY_FLOAT_COLOR_128),
            15 => Ok(PixelLayout::PX_LAY_SINGLE_COLOR_4),
            16 => Ok(PixelLayout::PX_LAY_DEPTH_24_X8),
            _ => Err(()),
        }
    }
}

/// Describes how mipmaps are handled in an NiTexture.
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum MipMapFormat {
    #[br(magic = 0_u32)]
    MIP_FMT_NO = 0,
    #[br(magic = 1_u32)]
    MIP_FMT_YES = 1,
    #[br(magic = 2_u32)]
    MIP_FMT_DEFAULT = 2,
}

impl TryFrom<usize> for MipMapFormat {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(MipMapFormat::MIP_FMT_NO),
            1 => Ok(MipMapFormat::MIP_FMT_YES),
            2 => Ok(MipMapFormat::MIP_FMT_DEFAULT),
            _ => Err(()),
        }
    }
}

/// Describes how transparency is handled in an NiTexture.
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum AlphaFormat {
    #[br(magic = 0_u32)]
    ALPHA_NONE = 0,
    #[br(magic = 1_u32)]
    ALPHA_BINARY = 1,
    #[br(magic = 2_u32)]
    ALPHA_SMOOTH = 2,
    #[br(magic = 3_u32)]
    ALPHA_DEFAULT = 3,
}

impl TryFrom<usize> for AlphaFormat {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(AlphaFormat::ALPHA_NONE),
            1 => Ok(AlphaFormat::ALPHA_BINARY),
            2 => Ok(AlphaFormat::ALPHA_SMOOTH),
            3 => Ok(AlphaFormat::ALPHA_DEFAULT),
            _ => Err(()),
        }
    }
}

/// Describes the availiable texture clamp modes, i.e. the behavior of UV mapping outside the \[0,1\] range.
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum TexClampMode {
    #[br(magic = 0_u32)]
    CLAMP_S_CLAMP_T = 0,
    #[br(magic = 1_u32)]
    CLAMP_S_WRAP_T = 1,
    #[br(magic = 2_u32)]
    WRAP_S_CLAMP_T = 2,
    #[br(magic = 3_u32)]
    WRAP_S_WRAP_T = 3,
}

impl TryFrom<usize> for TexClampMode {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(TexClampMode::CLAMP_S_CLAMP_T),
            1 => Ok(TexClampMode::CLAMP_S_WRAP_T),
            2 => Ok(TexClampMode::WRAP_S_CLAMP_T),
            3 => Ok(TexClampMode::WRAP_S_WRAP_T),
            _ => Err(()),
        }
    }
}

/// Describes the availiable texture filter modes, i.e. the way the pixels in a texture are displayed on screen.
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum TexFilterMode {
    #[br(magic = 0_u32)]
    FILTER_NEAREST = 0,
    #[br(magic = 1_u32)]
    FILTER_BILERP = 1,
    #[br(magic = 2_u32)]
    FILTER_TRILERP = 2,
    #[br(magic = 3_u32)]
    FILTER_NEAREST_MIPNEAREST = 3,
    #[br(magic = 4_u32)]
    FILTER_NEAREST_MIPLERP = 4,
    #[br(magic = 5_u32)]
    FILTER_BILERP_MIPNEAREST = 5,
    #[br(magic = 6_u32)]
    FILTER_ANISOTROPIC = 6,
}

impl TryFrom<usize> for TexFilterMode {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(TexFilterMode::FILTER_NEAREST),
            1 => Ok(TexFilterMode::FILTER_BILERP),
            2 => Ok(TexFilterMode::FILTER_TRILERP),
            3 => Ok(TexFilterMode::FILTER_NEAREST_MIPNEAREST),
            4 => Ok(TexFilterMode::FILTER_NEAREST_MIPLERP),
            5 => Ok(TexFilterMode::FILTER_BILERP_MIPNEAREST),
            6 => Ok(TexFilterMode::FILTER_ANISOTROPIC),
            _ => Err(()),
        }
    }
}

/// Describes how to apply vertex colors for NiVertexColorProperty.
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum SourceVertexMode {
    #[br(magic = 0_u32)]
    VERT_MODE_SRC_IGNORE = 0,
    #[br(magic = 1_u32)]
    VERT_MODE_SRC_EMISSIVE = 1,
    #[br(magic = 2_u32)]
    VERT_MODE_SRC_AMB_DIF = 2,
}

impl TryFrom<usize> for SourceVertexMode {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(SourceVertexMode::VERT_MODE_SRC_IGNORE),
            1 => Ok(SourceVertexMode::VERT_MODE_SRC_EMISSIVE),
            2 => Ok(SourceVertexMode::VERT_MODE_SRC_AMB_DIF),
            _ => Err(()),
        }
    }
}

/// Describes which lighting equation components influence the final vertex color for NiVertexColorProperty.
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum LightingMode {
    #[br(magic = 0_u32)]
    LIGHT_MODE_EMISSIVE = 0,
    #[br(magic = 1_u32)]
    LIGHT_MODE_EMI_AMB_DIF = 1,
}

impl TryFrom<usize> for LightingMode {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(LightingMode::LIGHT_MODE_EMISSIVE),
            1 => Ok(LightingMode::LIGHT_MODE_EMI_AMB_DIF),
            _ => Err(()),
        }
    }
}

/// The animation cyle behavior.
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum CycleType {
    #[br(magic = 0_u32)]
    CYCLE_LOOP = 0,
    #[br(magic = 1_u32)]
    CYCLE_REVERSE = 1,
    #[br(magic = 2_u32)]
    CYCLE_CLAMP = 2,
}

impl TryFrom<usize> for CycleType {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(CycleType::CYCLE_LOOP),
            1 => Ok(CycleType::CYCLE_REVERSE),
            2 => Ok(CycleType::CYCLE_CLAMP),
            _ => Err(()),
        }
    }
}

/// The force field type.
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum FieldType {
    #[br(magic = 0_u32)]
    FIELD_WIND = 0,
    #[br(magic = 1_u32)]
    FIELD_POINT = 1,
}

impl TryFrom<usize> for FieldType {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(FieldType::FIELD_WIND),
            1 => Ok(FieldType::FIELD_POINT),
            _ => Err(()),
        }
    }
}

/// Determines the way the billboard will react to the camera.
/// Billboard mode is stored in lowest 3 bits although Oblivion vanilla nifs uses values higher than 7.
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u16)]
pub enum BillboardMode {
    #[br(magic = 0_u16)]
    ALWAYS_FACE_CAMERA = 0,
    #[br(magic = 1_u16)]
    ROTATE_ABOUT_UP = 1,
    #[br(magic = 2_u16)]
    RIGID_FACE_CAMERA = 2,
    #[br(magic = 3_u16)]
    ALWAYS_FACE_CENTER = 3,
    #[br(magic = 4_u16)]
    RIGID_FACE_CENTER = 4,
    #[br(magic = 5_u16)]
    BSROTATE_ABOUT_UP = 5,
    #[br(magic = 9_u16)]
    ROTATE_ABOUT_UP2 = 9,
}

impl TryFrom<usize> for BillboardMode {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(BillboardMode::ALWAYS_FACE_CAMERA),
            1 => Ok(BillboardMode::ROTATE_ABOUT_UP),
            2 => Ok(BillboardMode::RIGID_FACE_CAMERA),
            3 => Ok(BillboardMode::ALWAYS_FACE_CENTER),
            4 => Ok(BillboardMode::RIGID_FACE_CENTER),
            5 => Ok(BillboardMode::BSROTATE_ABOUT_UP),
            9 => Ok(BillboardMode::ROTATE_ABOUT_UP2),
            _ => Err(()),
        }
    }
}

/// Describes stencil buffer test modes for NiStencilProperty.
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum StencilTestFunc {
    #[br(magic = 0_u32)]
    STENCIL_TEST_NEVER = 0,
    #[br(magic = 1_u32)]
    STENCIL_TEST_LESS = 1,
    #[br(magic = 2_u32)]
    STENCIL_TEST_EQUAL = 2,
    #[br(magic = 3_u32)]
    STENCIL_TEST_LESS_EQUAL = 3,
    #[br(magic = 4_u32)]
    STENCIL_TEST_GREATER = 4,
    #[br(magic = 5_u32)]
    STENCIL_TEST_NOT_EQUAL = 5,
    #[br(magic = 6_u32)]
    STENCIL_TEST_GREATER_EQUAL = 6,
    #[br(magic = 7_u32)]
    STENCIL_TEST_ALWAYS = 7,
}

impl TryFrom<usize> for StencilTestFunc {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(StencilTestFunc::STENCIL_TEST_NEVER),
            1 => Ok(StencilTestFunc::STENCIL_TEST_LESS),
            2 => Ok(StencilTestFunc::STENCIL_TEST_EQUAL),
            3 => Ok(StencilTestFunc::STENCIL_TEST_LESS_EQUAL),
            4 => Ok(StencilTestFunc::STENCIL_TEST_GREATER),
            5 => Ok(StencilTestFunc::STENCIL_TEST_NOT_EQUAL),
            6 => Ok(StencilTestFunc::STENCIL_TEST_GREATER_EQUAL),
            7 => Ok(StencilTestFunc::STENCIL_TEST_ALWAYS),
            _ => Err(()),
        }
    }
}

/// Describes the actions which can occur as a result of tests for NiStencilProperty.
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum StencilAction {
    #[br(magic = 0_u32)]
    ACTION_KEEP = 0,
    #[br(magic = 1_u32)]
    ACTION_ZERO = 1,
    #[br(magic = 2_u32)]
    ACTION_REPLACE = 2,
    #[br(magic = 3_u32)]
    ACTION_INCREMENT = 3,
    #[br(magic = 4_u32)]
    ACTION_DECREMENT = 4,
    #[br(magic = 5_u32)]
    ACTION_INVERT = 5,
}

impl TryFrom<usize> for StencilAction {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(StencilAction::ACTION_KEEP),
            1 => Ok(StencilAction::ACTION_ZERO),
            2 => Ok(StencilAction::ACTION_REPLACE),
            3 => Ok(StencilAction::ACTION_INCREMENT),
            4 => Ok(StencilAction::ACTION_DECREMENT),
            5 => Ok(StencilAction::ACTION_INVERT),
            _ => Err(()),
        }
    }
}

/// Describes the face culling options for NiStencilProperty.
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum StencilDrawMode {
    #[br(magic = 0_u32)]
    DRAW_CCW_OR_BOTH = 0,
    #[br(magic = 1_u32)]
    DRAW_CCW = 1,
    #[br(magic = 2_u32)]
    DRAW_CW = 2,
    #[br(magic = 3_u32)]
    DRAW_BOTH = 3,
}

impl TryFrom<usize> for StencilDrawMode {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(StencilDrawMode::DRAW_CCW_OR_BOTH),
            1 => Ok(StencilDrawMode::DRAW_CCW),
            2 => Ok(StencilDrawMode::DRAW_CW),
            3 => Ok(StencilDrawMode::DRAW_BOTH),
            _ => Err(()),
        }
    }
}

/// Describes Z-buffer test modes for NiZBufferProperty.
/// "Less than" = closer to camera, "Greater than" = further from camera.
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum TestFunction {
    #[br(magic = 0_u32)]
    TEST_ALWAYS = 0,
    #[br(magic = 1_u32)]
    TEST_LESS = 1,
    #[br(magic = 2_u32)]
    TEST_EQUAL = 2,
    #[br(magic = 3_u32)]
    TEST_LESS_EQUAL = 3,
    #[br(magic = 4_u32)]
    TEST_GREATER = 4,
    #[br(magic = 5_u32)]
    TEST_NOT_EQUAL = 5,
    #[br(magic = 6_u32)]
    TEST_GREATER_EQUAL = 6,
    #[br(magic = 7_u32)]
    TEST_NEVER = 7,
}

impl TryFrom<usize> for TestFunction {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(TestFunction::TEST_ALWAYS),
            1 => Ok(TestFunction::TEST_LESS),
            2 => Ok(TestFunction::TEST_EQUAL),
            3 => Ok(TestFunction::TEST_LESS_EQUAL),
            4 => Ok(TestFunction::TEST_GREATER),
            5 => Ok(TestFunction::TEST_NOT_EQUAL),
            6 => Ok(TestFunction::TEST_GREATER_EQUAL),
            7 => Ok(TestFunction::TEST_NEVER),
            _ => Err(()),
        }
    }
}

/// Describes alpha blend modes for NiAlphaProperty.
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u16)]
pub enum AlphaFunction {
    #[br(magic = 0_u16)]
    ALPHA_ONE = 0,
    #[br(magic = 1_u16)]
    ALPHA_ZERO = 1,
    #[br(magic = 2_u16)]
    ALPHA_SRC_COLOR = 2,
    #[br(magic = 3_u16)]
    ALPHA_INV_SRC_COLOR = 3,
    #[br(magic = 4_u16)]
    ALPHA_DEST_COLOR = 4,
    #[br(magic = 5_u16)]
    ALPHA_INV_DEST_COLOR = 5,
    #[br(magic = 6_u16)]
    ALPHA_SRC_ALPHA = 6,
    #[br(magic = 7_u16)]
    ALPHA_INV_SRC_ALPHA = 7,
    #[br(magic = 8_u16)]
    ALPHA_DEST_ALPHA = 8,
    #[br(magic = 9_u16)]
    ALPHA_INV_DEST_ALPHA = 9,
    #[br(magic = 10_u16)]
    ALPHA_SRC_ALPHA_SATURATE = 10,
}

impl TryFrom<usize> for AlphaFunction {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(AlphaFunction::ALPHA_ONE),
            1 => Ok(AlphaFunction::ALPHA_ZERO),
            2 => Ok(AlphaFunction::ALPHA_SRC_COLOR),
            3 => Ok(AlphaFunction::ALPHA_INV_SRC_COLOR),
            4 => Ok(AlphaFunction::ALPHA_DEST_COLOR),
            5 => Ok(AlphaFunction::ALPHA_INV_DEST_COLOR),
            6 => Ok(AlphaFunction::ALPHA_SRC_ALPHA),
            7 => Ok(AlphaFunction::ALPHA_INV_SRC_ALPHA),
            8 => Ok(AlphaFunction::ALPHA_DEST_ALPHA),
            9 => Ok(AlphaFunction::ALPHA_INV_DEST_ALPHA),
            10 => Ok(AlphaFunction::ALPHA_SRC_ALPHA_SATURATE),
            _ => Err(()),
        }
    }
}

/// Describes the type of gravitational force.
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum ForceType {
    #[br(magic = 0_u32)]
    FORCE_PLANAR = 0,
    #[br(magic = 1_u32)]
    FORCE_SPHERICAL = 1,
    #[br(magic = 2_u32)]
    FORCE_UNKNOWN = 2,
}

impl TryFrom<usize> for ForceType {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(ForceType::FORCE_PLANAR),
            1 => Ok(ForceType::FORCE_SPHERICAL),
            2 => Ok(ForceType::FORCE_UNKNOWN),
            _ => Err(()),
        }
    }
}

/// Describes which aspect of the NiTextureTransform the NiTextureTransformController will modify.
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum TransformMember {
    #[br(magic = 0_u32)]
    TT_TRANSLATE_U = 0,
    #[br(magic = 1_u32)]
    TT_TRANSLATE_V = 1,
    #[br(magic = 2_u32)]
    TT_ROTATE = 2,
    #[br(magic = 3_u32)]
    TT_SCALE_U = 3,
    #[br(magic = 4_u32)]
    TT_SCALE_V = 4,
}

impl TryFrom<usize> for TransformMember {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(TransformMember::TT_TRANSLATE_U),
            1 => Ok(TransformMember::TT_TRANSLATE_V),
            2 => Ok(TransformMember::TT_ROTATE),
            3 => Ok(TransformMember::TT_SCALE_U),
            4 => Ok(TransformMember::TT_SCALE_V),
            _ => Err(()),
        }
    }
}

/// Describes the decay function of bomb forces.
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum DecayType {
    #[br(magic = 0_u32)]
    DECAY_NONE = 0,
    #[br(magic = 1_u32)]
    DECAY_LINEAR = 1,
    #[br(magic = 2_u32)]
    DECAY_EXPONENTIAL = 2,
}

impl TryFrom<usize> for DecayType {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(DecayType::DECAY_NONE),
            1 => Ok(DecayType::DECAY_LINEAR),
            2 => Ok(DecayType::DECAY_EXPONENTIAL),
            _ => Err(()),
        }
    }
}

/// Describes the symmetry type of bomb forces.
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum SymmetryType {
    #[br(magic = 0_u32)]
    SPHERICAL_SYMMETRY = 0,
    #[br(magic = 1_u32)]
    CYLINDRICAL_SYMMETRY = 1,
    #[br(magic = 2_u32)]
    PLANAR_SYMMETRY = 2,
}

impl TryFrom<usize> for SymmetryType {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(SymmetryType::SPHERICAL_SYMMETRY),
            1 => Ok(SymmetryType::CYLINDRICAL_SYMMETRY),
            2 => Ok(SymmetryType::PLANAR_SYMMETRY),
            _ => Err(()),
        }
    }
}

/// Controls the way the a particle mesh emitter determines the starting speed and direction of the particles that are emitted.
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum VelocityType {
    #[br(magic = 0_u32)]
    VELOCITY_USE_NORMALS = 0,
    #[br(magic = 1_u32)]
    VELOCITY_USE_RANDOM = 1,
    #[br(magic = 2_u32)]
    VELOCITY_USE_DIRECTION = 2,
}

impl TryFrom<usize> for VelocityType {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(VelocityType::VELOCITY_USE_NORMALS),
            1 => Ok(VelocityType::VELOCITY_USE_RANDOM),
            2 => Ok(VelocityType::VELOCITY_USE_DIRECTION),
            _ => Err(()),
        }
    }
}

/// Controls which parts of the mesh that the particles are emitted from.
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum EmitFrom {
    #[br(magic = 0_u32)]
    EMIT_FROM_VERTICES = 0,
    #[br(magic = 1_u32)]
    EMIT_FROM_FACE_CENTER = 1,
    #[br(magic = 2_u32)]
    EMIT_FROM_EDGE_CENTER = 2,
    #[br(magic = 3_u32)]
    EMIT_FROM_FACE_SURFACE = 3,
    #[br(magic = 4_u32)]
    EMIT_FROM_EDGE_SURFACE = 4,
}

impl TryFrom<usize> for EmitFrom {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(EmitFrom::EMIT_FROM_VERTICES),
            1 => Ok(EmitFrom::EMIT_FROM_FACE_CENTER),
            2 => Ok(EmitFrom::EMIT_FROM_EDGE_CENTER),
            3 => Ok(EmitFrom::EMIT_FROM_FACE_SURFACE),
            4 => Ok(EmitFrom::EMIT_FROM_EDGE_SURFACE),
            _ => Err(()),
        }
    }
}

/// The type of information that is stored in a texture used by an NiTextureEffect.
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum TextureType {
    #[br(magic = 0_u32)]
    TEX_PROJECTED_LIGHT = 0,
    #[br(magic = 1_u32)]
    TEX_PROJECTED_SHADOW = 1,
    #[br(magic = 2_u32)]
    TEX_ENVIRONMENT_MAP = 2,
    #[br(magic = 3_u32)]
    TEX_FOG_MAP = 3,
}

impl TryFrom<usize> for TextureType {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(TextureType::TEX_PROJECTED_LIGHT),
            1 => Ok(TextureType::TEX_PROJECTED_SHADOW),
            2 => Ok(TextureType::TEX_ENVIRONMENT_MAP),
            3 => Ok(TextureType::TEX_FOG_MAP),
            _ => Err(()),
        }
    }
}

/// Determines the way that UV texture coordinates are generated.
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum CoordGenType {
    #[br(magic = 0_u32)]
    CG_WORLD_PARALLEL = 0,
    #[br(magic = 1_u32)]
    CG_WORLD_PERSPECTIVE = 1,
    #[br(magic = 2_u32)]
    CG_SPHERE_MAP = 2,
    #[br(magic = 3_u32)]
    CG_SPECULAR_CUBE_MAP = 3,
    #[br(magic = 4_u32)]
    CG_DIFFUSE_CUBE_MAP = 4,
}

impl TryFrom<usize> for CoordGenType {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(CoordGenType::CG_WORLD_PARALLEL),
            1 => Ok(CoordGenType::CG_WORLD_PERSPECTIVE),
            2 => Ok(CoordGenType::CG_SPHERE_MAP),
            3 => Ok(CoordGenType::CG_SPECULAR_CUBE_MAP),
            4 => Ok(CoordGenType::CG_DIFFUSE_CUBE_MAP),
            _ => Err(()),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u8)]
pub enum EndianType {
    #[br(magic = 0_u8)]
    ENDIAN_BIG = 0,
    #[br(magic = 1_u8)]
    ENDIAN_LITTLE = 1,
}

impl TryFrom<usize> for EndianType {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(EndianType::ENDIAN_BIG),
            1 => Ok(EndianType::ENDIAN_LITTLE),
            _ => Err(()),
        }
    }
}

/// Used by NiMaterialColorControllers to select which type of color in the controlled object that will be animated.
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u16)]
pub enum MaterialColor {
    #[br(magic = 0_u16)]
    TC_AMBIENT = 0,
    #[br(magic = 1_u16)]
    TC_DIFFUSE = 1,
    #[br(magic = 2_u16)]
    TC_SPECULAR = 2,
    #[br(magic = 3_u16)]
    TC_SELF_ILLUM = 3,
}

impl TryFrom<usize> for MaterialColor {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(MaterialColor::TC_AMBIENT),
            1 => Ok(MaterialColor::TC_DIFFUSE),
            2 => Ok(MaterialColor::TC_SPECULAR),
            3 => Ok(MaterialColor::TC_SELF_ILLUM),
            _ => Err(()),
        }
    }
}

/// Used by NiLightColorControllers to select which type of color in the controlled object that will be animated.
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u16)]
pub enum LightColor {
    #[br(magic = 0_u16)]
    LC_DIFFUSE = 0,
    #[br(magic = 1_u16)]
    LC_AMBIENT = 1,
}

impl TryFrom<usize> for LightColor {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(LightColor::LC_DIFFUSE),
            1 => Ok(LightColor::LC_AMBIENT),
            _ => Err(()),
        }
    }
}

/// Used by NiGeometryData to control the volatility of the mesh.
/// Consistency Type is masked to only the upper 4 bits (0xF000). Dirty mask is the lower 12 (0x0FFF) but only used at runtime.
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u16)]
pub enum ConsistencyType {
    #[br(magic = 0_u16)]
    CT_MUTABLE = 0,
    #[br(magic = 16384_u16)]
    CT_STATIC = 16384,
    #[br(magic = 32768_u16)]
    CT_VOLATILE = 32768,
}

impl TryFrom<usize> for ConsistencyType {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(ConsistencyType::CT_MUTABLE),
            16384 => Ok(ConsistencyType::CT_STATIC),
            32768 => Ok(ConsistencyType::CT_VOLATILE),
            _ => Err(()),
        }
    }
}

/// Describes the way that NiSortAdjustNode modifies the sorting behavior for the subtree below it.
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum SortingMode {
    #[br(magic = 0_u32)]
    SORTING_INHERIT = 0,
    #[br(magic = 1_u32)]
    SORTING_OFF = 1,
}

impl TryFrom<usize> for SortingMode {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(SortingMode::SORTING_INHERIT),
            1 => Ok(SortingMode::SORTING_OFF),
            _ => Err(()),
        }
    }
}

/// The propagation mode controls scene graph traversal during collision detection operations for NiCollisionData.
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum PropagationMode {
    #[br(magic = 0_u32)]
    PROPAGATE_ON_SUCCESS = 0,
    #[br(magic = 1_u32)]
    PROPAGATE_ON_FAILURE = 1,
    #[br(magic = 2_u32)]
    PROPAGATE_ALWAYS = 2,
    #[br(magic = 3_u32)]
    PROPAGATE_NEVER = 3,
}

impl TryFrom<usize> for PropagationMode {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(PropagationMode::PROPAGATE_ON_SUCCESS),
            1 => Ok(PropagationMode::PROPAGATE_ON_FAILURE),
            2 => Ok(PropagationMode::PROPAGATE_ALWAYS),
            3 => Ok(PropagationMode::PROPAGATE_NEVER),
            _ => Err(()),
        }
    }
}

/// The collision mode controls the type of collision operation that is to take place for NiCollisionData.
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum CollisionMode {
    #[br(magic = 0_u32)]
    CM_USE_OBB = 0,
    #[br(magic = 1_u32)]
    CM_USE_TRI = 1,
    #[br(magic = 2_u32)]
    CM_USE_ABV = 2,
    #[br(magic = 3_u32)]
    CM_NOTEST = 3,
    #[br(magic = 4_u32)]
    CM_USE_NIBOUND = 4,
}

impl TryFrom<usize> for CollisionMode {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(CollisionMode::CM_USE_OBB),
            1 => Ok(CollisionMode::CM_USE_TRI),
            2 => Ok(CollisionMode::CM_USE_ABV),
            3 => Ok(CollisionMode::CM_NOTEST),
            4 => Ok(CollisionMode::CM_USE_NIBOUND),
            _ => Err(()),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum BoundVolumeType {
    #[br(magic = 4294967295_u32)]
    BASE_BV = 4294967295,
    #[br(magic = 0_u32)]
    SPHERE_BV = 0,
    #[br(magic = 1_u32)]
    BOX_BV = 1,
    #[br(magic = 2_u32)]
    CAPSULE_BV = 2,
    #[br(magic = 4_u32)]
    UNION_BV = 4,
    #[br(magic = 5_u32)]
    HALFSPACE_BV = 5,
}

impl TryFrom<usize> for BoundVolumeType {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            4294967295 => Ok(BoundVolumeType::BASE_BV),
            0 => Ok(BoundVolumeType::SPHERE_BV),
            1 => Ok(BoundVolumeType::BOX_BV),
            2 => Ok(BoundVolumeType::CAPSULE_BV),
            4 => Ok(BoundVolumeType::UNION_BV),
            5 => Ok(BoundVolumeType::HALFSPACE_BV),
            _ => Err(()),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u16)]
pub enum FogFunction {
    #[br(magic = 0_u16)]
    FOG_Z_LINEAR = 0,
    #[br(magic = 1_u16)]
    FOG_RANGE_SQ = 1,
    #[br(magic = 2_u16)]
    FOG_VERTEX_ALPHA = 2,
}

impl TryFrom<usize> for FogFunction {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(FogFunction::FOG_Z_LINEAR),
            1 => Ok(FogFunction::FOG_RANGE_SQ),
            2 => Ok(FogFunction::FOG_VERTEX_ALPHA),
            _ => Err(()),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u16)]
pub enum AnimType {
    #[br(magic = 0_u16)]
    APP_TIME = 0,
    #[br(magic = 1_u16)]
    APP_INIT = 1,
}

impl TryFrom<usize> for AnimType {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(AnimType::APP_TIME),
            1 => Ok(AnimType::APP_INIT),
            _ => Err(()),
        }
    }
}

/// Flags for NiDitherProperty
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u16)]
pub enum DitherFlags {
    #[br(magic = 0_u16)]
    DITHER_DISABLED = 0,
    #[br(magic = 1_u16)]
    DITHER_ENABLED = 1,
}

impl TryFrom<usize> for DitherFlags {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(DitherFlags::DITHER_DISABLED),
            1 => Ok(DitherFlags::DITHER_ENABLED),
            _ => Err(()),
        }
    }
}

/// Flags for NiShadeProperty
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u16)]
pub enum ShadeFlags {
    #[br(magic = 0_u16)]
    SHADING_HARD = 0,
    #[br(magic = 1_u16)]
    SHADING_SMOOTH = 1,
}

impl TryFrom<usize> for ShadeFlags {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(ShadeFlags::SHADING_HARD),
            1 => Ok(ShadeFlags::SHADING_SMOOTH),
            _ => Err(()),
        }
    }
}

/// Flags for NiSpecularProperty
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u16)]
pub enum SpecularFlags {
    #[br(magic = 0_u16)]
    SPECULAR_DISABLED = 0,
    #[br(magic = 1_u16)]
    SPECULAR_ENABLED = 1,
}

impl TryFrom<usize> for SpecularFlags {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(SpecularFlags::SPECULAR_DISABLED),
            1 => Ok(SpecularFlags::SPECULAR_ENABLED),
            _ => Err(()),
        }
    }
}

/// Flags for NiWireframeProperty
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u16)]
pub enum WireframeFlags {
    #[br(magic = 0_u16)]
    WIREFRAME_DISABLED = 0,
    #[br(magic = 1_u16)]
    WIREFRAME_ENABLED = 1,
}

impl TryFrom<usize> for WireframeFlags {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(WireframeFlags::WIREFRAME_DISABLED),
            1 => Ok(WireframeFlags::WIREFRAME_ENABLED),
            _ => Err(()),
        }
    }
}

/// Flags for NiGeomMorpherController
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u16)]
pub enum GeomMorpherFlags {
    #[br(magic = 0_u16)]
    UPDATE_NORMALS_DISABLED = 0,
    #[br(magic = 1_u16)]
    UPDATE_NORMALS_ENABLED = 1,
}

impl TryFrom<usize> for GeomMorpherFlags {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(GeomMorpherFlags::UPDATE_NORMALS_DISABLED),
            1 => Ok(GeomMorpherFlags::UPDATE_NORMALS_ENABLED),
            _ => Err(()),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u8)]
pub enum AGDConsistencyType {
    #[br(magic = 0_u8)]
    AGD_MUTABLE = 0,
    #[br(magic = 1_u8)]
    AGD_STATIC = 1,
    #[br(magic = 2_u8)]
    AGD_VOLATILE = 2,
}

impl TryFrom<usize> for AGDConsistencyType {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(AGDConsistencyType::AGD_MUTABLE),
            1 => Ok(AGDConsistencyType::AGD_STATIC),
            2 => Ok(AGDConsistencyType::AGD_VOLATILE),
            _ => Err(()),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u16)]
pub enum NiNBTMethod {
    #[br(magic = 0_u16)]
    NBT_METHOD_NONE = 0,
    #[br(magic = 1_u16)]
    NBT_METHOD_NDL = 1,
    #[br(magic = 2_u16)]
    NBT_METHOD_MAX = 2,
    #[br(magic = 3_u16)]
    NBT_METHOD_ATI = 3,
}

impl TryFrom<usize> for NiNBTMethod {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(NiNBTMethod::NBT_METHOD_NONE),
            1 => Ok(NiNBTMethod::NBT_METHOD_NDL),
            2 => Ok(NiNBTMethod::NBT_METHOD_MAX),
            3 => Ok(NiNBTMethod::NBT_METHOD_ATI),
            _ => Err(()),
        }
    }
}

/// Describes the order of scaling and rotation matrices. Translate, Scale, Rotation, Center are from TexDesc.
/// Back = inverse of Center. FromMaya = inverse of the V axis with a positive translation along V of 1 unit.
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum TransformMethod {
    #[br(magic = 0_u32)]
    TM_MayaDeprecated = 0,
    #[br(magic = 1_u32)]
    TM_Max = 1,
    #[br(magic = 2_u32)]
    TM_Maya = 2,
}

impl TryFrom<usize> for TransformMethod {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(TransformMethod::TM_MayaDeprecated),
            1 => Ok(TransformMethod::TM_Max),
            2 => Ok(TransformMethod::TM_Maya),
            _ => Err(()),
        }
    }
}

/// Determines how the raw image data is stored in NiRawImageData.
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum ImageType {
    #[br(magic = 1_u32)]
    RGB = 1,
    #[br(magic = 2_u32)]
    RGBA = 2,
}

impl TryFrom<usize> for ImageType {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            1 => Ok(ImageType::RGB),
            2 => Ok(ImageType::RGBA),
            _ => Err(()),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u8)]
pub enum InterpBlendFlags {
    #[br(magic = 1_u8)]
    MANAGER_CONTROLLED = 1,
}

impl TryFrom<usize> for InterpBlendFlags {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            1 => Ok(InterpBlendFlags::MANAGER_CONTROLLED),
            _ => Err(()),
        }
    }
}

/// The set order for each derived class of NiPSysModifier.
/// Note: For Skyrim, BSPSysStripUpdateModifier is 8000 and for FO3 it is 2500.
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum NiPSysModifierOrder {
    #[br(magic = 0_u32)]
    ORDER_KILLOLDPARTICLES = 0,
    #[br(magic = 1_u32)]
    ORDER_BSLOD = 1,
    #[br(magic = 1000_u32)]
    ORDER_EMITTER = 1000,
    #[br(magic = 2000_u32)]
    ORDER_SPAWN = 2000,
    #[br(magic = 2500_u32)]
    ORDER_FO3_BSSTRIPUPDATE = 2500,
    #[br(magic = 3000_u32)]
    ORDER_GENERAL = 3000,
    #[br(magic = 4000_u32)]
    ORDER_FORCE = 4000,
    #[br(magic = 5000_u32)]
    ORDER_COLLIDER = 5000,
    #[br(magic = 6000_u32)]
    ORDER_POS_UPDATE = 6000,
    #[br(magic = 6500_u32)]
    ORDER_POSTPOS_UPDATE = 6500,
    #[br(magic = 6600_u32)]
    ORDER_WORLDSHIFT_PARTSPAWN = 6600,
    #[br(magic = 7000_u32)]
    ORDER_BOUND_UPDATE = 7000,
    #[br(magic = 8000_u32)]
    ORDER_SK_BSSTRIPUPDATE = 8000,
}

impl TryFrom<usize> for NiPSysModifierOrder {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(NiPSysModifierOrder::ORDER_KILLOLDPARTICLES),
            1 => Ok(NiPSysModifierOrder::ORDER_BSLOD),
            1000 => Ok(NiPSysModifierOrder::ORDER_EMITTER),
            2000 => Ok(NiPSysModifierOrder::ORDER_SPAWN),
            2500 => Ok(NiPSysModifierOrder::ORDER_FO3_BSSTRIPUPDATE),
            3000 => Ok(NiPSysModifierOrder::ORDER_GENERAL),
            4000 => Ok(NiPSysModifierOrder::ORDER_FORCE),
            5000 => Ok(NiPSysModifierOrder::ORDER_COLLIDER),
            6000 => Ok(NiPSysModifierOrder::ORDER_POS_UPDATE),
            6500 => Ok(NiPSysModifierOrder::ORDER_POSTPOS_UPDATE),
            6600 => Ok(NiPSysModifierOrder::ORDER_WORLDSHIFT_PARTSPAWN),
            7000 => Ok(NiPSysModifierOrder::ORDER_BOUND_UPDATE),
            8000 => Ok(NiPSysModifierOrder::ORDER_SK_BSSTRIPUPDATE),
            _ => Err(()),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum NiSceneDescNxBroadPhaseType {
    #[br(magic = 0_u32)]
    NX_BROADPHASE_QUADRATIC = 0,
    #[br(magic = 1_u32)]
    NX_BROADPHASE_FULL = 1,
    #[br(magic = 2_u32)]
    NX_BROADPHASE_COHERENT = 2,
}

impl TryFrom<usize> for NiSceneDescNxBroadPhaseType {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(NiSceneDescNxBroadPhaseType::NX_BROADPHASE_QUADRATIC),
            1 => Ok(NiSceneDescNxBroadPhaseType::NX_BROADPHASE_FULL),
            2 => Ok(NiSceneDescNxBroadPhaseType::NX_BROADPHASE_COHERENT),
            _ => Err(()),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum NiSceneDescNxHwPipelineSpec {
    #[br(magic = 0_u32)]
    NX_HW_RB_PIPELINE_HLP_ONLY = 0,
    #[br(magic = 1_u32)]
    NX_HW_PIPELINE_FULL = 1,
    #[br(magic = 2_u32)]
    NX_HW_PIPELINE_DEBUG = 2,
}

impl TryFrom<usize> for NiSceneDescNxHwPipelineSpec {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(NiSceneDescNxHwPipelineSpec::NX_HW_RB_PIPELINE_HLP_ONLY),
            1 => Ok(NiSceneDescNxHwPipelineSpec::NX_HW_PIPELINE_FULL),
            2 => Ok(NiSceneDescNxHwPipelineSpec::NX_HW_PIPELINE_DEBUG),
            _ => Err(()),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum NiSceneDescNxHwSceneType {
    #[br(magic = 0_u32)]
    NX_HW_SCENE_TYPE_RB = 0,
    #[br(magic = 1_u32)]
    NX_HW_SCENE_TYPE_FLUID = 1,
    #[br(magic = 2_u32)]
    NX_HW_SCENE_TYPE_FLUID_SOFTWARE = 2,
    #[br(magic = 3_u32)]
    NX_HW_SCENE_TYPE_CLOTH = 3,
}

impl TryFrom<usize> for NiSceneDescNxHwSceneType {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(NiSceneDescNxHwSceneType::NX_HW_SCENE_TYPE_RB),
            1 => Ok(NiSceneDescNxHwSceneType::NX_HW_SCENE_TYPE_FLUID),
            2 => Ok(NiSceneDescNxHwSceneType::NX_HW_SCENE_TYPE_FLUID_SOFTWARE),
            3 => Ok(NiSceneDescNxHwSceneType::NX_HW_SCENE_TYPE_CLOTH),
            _ => Err(()),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum NxTimeStepMethod {
    #[br(magic = 0_u32)]
    NX_TIMESTEP_FIXED = 0,
    #[br(magic = 1_u32)]
    NX_TIMESTEP_VARIABLE = 1,
    #[br(magic = 2_u32)]
    NX_TIMESTEP_INHERIT = 2,
}

impl TryFrom<usize> for NxTimeStepMethod {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(NxTimeStepMethod::NX_TIMESTEP_FIXED),
            1 => Ok(NxTimeStepMethod::NX_TIMESTEP_VARIABLE),
            2 => Ok(NxTimeStepMethod::NX_TIMESTEP_INHERIT),
            _ => Err(()),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum NxSimulationType {
    #[br(magic = 0_u32)]
    NX_SIMULATION_SW = 0,
    #[br(magic = 1_u32)]
    NX_SIMULATION_HW = 1,
}

impl TryFrom<usize> for NxSimulationType {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(NxSimulationType::NX_SIMULATION_SW),
            1 => Ok(NxSimulationType::NX_SIMULATION_HW),
            _ => Err(()),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum NxBroadPhaseType {
    #[br(magic = 0_u32)]
    NX_BP_TYPE_SAP_SINGLE = 0,
    #[br(magic = 1_u32)]
    NX_BP_TYPE_SAP_MULTI = 1,
}

impl TryFrom<usize> for NxBroadPhaseType {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(NxBroadPhaseType::NX_BP_TYPE_SAP_SINGLE),
            1 => Ok(NxBroadPhaseType::NX_BP_TYPE_SAP_MULTI),
            _ => Err(()),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum NxFilterOp {
    #[br(magic = 0_u32)]
    NX_FILTEROP_AND = 0,
    #[br(magic = 1_u32)]
    NX_FILTEROP_OR = 1,
    #[br(magic = 2_u32)]
    NX_FILTEROP_XOR = 2,
    #[br(magic = 3_u32)]
    NX_FILTEROP_NAND = 3,
    #[br(magic = 4_u32)]
    NX_FILTEROP_NOR = 4,
    #[br(magic = 5_u32)]
    NX_FILTEROP_NXOR = 5,
    #[br(magic = 6_u32)]
    NX_FILTEROP_SWAP_AND = 6,
}

impl TryFrom<usize> for NxFilterOp {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(NxFilterOp::NX_FILTEROP_AND),
            1 => Ok(NxFilterOp::NX_FILTEROP_OR),
            2 => Ok(NxFilterOp::NX_FILTEROP_XOR),
            3 => Ok(NxFilterOp::NX_FILTEROP_NAND),
            4 => Ok(NxFilterOp::NX_FILTEROP_NOR),
            5 => Ok(NxFilterOp::NX_FILTEROP_NXOR),
            6 => Ok(NxFilterOp::NX_FILTEROP_SWAP_AND),
            _ => Err(()),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum NxThreadPriority {
    #[br(magic = 0_u32)]
    NX_TP_HIGH = 0,
    #[br(magic = 1_u32)]
    NX_TP_ABOVE_NORMAL = 1,
    #[br(magic = 2_u32)]
    NX_TP_NORMAL = 2,
    #[br(magic = 3_u32)]
    NX_TP_BELOW_NORMAL = 3,
    #[br(magic = 4_u32)]
    NX_TP_LOW = 4,
}

impl TryFrom<usize> for NxThreadPriority {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(NxThreadPriority::NX_TP_HIGH),
            1 => Ok(NxThreadPriority::NX_TP_ABOVE_NORMAL),
            2 => Ok(NxThreadPriority::NX_TP_NORMAL),
            3 => Ok(NxThreadPriority::NX_TP_BELOW_NORMAL),
            4 => Ok(NxThreadPriority::NX_TP_LOW),
            _ => Err(()),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum NxPruningStructure {
    #[br(magic = 0_u32)]
    NX_PRUNING_NONE = 0,
    #[br(magic = 1_u32)]
    NX_PRUNING_OCTREE = 1,
    #[br(magic = 2_u32)]
    NX_PRUNING_QUADTREE = 2,
    #[br(magic = 3_u32)]
    NX_PRUNING_DYNAMIC_AABB_TREE = 3,
    #[br(magic = 4_u32)]
    NX_PRUNING_STATIC_AABB_TREE = 4,
}

impl TryFrom<usize> for NxPruningStructure {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(NxPruningStructure::NX_PRUNING_NONE),
            1 => Ok(NxPruningStructure::NX_PRUNING_OCTREE),
            2 => Ok(NxPruningStructure::NX_PRUNING_QUADTREE),
            3 => Ok(NxPruningStructure::NX_PRUNING_DYNAMIC_AABB_TREE),
            4 => Ok(NxPruningStructure::NX_PRUNING_STATIC_AABB_TREE),
            _ => Err(()),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum NxCompartmentType {
    #[br(magic = 0_u32)]
    NX_SCT_RIGIDBODY = 0,
    #[br(magic = 1_u32)]
    NX_SCT_FLUID = 1,
    #[br(magic = 2_u32)]
    NX_SCT_CLOTH = 2,
}

impl TryFrom<usize> for NxCompartmentType {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(NxCompartmentType::NX_SCT_RIGIDBODY),
            1 => Ok(NxCompartmentType::NX_SCT_FLUID),
            2 => Ok(NxCompartmentType::NX_SCT_CLOTH),
            _ => Err(()),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum NxDeviceCode {
    #[br(magic = 0_u32)]
    NX_DC_PPU_0 = 0,
    #[br(magic = 1_u32)]
    NX_DC_PPU_1 = 1,
    #[br(magic = 2_u32)]
    NX_DC_PPU_2 = 2,
    #[br(magic = 3_u32)]
    NX_DC_PPU_3 = 3,
    #[br(magic = 4_u32)]
    NX_DC_PPU_4 = 4,
    #[br(magic = 5_u32)]
    NX_DC_PPU_5 = 5,
    #[br(magic = 6_u32)]
    NX_DC_PPU_6 = 6,
    #[br(magic = 7_u32)]
    NX_DC_PPU_7 = 7,
    #[br(magic = 8_u32)]
    NX_DC_PPU_8 = 8,
    #[br(magic = 4294901760_u32)]
    NX_DC_CPU = 4294901760,
    #[br(magic = 4294901761_u32)]
    NX_DC_PPU_AUTO_ASSIGN = 4294901761,
}

impl TryFrom<usize> for NxDeviceCode {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(NxDeviceCode::NX_DC_PPU_0),
            1 => Ok(NxDeviceCode::NX_DC_PPU_1),
            2 => Ok(NxDeviceCode::NX_DC_PPU_2),
            3 => Ok(NxDeviceCode::NX_DC_PPU_3),
            4 => Ok(NxDeviceCode::NX_DC_PPU_4),
            5 => Ok(NxDeviceCode::NX_DC_PPU_5),
            6 => Ok(NxDeviceCode::NX_DC_PPU_6),
            7 => Ok(NxDeviceCode::NX_DC_PPU_7),
            8 => Ok(NxDeviceCode::NX_DC_PPU_8),
            4294901760 => Ok(NxDeviceCode::NX_DC_CPU),
            4294901761 => Ok(NxDeviceCode::NX_DC_PPU_AUTO_ASSIGN),
            _ => Err(()),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum NxJointType {
    #[br(magic = 0_u32)]
    NX_JOINT_PRISMATIC = 0,
    #[br(magic = 1_u32)]
    NX_JOINT_REVOLUTE = 1,
    #[br(magic = 2_u32)]
    NX_JOINT_CYLINDRICAL = 2,
    #[br(magic = 3_u32)]
    NX_JOINT_SPHERICAL = 3,
    #[br(magic = 4_u32)]
    NX_JOINT_POINT_ON_LINE = 4,
    #[br(magic = 5_u32)]
    NX_JOINT_POINT_IN_PLANE = 5,
    #[br(magic = 6_u32)]
    NX_JOINT_DISTANCE = 6,
    #[br(magic = 7_u32)]
    NX_JOINT_PULLEY = 7,
    #[br(magic = 8_u32)]
    NX_JOINT_FIXED = 8,
    #[br(magic = 9_u32)]
    NX_JOINT_D6 = 9,
}

impl TryFrom<usize> for NxJointType {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(NxJointType::NX_JOINT_PRISMATIC),
            1 => Ok(NxJointType::NX_JOINT_REVOLUTE),
            2 => Ok(NxJointType::NX_JOINT_CYLINDRICAL),
            3 => Ok(NxJointType::NX_JOINT_SPHERICAL),
            4 => Ok(NxJointType::NX_JOINT_POINT_ON_LINE),
            5 => Ok(NxJointType::NX_JOINT_POINT_IN_PLANE),
            6 => Ok(NxJointType::NX_JOINT_DISTANCE),
            7 => Ok(NxJointType::NX_JOINT_PULLEY),
            8 => Ok(NxJointType::NX_JOINT_FIXED),
            9 => Ok(NxJointType::NX_JOINT_D6),
            _ => Err(()),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum NxD6JointMotion {
    #[br(magic = 0_u32)]
    NX_D6JOINT_MOTION_LOCKED = 0,
    #[br(magic = 1_u32)]
    NX_D6JOINT_MOTION_LIMITED = 1,
    #[br(magic = 2_u32)]
    NX_D6JOINT_MOTION_FREE = 2,
}

impl TryFrom<usize> for NxD6JointMotion {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(NxD6JointMotion::NX_D6JOINT_MOTION_LOCKED),
            1 => Ok(NxD6JointMotion::NX_D6JOINT_MOTION_LIMITED),
            2 => Ok(NxD6JointMotion::NX_D6JOINT_MOTION_FREE),
            _ => Err(()),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum NxD6JointDriveType {
    #[br(magic = 1_u32)]
    NX_D6JOINT_DRIVE_POSITION = 1,
    #[br(magic = 2_u32)]
    NX_D6JOINT_DRIVE_VELOCITY = 2,
}

impl TryFrom<usize> for NxD6JointDriveType {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            1 => Ok(NxD6JointDriveType::NX_D6JOINT_DRIVE_POSITION),
            2 => Ok(NxD6JointDriveType::NX_D6JOINT_DRIVE_VELOCITY),
            _ => Err(()),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum NxJointProjectionMode {
    #[br(magic = 0_u32)]
    NX_JPM_NONE = 0,
    #[br(magic = 1_u32)]
    NX_JPM_POINT_MINDIST = 1,
    #[br(magic = 2_u32)]
    NX_JPM_LINEAR_MINDIST = 2,
}

impl TryFrom<usize> for NxJointProjectionMode {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(NxJointProjectionMode::NX_JPM_NONE),
            1 => Ok(NxJointProjectionMode::NX_JPM_POINT_MINDIST),
            2 => Ok(NxJointProjectionMode::NX_JPM_LINEAR_MINDIST),
            _ => Err(()),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum NxShapeType {
    #[br(magic = 0_u32)]
    NX_SHAPE_PLANE = 0,
    #[br(magic = 1_u32)]
    NX_SHAPE_SPHERE = 1,
    #[br(magic = 2_u32)]
    NX_SHAPE_BOX = 2,
    #[br(magic = 3_u32)]
    NX_SHAPE_CAPSULE = 3,
    #[br(magic = 4_u32)]
    NX_SHAPE_WHEEL = 4,
    #[br(magic = 5_u32)]
    NX_SHAPE_CONVEX = 5,
    #[br(magic = 6_u32)]
    NX_SHAPE_MESH = 6,
    #[br(magic = 7_u32)]
    NX_SHAPE_HEIGHTFIELD = 7,
    #[br(magic = 8_u32)]
    NX_SHAPE_RAW_MESH = 8,
    #[br(magic = 9_u32)]
    NX_SHAPE_COMPOUND = 9,
}

impl TryFrom<usize> for NxShapeType {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(NxShapeType::NX_SHAPE_PLANE),
            1 => Ok(NxShapeType::NX_SHAPE_SPHERE),
            2 => Ok(NxShapeType::NX_SHAPE_BOX),
            3 => Ok(NxShapeType::NX_SHAPE_CAPSULE),
            4 => Ok(NxShapeType::NX_SHAPE_WHEEL),
            5 => Ok(NxShapeType::NX_SHAPE_CONVEX),
            6 => Ok(NxShapeType::NX_SHAPE_MESH),
            7 => Ok(NxShapeType::NX_SHAPE_HEIGHTFIELD),
            8 => Ok(NxShapeType::NX_SHAPE_RAW_MESH),
            9 => Ok(NxShapeType::NX_SHAPE_COMPOUND),
            _ => Err(()),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum NxCombineMode {
    #[br(magic = 0_u32)]
    NX_CM_AVERAGE = 0,
    #[br(magic = 1_u32)]
    NX_CM_MIN = 1,
    #[br(magic = 2_u32)]
    NX_CM_MULTIPLY = 2,
    #[br(magic = 3_u32)]
    NX_CM_MAX = 3,
}

impl TryFrom<usize> for NxCombineMode {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(NxCombineMode::NX_CM_AVERAGE),
            1 => Ok(NxCombineMode::NX_CM_MIN),
            2 => Ok(NxCombineMode::NX_CM_MULTIPLY),
            3 => Ok(NxCombineMode::NX_CM_MAX),
            _ => Err(()),
        }
    }
}

/// Sets how objects are to be cloned.
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum CloningBehavior {
    #[br(magic = 0_u32)]
    CLONING_SHARE = 0,
    #[br(magic = 1_u32)]
    CLONING_COPY = 1,
    #[br(magic = 2_u32)]
    CLONING_BLANK_COPY = 2,
}

impl TryFrom<usize> for CloningBehavior {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(CloningBehavior::CLONING_SHARE),
            1 => Ok(CloningBehavior::CLONING_COPY),
            2 => Ok(CloningBehavior::CLONING_BLANK_COPY),
            _ => Err(()),
        }
    }
}

/// The data format of components.
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum ComponentFormat {
    #[br(magic = 0_u32)]
    F_UNKNOWN = 0,
    #[br(magic = 65793_u32)]
    F_INT8_1 = 65793,
    #[br(magic = 131330_u32)]
    F_INT8_2 = 131330,
    #[br(magic = 196867_u32)]
    F_INT8_3 = 196867,
    #[br(magic = 262404_u32)]
    F_INT8_4 = 262404,
    #[br(magic = 65797_u32)]
    F_UINT8_1 = 65797,
    #[br(magic = 131334_u32)]
    F_UINT8_2 = 131334,
    #[br(magic = 196871_u32)]
    F_UINT8_3 = 196871,
    #[br(magic = 262408_u32)]
    F_UINT8_4 = 262408,
    #[br(magic = 65801_u32)]
    F_NORMINT8_1 = 65801,
    #[br(magic = 131338_u32)]
    F_NORMINT8_2 = 131338,
    #[br(magic = 196875_u32)]
    F_NORMINT8_3 = 196875,
    #[br(magic = 262412_u32)]
    F_NORMINT8_4 = 262412,
    #[br(magic = 65805_u32)]
    F_NORMUINT8_1 = 65805,
    #[br(magic = 131342_u32)]
    F_NORMUINT8_2 = 131342,
    #[br(magic = 196879_u32)]
    F_NORMUINT8_3 = 196879,
    #[br(magic = 262416_u32)]
    F_NORMUINT8_4 = 262416,
    #[br(magic = 66065_u32)]
    F_INT16_1 = 66065,
    #[br(magic = 131602_u32)]
    F_INT16_2 = 131602,
    #[br(magic = 197139_u32)]
    F_INT16_3 = 197139,
    #[br(magic = 262676_u32)]
    F_INT16_4 = 262676,
    #[br(magic = 66069_u32)]
    F_UINT16_1 = 66069,
    #[br(magic = 131606_u32)]
    F_UINT16_2 = 131606,
    #[br(magic = 197143_u32)]
    F_UINT16_3 = 197143,
    #[br(magic = 262680_u32)]
    F_UINT16_4 = 262680,
    #[br(magic = 66073_u32)]
    F_NORMINT16_1 = 66073,
    #[br(magic = 131610_u32)]
    F_NORMINT16_2 = 131610,
    #[br(magic = 197147_u32)]
    F_NORMINT16_3 = 197147,
    #[br(magic = 262684_u32)]
    F_NORMINT16_4 = 262684,
    #[br(magic = 66077_u32)]
    F_NORMUINT16_1 = 66077,
    #[br(magic = 131614_u32)]
    F_NORMUINT16_2 = 131614,
    #[br(magic = 197151_u32)]
    F_NORMUINT16_3 = 197151,
    #[br(magic = 262688_u32)]
    F_NORMUINT16_4 = 262688,
    #[br(magic = 66593_u32)]
    F_INT32_1 = 66593,
    #[br(magic = 132130_u32)]
    F_INT32_2 = 132130,
    #[br(magic = 197667_u32)]
    F_INT32_3 = 197667,
    #[br(magic = 263204_u32)]
    F_INT32_4 = 263204,
    #[br(magic = 66597_u32)]
    F_UINT32_1 = 66597,
    #[br(magic = 132134_u32)]
    F_UINT32_2 = 132134,
    #[br(magic = 197671_u32)]
    F_UINT32_3 = 197671,
    #[br(magic = 263208_u32)]
    F_UINT32_4 = 263208,
    #[br(magic = 66601_u32)]
    F_NORMINT32_1 = 66601,
    #[br(magic = 132138_u32)]
    F_NORMINT32_2 = 132138,
    #[br(magic = 197675_u32)]
    F_NORMINT32_3 = 197675,
    #[br(magic = 263212_u32)]
    F_NORMINT32_4 = 263212,
    #[br(magic = 66605_u32)]
    F_NORMUINT32_1 = 66605,
    #[br(magic = 132142_u32)]
    F_NORMUINT32_2 = 132142,
    #[br(magic = 197679_u32)]
    F_NORMUINT32_3 = 197679,
    #[br(magic = 263216_u32)]
    F_NORMUINT32_4 = 263216,
    #[br(magic = 66097_u32)]
    F_FLOAT16_1 = 66097,
    #[br(magic = 131634_u32)]
    F_FLOAT16_2 = 131634,
    #[br(magic = 197171_u32)]
    F_FLOAT16_3 = 197171,
    #[br(magic = 262708_u32)]
    F_FLOAT16_4 = 262708,
    #[br(magic = 66613_u32)]
    F_FLOAT32_1 = 66613,
    #[br(magic = 132150_u32)]
    F_FLOAT32_2 = 132150,
    #[br(magic = 197687_u32)]
    F_FLOAT32_3 = 197687,
    #[br(magic = 263224_u32)]
    F_FLOAT32_4 = 263224,
    #[br(magic = 66617_u32)]
    F_UINT_10_10_10_L1 = 66617,
    #[br(magic = 66618_u32)]
    F_NORMINT_10_10_10_L1 = 66618,
    #[br(magic = 66619_u32)]
    F_NORMINT_11_11_10 = 66619,
    #[br(magic = 262460_u32)]
    F_NORMUINT8_4_BGRA = 262460,
    #[br(magic = 66621_u32)]
    F_NORMINT_10_10_10_2 = 66621,
    #[br(magic = 66622_u32)]
    F_UINT_10_10_10_2 = 66622,
}

impl TryFrom<usize> for ComponentFormat {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(ComponentFormat::F_UNKNOWN),
            65793 => Ok(ComponentFormat::F_INT8_1),
            131330 => Ok(ComponentFormat::F_INT8_2),
            196867 => Ok(ComponentFormat::F_INT8_3),
            262404 => Ok(ComponentFormat::F_INT8_4),
            65797 => Ok(ComponentFormat::F_UINT8_1),
            131334 => Ok(ComponentFormat::F_UINT8_2),
            196871 => Ok(ComponentFormat::F_UINT8_3),
            262408 => Ok(ComponentFormat::F_UINT8_4),
            65801 => Ok(ComponentFormat::F_NORMINT8_1),
            131338 => Ok(ComponentFormat::F_NORMINT8_2),
            196875 => Ok(ComponentFormat::F_NORMINT8_3),
            262412 => Ok(ComponentFormat::F_NORMINT8_4),
            65805 => Ok(ComponentFormat::F_NORMUINT8_1),
            131342 => Ok(ComponentFormat::F_NORMUINT8_2),
            196879 => Ok(ComponentFormat::F_NORMUINT8_3),
            262416 => Ok(ComponentFormat::F_NORMUINT8_4),
            66065 => Ok(ComponentFormat::F_INT16_1),
            131602 => Ok(ComponentFormat::F_INT16_2),
            197139 => Ok(ComponentFormat::F_INT16_3),
            262676 => Ok(ComponentFormat::F_INT16_4),
            66069 => Ok(ComponentFormat::F_UINT16_1),
            131606 => Ok(ComponentFormat::F_UINT16_2),
            197143 => Ok(ComponentFormat::F_UINT16_3),
            262680 => Ok(ComponentFormat::F_UINT16_4),
            66073 => Ok(ComponentFormat::F_NORMINT16_1),
            131610 => Ok(ComponentFormat::F_NORMINT16_2),
            197147 => Ok(ComponentFormat::F_NORMINT16_3),
            262684 => Ok(ComponentFormat::F_NORMINT16_4),
            66077 => Ok(ComponentFormat::F_NORMUINT16_1),
            131614 => Ok(ComponentFormat::F_NORMUINT16_2),
            197151 => Ok(ComponentFormat::F_NORMUINT16_3),
            262688 => Ok(ComponentFormat::F_NORMUINT16_4),
            66593 => Ok(ComponentFormat::F_INT32_1),
            132130 => Ok(ComponentFormat::F_INT32_2),
            197667 => Ok(ComponentFormat::F_INT32_3),
            263204 => Ok(ComponentFormat::F_INT32_4),
            66597 => Ok(ComponentFormat::F_UINT32_1),
            132134 => Ok(ComponentFormat::F_UINT32_2),
            197671 => Ok(ComponentFormat::F_UINT32_3),
            263208 => Ok(ComponentFormat::F_UINT32_4),
            66601 => Ok(ComponentFormat::F_NORMINT32_1),
            132138 => Ok(ComponentFormat::F_NORMINT32_2),
            197675 => Ok(ComponentFormat::F_NORMINT32_3),
            263212 => Ok(ComponentFormat::F_NORMINT32_4),
            66605 => Ok(ComponentFormat::F_NORMUINT32_1),
            132142 => Ok(ComponentFormat::F_NORMUINT32_2),
            197679 => Ok(ComponentFormat::F_NORMUINT32_3),
            263216 => Ok(ComponentFormat::F_NORMUINT32_4),
            66097 => Ok(ComponentFormat::F_FLOAT16_1),
            131634 => Ok(ComponentFormat::F_FLOAT16_2),
            197171 => Ok(ComponentFormat::F_FLOAT16_3),
            262708 => Ok(ComponentFormat::F_FLOAT16_4),
            66613 => Ok(ComponentFormat::F_FLOAT32_1),
            132150 => Ok(ComponentFormat::F_FLOAT32_2),
            197687 => Ok(ComponentFormat::F_FLOAT32_3),
            263224 => Ok(ComponentFormat::F_FLOAT32_4),
            66617 => Ok(ComponentFormat::F_UINT_10_10_10_L1),
            66618 => Ok(ComponentFormat::F_NORMINT_10_10_10_L1),
            66619 => Ok(ComponentFormat::F_NORMINT_11_11_10),
            262460 => Ok(ComponentFormat::F_NORMUINT8_4_BGRA),
            66621 => Ok(ComponentFormat::F_NORMINT_10_10_10_2),
            66622 => Ok(ComponentFormat::F_UINT_10_10_10_2),
            _ => Err(()),
        }
    }
}

/// Determines how a data stream is used?
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum DataStreamUsage {
    #[br(magic = 0_u32)]
    USAGE_VERTEX_INDEX = 0,
    #[br(magic = 1_u32)]
    USAGE_VERTEX = 1,
    #[br(magic = 2_u32)]
    USAGE_SHADER_CONSTANT = 2,
    #[br(magic = 3_u32)]
    USAGE_USER = 3,
}

impl TryFrom<usize> for DataStreamUsage {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(DataStreamUsage::USAGE_VERTEX_INDEX),
            1 => Ok(DataStreamUsage::USAGE_VERTEX),
            2 => Ok(DataStreamUsage::USAGE_SHADER_CONSTANT),
            3 => Ok(DataStreamUsage::USAGE_USER),
            _ => Err(()),
        }
    }
}

/// Describes the type of primitives stored in a mesh object.
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum MeshPrimitiveType {
    #[br(magic = 0_u32)]
    MESH_PRIMITIVE_TRIANGLES = 0,
    #[br(magic = 1_u32)]
    MESH_PRIMITIVE_TRISTRIPS = 1,
    #[br(magic = 2_u32)]
    MESH_PRIMITIVE_LINES = 2,
    #[br(magic = 3_u32)]
    MESH_PRIMITIVE_LINESTRIPS = 3,
    #[br(magic = 4_u32)]
    MESH_PRIMITIVE_QUADS = 4,
    #[br(magic = 5_u32)]
    MESH_PRIMITIVE_POINTS = 5,
}

impl TryFrom<usize> for MeshPrimitiveType {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(MeshPrimitiveType::MESH_PRIMITIVE_TRIANGLES),
            1 => Ok(MeshPrimitiveType::MESH_PRIMITIVE_TRISTRIPS),
            2 => Ok(MeshPrimitiveType::MESH_PRIMITIVE_LINES),
            3 => Ok(MeshPrimitiveType::MESH_PRIMITIVE_LINESTRIPS),
            4 => Ok(MeshPrimitiveType::MESH_PRIMITIVE_QUADS),
            5 => Ok(MeshPrimitiveType::MESH_PRIMITIVE_POINTS),
            _ => Err(()),
        }
    }
}

/// A sync point corresponds to a particular stage in per-frame processing.
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u16)]
pub enum SyncPoint {
    #[br(magic = 32768_u16)]
    SYNC_ANY = 32768,
    #[br(magic = 32784_u16)]
    SYNC_UPDATE = 32784,
    #[br(magic = 32800_u16)]
    SYNC_POST_UPDATE = 32800,
    #[br(magic = 32816_u16)]
    SYNC_VISIBLE = 32816,
    #[br(magic = 32832_u16)]
    SYNC_RENDER = 32832,
    #[br(magic = 32848_u16)]
    SYNC_PHYSICS_SIMULATE = 32848,
    #[br(magic = 32864_u16)]
    SYNC_PHYSICS_COMPLETED = 32864,
    #[br(magic = 32880_u16)]
    SYNC_REFLECTIONS = 32880,
}

impl TryFrom<usize> for SyncPoint {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            32768 => Ok(SyncPoint::SYNC_ANY),
            32784 => Ok(SyncPoint::SYNC_UPDATE),
            32800 => Ok(SyncPoint::SYNC_POST_UPDATE),
            32816 => Ok(SyncPoint::SYNC_VISIBLE),
            32832 => Ok(SyncPoint::SYNC_RENDER),
            32848 => Ok(SyncPoint::SYNC_PHYSICS_SIMULATE),
            32864 => Ok(SyncPoint::SYNC_PHYSICS_COMPLETED),
            32880 => Ok(SyncPoint::SYNC_REFLECTIONS),
            _ => Err(()),
        }
    }
}

/// Describes the various methods that may be used to specify the orientation of the particles.
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum AlignMethod {
    #[br(magic = 0_u32)]
    ALIGN_INVALID = 0,
    #[br(magic = 1_u32)]
    ALIGN_PER_PARTICLE = 1,
    #[br(magic = 2_u32)]
    ALIGN_LOCAL_FIXED = 2,
    #[br(magic = 5_u32)]
    ALIGN_LOCAL_POSITION = 5,
    #[br(magic = 9_u32)]
    ALIGN_LOCAL_VELOCITY = 9,
    #[br(magic = 16_u32)]
    ALIGN_CAMERA = 16,
}

impl TryFrom<usize> for AlignMethod {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(AlignMethod::ALIGN_INVALID),
            1 => Ok(AlignMethod::ALIGN_PER_PARTICLE),
            2 => Ok(AlignMethod::ALIGN_LOCAL_FIXED),
            5 => Ok(AlignMethod::ALIGN_LOCAL_POSITION),
            9 => Ok(AlignMethod::ALIGN_LOCAL_VELOCITY),
            16 => Ok(AlignMethod::ALIGN_CAMERA),
            _ => Err(()),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum PSLoopBehavior {
    #[br(magic = 0_u32)]
    PS_LOOP_CLAMP_BIRTH = 0,
    #[br(magic = 1_u32)]
    PS_LOOP_CLAMP_DEATH = 1,
    #[br(magic = 2_u32)]
    PS_LOOP_AGESCALE = 2,
    #[br(magic = 3_u32)]
    PS_LOOP_LOOP = 3,
    #[br(magic = 4_u32)]
    PS_LOOP_REFLECT = 4,
}

impl TryFrom<usize> for PSLoopBehavior {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(PSLoopBehavior::PS_LOOP_CLAMP_BIRTH),
            1 => Ok(PSLoopBehavior::PS_LOOP_CLAMP_DEATH),
            2 => Ok(PSLoopBehavior::PS_LOOP_AGESCALE),
            3 => Ok(PSLoopBehavior::PS_LOOP_LOOP),
            4 => Ok(PSLoopBehavior::PS_LOOP_REFLECT),
            _ => Err(()),
        }
    }
}

/// This is used by the Floodgate kernel to determine which NiPSForceHelpers functions to call.
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum PSForceType {
    #[br(magic = 0_u32)]
    FORCE_BOMB = 0,
    #[br(magic = 1_u32)]
    FORCE_DRAG = 1,
    #[br(magic = 2_u32)]
    FORCE_AIR_FIELD = 2,
    #[br(magic = 3_u32)]
    FORCE_DRAG_FIELD = 3,
    #[br(magic = 4_u32)]
    FORCE_GRAVITY_FIELD = 4,
    #[br(magic = 5_u32)]
    FORCE_RADIAL_FIELD = 5,
    #[br(magic = 6_u32)]
    FORCE_TURBULENCE_FIELD = 6,
    #[br(magic = 7_u32)]
    FORCE_VORTEX_FIELD = 7,
    #[br(magic = 8_u32)]
    FORCE_GRAVITY = 8,
}

impl TryFrom<usize> for PSForceType {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(PSForceType::FORCE_BOMB),
            1 => Ok(PSForceType::FORCE_DRAG),
            2 => Ok(PSForceType::FORCE_AIR_FIELD),
            3 => Ok(PSForceType::FORCE_DRAG_FIELD),
            4 => Ok(PSForceType::FORCE_GRAVITY_FIELD),
            5 => Ok(PSForceType::FORCE_RADIAL_FIELD),
            6 => Ok(PSForceType::FORCE_TURBULENCE_FIELD),
            7 => Ok(PSForceType::FORCE_VORTEX_FIELD),
            8 => Ok(PSForceType::FORCE_GRAVITY),
            _ => Err(()),
        }
    }
}

/// This is used by the Floodgate kernel to determine which NiPSColliderHelpers functions to call.
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u32)]
pub enum ColliderType {
    #[br(magic = 0_u32)]
    COLLIDER_PLANAR = 0,
    #[br(magic = 1_u32)]
    COLLIDER_SPHERICAL = 1,
}

impl TryFrom<usize> for ColliderType {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(ColliderType::COLLIDER_PLANAR),
            1 => Ok(ColliderType::COLLIDER_SPHERICAL),
            _ => Err(()),
        }
    }
}

/// hkpWeldingUtility::WeldingType
#[derive(Clone, Copy, Debug, PartialEq, Eq, BinRead)]
#[repr(u8)]
pub enum hkWeldingType {
    #[br(magic = 0_u8)]
    WT_ANTICLOCKWISE = 0,
}

impl TryFrom<usize> for hkWeldingType {
    type Error = ();
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(hkWeldingType::WT_ANTICLOCKWISE),
            _ => Err(()),
        }
    }
}
