// This file is auto-generated by nifgen
// based on nifxml version 0.9.3.0.
// Do not edit manually.

#![allow(
    clippy::eq_op,
    clippy::identity_op,
    non_camel_case_types,
    non_upper_case_globals,
    unused_imports,
    unused_parens
)]

use binrw::{binread, BinRead};
use bitflags::bitflags;

use crate::{basic::*, parse};
use binrw::{
    io::{Read, Seek},
    BinResult, Error, Endian,
};

mod impls;

mod manual;
pub use self::manual::*;

use crate::{bitfields::*, bitflags::*, compounds::*, enums::*};

#[derive(Clone, Debug, PartialEq)]
pub enum NiObject {
    NiParticleModifier(NiParticleModifier),
    NiPSysCollider(NiPSysCollider),
    NiExtraData(NiExtraData),
    NiInterpolator(NiInterpolator),
    NiKeyBasedInterpolator(NiKeyBasedInterpolator),
    NiColorInterpolator(NiColorInterpolator),
    NiFloatInterpolator(NiFloatInterpolator),
    NiTransformInterpolator(NiTransformInterpolator),
    NiPoint3Interpolator(NiPoint3Interpolator),
    NiPathInterpolator(NiPathInterpolator),
    NiBoolInterpolator(NiBoolInterpolator),
    NiBoolTimelineInterpolator(NiBoolTimelineInterpolator),
    NiBlendInterpolator(NiBlendInterpolator),
    NiBSplineInterpolator(NiBSplineInterpolator),
    NiObjectNET(NiObjectNET),
    NiCollisionObject(NiCollisionObject),
    NiCollisionData(NiCollisionData),
    NiAVObject(NiAVObject),
    NiDynamicEffect(NiDynamicEffect),
    NiLight(NiLight),
    NiProperty(NiProperty),
    NiTransparentProperty(NiTransparentProperty),
    NiPSysModifier(NiPSysModifier),
    NiPSysEmitter(NiPSysEmitter),
    NiPSysVolumeEmitter(NiPSysVolumeEmitter),
    NiTimeController(NiTimeController),
    NiInterpController(NiInterpController),
    NiMultiTargetTransformController(NiMultiTargetTransformController),
    NiGeomMorpherController(NiGeomMorpherController),
    NiMorphController(NiMorphController),
    NiMorpherController(NiMorpherController),
    NiSingleInterpController(NiSingleInterpController),
    NiKeyframeController(NiKeyframeController),
    NiTransformController(NiTransformController),
    NiPSysModifierCtlr(NiPSysModifierCtlr),
    NiPSysEmitterCtlr(NiPSysEmitterCtlr),
    NiPSysModifierBoolCtlr(NiPSysModifierBoolCtlr),
    NiPSysModifierActiveCtlr(NiPSysModifierActiveCtlr),
    NiPSysModifierFloatCtlr(NiPSysModifierFloatCtlr),
    NiPSysEmitterDeclinationCtlr(NiPSysEmitterDeclinationCtlr),
    NiPSysEmitterDeclinationVarCtlr(NiPSysEmitterDeclinationVarCtlr),
    NiPSysEmitterInitialRadiusCtlr(NiPSysEmitterInitialRadiusCtlr),
    NiPSysEmitterLifeSpanCtlr(NiPSysEmitterLifeSpanCtlr),
    NiPSysEmitterSpeedCtlr(NiPSysEmitterSpeedCtlr),
    NiPSysGravityStrengthCtlr(NiPSysGravityStrengthCtlr),
    NiFloatInterpController(NiFloatInterpController),
    NiFlipController(NiFlipController),
    NiAlphaController(NiAlphaController),
    NiTextureTransformController(NiTextureTransformController),
    NiLightDimmerController(NiLightDimmerController),
    NiBoolInterpController(NiBoolInterpController),
    NiVisController(NiVisController),
    NiPoint3InterpController(NiPoint3InterpController),
    NiMaterialColorController(NiMaterialColorController),
    NiLightColorController(NiLightColorController),
    NiExtraDataController(NiExtraDataController),
    NiColorExtraDataController(NiColorExtraDataController),
    NiFloatExtraDataController(NiFloatExtraDataController),
    NiFloatsExtraDataController(NiFloatsExtraDataController),
    NiFloatsExtraDataPoint3Controller(NiFloatsExtraDataPoint3Controller),
    NiBoneLODController(NiBoneLODController),
    NiGeometry(NiGeometry),
    NiTriBasedGeom(NiTriBasedGeom),
    NiGeometryData(NiGeometryData),
    AbstractAdditionalGeometryData(AbstractAdditionalGeometryData),
    NiTriBasedGeomData(NiTriBasedGeomData),
    NiAlphaProperty(NiAlphaProperty),
    NiAmbientLight(NiAmbientLight),
    NiParticlesData(NiParticlesData),
    NiRotatingParticlesData(NiRotatingParticlesData),
    NiAutoNormalParticlesData(NiAutoNormalParticlesData),
    NiPSysData(NiPSysData),
    NiMeshPSysData(NiMeshPSysData),
    NiBinaryExtraData(NiBinaryExtraData),
    NiBinaryVoxelExtraData(NiBinaryVoxelExtraData),
    NiBinaryVoxelData(NiBinaryVoxelData),
    NiBlendBoolInterpolator(NiBlendBoolInterpolator),
    NiBlendFloatInterpolator(NiBlendFloatInterpolator),
    NiBlendPoint3Interpolator(NiBlendPoint3Interpolator),
    NiBlendTransformInterpolator(NiBlendTransformInterpolator),
    NiBoolData(NiBoolData),
    NiBooleanExtraData(NiBooleanExtraData),
    NiBSplineBasisData(NiBSplineBasisData),
    NiBSplineFloatInterpolator(NiBSplineFloatInterpolator),
    NiBSplineCompFloatInterpolator(NiBSplineCompFloatInterpolator),
    NiBSplinePoint3Interpolator(NiBSplinePoint3Interpolator),
    NiBSplineCompPoint3Interpolator(NiBSplineCompPoint3Interpolator),
    NiBSplineTransformInterpolator(NiBSplineTransformInterpolator),
    NiBSplineCompTransformInterpolator(NiBSplineCompTransformInterpolator),
    NiBSplineData(NiBSplineData),
    NiCamera(NiCamera),
    NiColorData(NiColorData),
    NiColorExtraData(NiColorExtraData),
    NiControllerManager(NiControllerManager),
    NiSequence(NiSequence),
    NiControllerSequence(NiControllerSequence),
    NiAVObjectPalette(NiAVObjectPalette),
    NiDefaultAVObjectPalette(NiDefaultAVObjectPalette),
    NiDirectionalLight(NiDirectionalLight),
    NiDitherProperty(NiDitherProperty),
    NiRollController(NiRollController),
    NiFloatData(NiFloatData),
    NiFloatExtraData(NiFloatExtraData),
    NiFloatsExtraData(NiFloatsExtraData),
    NiFogProperty(NiFogProperty),
    NiGravity(NiGravity),
    NiIntegerExtraData(NiIntegerExtraData),
    NiIntegersExtraData(NiIntegersExtraData),
    NiKeyframeData(NiKeyframeData),
    NiLookAtController(NiLookAtController),
    NiLookAtInterpolator(NiLookAtInterpolator),
    NiMaterialProperty(NiMaterialProperty),
    NiMorphData(NiMorphData),
    NiNode(NiNode),
    NiBone(NiBone),
    NiCollisionSwitch(NiCollisionSwitch),
    NiBillboardNode(NiBillboardNode),
    NiSwitchNode(NiSwitchNode),
    NiLODNode(NiLODNode),
    NiPalette(NiPalette),
    NiParticleBomb(NiParticleBomb),
    NiParticleColorModifier(NiParticleColorModifier),
    NiParticleGrowFade(NiParticleGrowFade),
    NiParticleMeshModifier(NiParticleMeshModifier),
    NiParticleRotation(NiParticleRotation),
    NiParticles(NiParticles),
    NiAutoNormalParticles(NiAutoNormalParticles),
    NiParticleMeshes(NiParticleMeshes),
    NiParticleMeshesData(NiParticleMeshesData),
    NiParticleSystem(NiParticleSystem),
    NiMeshParticleSystem(NiMeshParticleSystem),
    NiEmitterModifier(NiEmitterModifier),
    NiParticleSystemController(NiParticleSystemController),
    NiPathController(NiPathController),
    NiPixelFormat(NiPixelFormat),
    NiPersistentSrcTextureRendererData(NiPersistentSrcTextureRendererData),
    NiPixelData(NiPixelData),
    NiParticleCollider(NiParticleCollider),
    NiPlanarCollider(NiPlanarCollider),
    NiPointLight(NiPointLight),
    NiPosData(NiPosData),
    NiRotData(NiRotData),
    NiPSysAgeDeathModifier(NiPSysAgeDeathModifier),
    NiPSysBombModifier(NiPSysBombModifier),
    NiPSysBoundUpdateModifier(NiPSysBoundUpdateModifier),
    NiPSysBoxEmitter(NiPSysBoxEmitter),
    NiPSysColliderManager(NiPSysColliderManager),
    NiPSysColorModifier(NiPSysColorModifier),
    NiPSysCylinderEmitter(NiPSysCylinderEmitter),
    NiPSysDragModifier(NiPSysDragModifier),
    NiPSysEmitterCtlrData(NiPSysEmitterCtlrData),
    NiPSysGravityModifier(NiPSysGravityModifier),
    NiPSysGrowFadeModifier(NiPSysGrowFadeModifier),
    NiPSysMeshEmitter(NiPSysMeshEmitter),
    NiPSysMeshUpdateModifier(NiPSysMeshUpdateModifier),
    NiPSysPlanarCollider(NiPSysPlanarCollider),
    NiPSysSphericalCollider(NiPSysSphericalCollider),
    NiPSysPositionModifier(NiPSysPositionModifier),
    NiPSysResetOnLoopCtlr(NiPSysResetOnLoopCtlr),
    NiPSysRotationModifier(NiPSysRotationModifier),
    NiPSysSpawnModifier(NiPSysSpawnModifier),
    NiPSysSphereEmitter(NiPSysSphereEmitter),
    NiPSysUpdateCtlr(NiPSysUpdateCtlr),
    NiPSysFieldModifier(NiPSysFieldModifier),
    NiPSysVortexFieldModifier(NiPSysVortexFieldModifier),
    NiPSysGravityFieldModifier(NiPSysGravityFieldModifier),
    NiPSysDragFieldModifier(NiPSysDragFieldModifier),
    NiPSysTurbulenceFieldModifier(NiPSysTurbulenceFieldModifier),
    NiPSysFieldMagnitudeCtlr(NiPSysFieldMagnitudeCtlr),
    NiPSysFieldAttenuationCtlr(NiPSysFieldAttenuationCtlr),
    NiPSysFieldMaxDistanceCtlr(NiPSysFieldMaxDistanceCtlr),
    NiPSysAirFieldAirFrictionCtlr(NiPSysAirFieldAirFrictionCtlr),
    NiPSysAirFieldInheritVelocityCtlr(NiPSysAirFieldInheritVelocityCtlr),
    NiPSysAirFieldSpreadCtlr(NiPSysAirFieldSpreadCtlr),
    NiPSysInitialRotSpeedCtlr(NiPSysInitialRotSpeedCtlr),
    NiPSysInitialRotSpeedVarCtlr(NiPSysInitialRotSpeedVarCtlr),
    NiPSysInitialRotAngleCtlr(NiPSysInitialRotAngleCtlr),
    NiPSysInitialRotAngleVarCtlr(NiPSysInitialRotAngleVarCtlr),
    NiPSysEmitterPlanarAngleCtlr(NiPSysEmitterPlanarAngleCtlr),
    NiPSysEmitterPlanarAngleVarCtlr(NiPSysEmitterPlanarAngleVarCtlr),
    NiPSysAirFieldModifier(NiPSysAirFieldModifier),
    NiPSysTrailEmitter(NiPSysTrailEmitter),
    NiLightIntensityController(NiLightIntensityController),
    NiPSysRadialFieldModifier(NiPSysRadialFieldModifier),
    NiLODData(NiLODData),
    NiRangeLODData(NiRangeLODData),
    NiScreenLODData(NiScreenLODData),
    NiRotatingParticles(NiRotatingParticles),
    NiSequenceStreamHelper(NiSequenceStreamHelper),
    NiShadeProperty(NiShadeProperty),
    NiSkinData(NiSkinData),
    NiSkinInstance(NiSkinInstance),
    NiTriShapeSkinController(NiTriShapeSkinController),
    NiSkinPartition(NiSkinPartition),
    NiTexture(NiTexture),
    NiSourceTexture(NiSourceTexture),
    NiSpecularProperty(NiSpecularProperty),
    NiSphericalCollider(NiSphericalCollider),
    NiSpotLight(NiSpotLight),
    NiStencilProperty(NiStencilProperty),
    NiStringExtraData(NiStringExtraData),
    NiStringPalette(NiStringPalette),
    NiStringsExtraData(NiStringsExtraData),
    NiTextKeyExtraData(NiTextKeyExtraData),
    NiTextureEffect(NiTextureEffect),
    NiTextureModeProperty(NiTextureModeProperty),
    NiImage(NiImage),
    NiTextureProperty(NiTextureProperty),
    NiTexturingProperty(NiTexturingProperty),
    NiMultiTextureProperty(NiMultiTextureProperty),
    NiTransformData(NiTransformData),
    NiTriShape(NiTriShape),
    NiTriShapeData(NiTriShapeData),
    NiTriStrips(NiTriStrips),
    NiTriStripsData(NiTriStripsData),
    NiEnvMappedTriShape(NiEnvMappedTriShape),
    NiEnvMappedTriShapeData(NiEnvMappedTriShapeData),
    NiBezierTriangle4(NiBezierTriangle4),
    NiBezierMesh(NiBezierMesh),
    NiClod(NiClod),
    NiClodData(NiClodData),
    NiClodSkinInstance(NiClodSkinInstance),
    NiUVController(NiUVController),
    NiUVData(NiUVData),
    NiVectorExtraData(NiVectorExtraData),
    NiVertexColorProperty(NiVertexColorProperty),
    NiVertWeightsExtraData(NiVertWeightsExtraData),
    NiVisData(NiVisData),
    NiWireframeProperty(NiWireframeProperty),
    NiZBufferProperty(NiZBufferProperty),
    NiRawImageData(NiRawImageData),
    NiAccumulator(NiAccumulator),
    NiSortAdjustNode(NiSortAdjustNode),
    NiSourceCubeMap(NiSourceCubeMap),
    NiLines(NiLines),
    NiLinesData(NiLinesData),
    NiScreenElementsData(NiScreenElementsData),
    NiScreenElements(NiScreenElements),
    NiRoomGroup(NiRoomGroup),
    NiWall(NiWall),
    NiRoom(NiRoom),
    NiPortal(NiPortal),
    NiAdditionalGeometryData(NiAdditionalGeometryData),
    NiDataStream(NiDataStream),
    NiRenderObject(NiRenderObject),
    NiMeshModifier(NiMeshModifier),
    NiMesh(NiMesh),
    NiMorphWeightsController(NiMorphWeightsController),
    NiMorphMeshModifier(NiMorphMeshModifier),
    NiSkinningMeshModifier(NiSkinningMeshModifier),
    NiMeshHWInstance(NiMeshHWInstance),
    NiInstancingMeshModifier(NiInstancingMeshModifier),
    NiSkinningLODController(NiSkinningLODController),
    NiPSParticleSystem(NiPSParticleSystem),
    NiPSMeshParticleSystem(NiPSMeshParticleSystem),
    NiPSFacingQuadGenerator(NiPSFacingQuadGenerator),
    NiPSAlignedQuadGenerator(NiPSAlignedQuadGenerator),
    NiPSSimulator(NiPSSimulator),
    NiPSSimulatorStep(NiPSSimulatorStep),
    NiPSSimulatorGeneralStep(NiPSSimulatorGeneralStep),
    NiPSSimulatorForcesStep(NiPSSimulatorForcesStep),
    NiPSSimulatorCollidersStep(NiPSSimulatorCollidersStep),
    NiPSSimulatorMeshAlignStep(NiPSSimulatorMeshAlignStep),
    NiPSSimulatorFinalStep(NiPSSimulatorFinalStep),
    NiPSBoundUpdater(NiPSBoundUpdater),
    NiPSForce(NiPSForce),
    NiPSFieldForce(NiPSFieldForce),
    NiPSDragForce(NiPSDragForce),
    NiPSGravityForce(NiPSGravityForce),
    NiPSBombForce(NiPSBombForce),
    NiPSAirFieldForce(NiPSAirFieldForce),
    NiPSGravityFieldForce(NiPSGravityFieldForce),
    NiPSDragFieldForce(NiPSDragFieldForce),
    NiPSRadialFieldForce(NiPSRadialFieldForce),
    NiPSTurbulenceFieldForce(NiPSTurbulenceFieldForce),
    NiPSVortexFieldForce(NiPSVortexFieldForce),
    NiPSEmitter(NiPSEmitter),
    NiPSVolumeEmitter(NiPSVolumeEmitter),
    NiPSBoxEmitter(NiPSBoxEmitter),
    NiPSSphereEmitter(NiPSSphereEmitter),
    NiPSCylinderEmitter(NiPSCylinderEmitter),
    NiPSTorusEmitter(NiPSTorusEmitter),
    NiPSMeshEmitter(NiPSMeshEmitter),
    NiPSCurveEmitter(NiPSCurveEmitter),
    NiPSEmitterCtlr(NiPSEmitterCtlr),
    NiPSEmitterFloatCtlr(NiPSEmitterFloatCtlr),
    NiPSEmitParticlesCtlr(NiPSEmitParticlesCtlr),
    NiPSForceCtlr(NiPSForceCtlr),
    NiPSForceBoolCtlr(NiPSForceBoolCtlr),
    NiPSForceFloatCtlr(NiPSForceFloatCtlr),
    NiPSForceActiveCtlr(NiPSForceActiveCtlr),
    NiPSGravityStrengthCtlr(NiPSGravityStrengthCtlr),
    NiPSFieldAttenuationCtlr(NiPSFieldAttenuationCtlr),
    NiPSFieldMagnitudeCtlr(NiPSFieldMagnitudeCtlr),
    NiPSFieldMaxDistanceCtlr(NiPSFieldMaxDistanceCtlr),
    NiPSEmitterSpeedCtlr(NiPSEmitterSpeedCtlr),
    NiPSEmitterRadiusCtlr(NiPSEmitterRadiusCtlr),
    NiPSEmitterDeclinationCtlr(NiPSEmitterDeclinationCtlr),
    NiPSEmitterDeclinationVarCtlr(NiPSEmitterDeclinationVarCtlr),
    NiPSEmitterPlanarAngleCtlr(NiPSEmitterPlanarAngleCtlr),
    NiPSEmitterPlanarAngleVarCtlr(NiPSEmitterPlanarAngleVarCtlr),
    NiPSEmitterRotAngleCtlr(NiPSEmitterRotAngleCtlr),
    NiPSEmitterRotAngleVarCtlr(NiPSEmitterRotAngleVarCtlr),
    NiPSEmitterRotSpeedCtlr(NiPSEmitterRotSpeedCtlr),
    NiPSEmitterRotSpeedVarCtlr(NiPSEmitterRotSpeedVarCtlr),
    NiPSEmitterLifeSpanCtlr(NiPSEmitterLifeSpanCtlr),
    NiPSResetOnLoopCtlr(NiPSResetOnLoopCtlr),
    NiPSCollider(NiPSCollider),
    NiPSPlanarCollider(NiPSPlanarCollider),
    NiPSSphericalCollider(NiPSSphericalCollider),
    NiPSSpawner(NiPSSpawner),
    NiEvaluator(NiEvaluator),
    NiKeyBasedEvaluator(NiKeyBasedEvaluator),
    NiBoolEvaluator(NiBoolEvaluator),
    NiBoolTimelineEvaluator(NiBoolTimelineEvaluator),
    NiColorEvaluator(NiColorEvaluator),
    NiFloatEvaluator(NiFloatEvaluator),
    NiPoint3Evaluator(NiPoint3Evaluator),
    NiQuaternionEvaluator(NiQuaternionEvaluator),
    NiTransformEvaluator(NiTransformEvaluator),
    NiConstBoolEvaluator(NiConstBoolEvaluator),
    NiConstColorEvaluator(NiConstColorEvaluator),
    NiConstFloatEvaluator(NiConstFloatEvaluator),
    NiConstPoint3Evaluator(NiConstPoint3Evaluator),
    NiConstQuaternionEvaluator(NiConstQuaternionEvaluator),
    NiConstTransformEvaluator(NiConstTransformEvaluator),
    NiBSplineEvaluator(NiBSplineEvaluator),
    NiBSplineColorEvaluator(NiBSplineColorEvaluator),
    NiBSplineCompColorEvaluator(NiBSplineCompColorEvaluator),
    NiBSplineFloatEvaluator(NiBSplineFloatEvaluator),
    NiBSplineCompFloatEvaluator(NiBSplineCompFloatEvaluator),
    NiBSplinePoint3Evaluator(NiBSplinePoint3Evaluator),
    NiBSplineCompPoint3Evaluator(NiBSplineCompPoint3Evaluator),
    NiBSplineTransformEvaluator(NiBSplineTransformEvaluator),
    NiBSplineCompTransformEvaluator(NiBSplineCompTransformEvaluator),
    NiLookAtEvaluator(NiLookAtEvaluator),
    NiPathEvaluator(NiPathEvaluator),
    NiSequenceData(NiSequenceData),
    NiShadowGenerator(NiShadowGenerator),
}

impl NiObject {
    pub fn read_options<R: Read + Seek>(
        r: &mut R,
        e: Endian,
        a: &str,
        v: FileVersion,
    ) -> BinResult<Self> {
        let pos = r.stream_position()?;
        match a {
            "NiParticleModifier" => {
                NiParticleModifier::read_options(r, e, (v,)).map(NiObject::NiParticleModifier)
            }
            "NiPSysCollider" => {
                NiPSysCollider::read_options(r, e, (v,)).map(NiObject::NiPSysCollider)
            }
            "NiExtraData" => NiExtraData::read_options(r, e, (v,)).map(NiObject::NiExtraData),
            "NiInterpolator" => {
                NiInterpolator::read_options(r, e, (v,)).map(NiObject::NiInterpolator)
            }
            "NiKeyBasedInterpolator" => NiKeyBasedInterpolator::read_options(r, e, (v,))
                .map(NiObject::NiKeyBasedInterpolator),
            "NiColorInterpolator" => {
                NiColorInterpolator::read_options(r, e, (v,)).map(NiObject::NiColorInterpolator)
            }
            "NiFloatInterpolator" => {
                NiFloatInterpolator::read_options(r, e, (v,)).map(NiObject::NiFloatInterpolator)
            }
            "NiTransformInterpolator" => NiTransformInterpolator::read_options(r, e, (v,))
                .map(NiObject::NiTransformInterpolator),
            "NiPoint3Interpolator" => {
                NiPoint3Interpolator::read_options(r, e, (v,)).map(NiObject::NiPoint3Interpolator)
            }
            "NiPathInterpolator" => {
                NiPathInterpolator::read_options(r, e, (v,)).map(NiObject::NiPathInterpolator)
            }
            "NiBoolInterpolator" => {
                NiBoolInterpolator::read_options(r, e, (v,)).map(NiObject::NiBoolInterpolator)
            }
            "NiBoolTimelineInterpolator" => NiBoolTimelineInterpolator::read_options(r, e, (v,))
                .map(NiObject::NiBoolTimelineInterpolator),
            "NiBlendInterpolator" => {
                NiBlendInterpolator::read_options(r, e, (v,)).map(NiObject::NiBlendInterpolator)
            }
            "NiBSplineInterpolator" => {
                NiBSplineInterpolator::read_options(r, e, (v,)).map(NiObject::NiBSplineInterpolator)
            }
            "NiObjectNET" => NiObjectNET::read_options(r, e, (v,)).map(NiObject::NiObjectNET),
            "NiCollisionObject" => {
                NiCollisionObject::read_options(r, e, (v,)).map(NiObject::NiCollisionObject)
            }
            "NiCollisionData" => {
                NiCollisionData::read_options(r, e, (v,)).map(NiObject::NiCollisionData)
            }
            "NiAVObject" => NiAVObject::read_options(r, e, (v,)).map(NiObject::NiAVObject),
            "NiDynamicEffect" => {
                NiDynamicEffect::read_options(r, e, (v,)).map(NiObject::NiDynamicEffect)
            }
            "NiLight" => NiLight::read_options(r, e, (v,)).map(NiObject::NiLight),
            "NiProperty" => NiProperty::read_options(r, e, (v,)).map(NiObject::NiProperty),
            "NiTransparentProperty" => {
                NiTransparentProperty::read_options(r, e, (v,)).map(NiObject::NiTransparentProperty)
            }
            "NiPSysModifier" => {
                NiPSysModifier::read_options(r, e, (v,)).map(NiObject::NiPSysModifier)
            }
            "NiPSysEmitter" => NiPSysEmitter::read_options(r, e, (v,)).map(NiObject::NiPSysEmitter),
            "NiPSysVolumeEmitter" => {
                NiPSysVolumeEmitter::read_options(r, e, (v,)).map(NiObject::NiPSysVolumeEmitter)
            }
            "NiTimeController" => {
                NiTimeController::read_options(r, e, (v,)).map(NiObject::NiTimeController)
            }
            "NiInterpController" => {
                NiInterpController::read_options(r, e, (v,)).map(NiObject::NiInterpController)
            }
            "NiMultiTargetTransformController" => {
                NiMultiTargetTransformController::read_options(r, e, (v,))
                    .map(NiObject::NiMultiTargetTransformController)
            }
            "NiGeomMorpherController" => NiGeomMorpherController::read_options(r, e, (v,))
                .map(NiObject::NiGeomMorpherController),
            "NiMorphController" => {
                NiMorphController::read_options(r, e, (v,)).map(NiObject::NiMorphController)
            }
            "NiMorpherController" => {
                NiMorpherController::read_options(r, e, (v,)).map(NiObject::NiMorpherController)
            }
            "NiSingleInterpController" => NiSingleInterpController::read_options(r, e, (v,))
                .map(NiObject::NiSingleInterpController),
            "NiKeyframeController" => {
                NiKeyframeController::read_options(r, e, (v,)).map(NiObject::NiKeyframeController)
            }
            "NiTransformController" => {
                NiTransformController::read_options(r, e, (v,)).map(NiObject::NiTransformController)
            }
            "NiPSysModifierCtlr" => {
                NiPSysModifierCtlr::read_options(r, e, (v,)).map(NiObject::NiPSysModifierCtlr)
            }
            "NiPSysEmitterCtlr" => {
                NiPSysEmitterCtlr::read_options(r, e, (v,)).map(NiObject::NiPSysEmitterCtlr)
            }
            "NiPSysModifierBoolCtlr" => NiPSysModifierBoolCtlr::read_options(r, e, (v,))
                .map(NiObject::NiPSysModifierBoolCtlr),
            "NiPSysModifierActiveCtlr" => NiPSysModifierActiveCtlr::read_options(r, e, (v,))
                .map(NiObject::NiPSysModifierActiveCtlr),
            "NiPSysModifierFloatCtlr" => NiPSysModifierFloatCtlr::read_options(r, e, (v,))
                .map(NiObject::NiPSysModifierFloatCtlr),
            "NiPSysEmitterDeclinationCtlr" => {
                NiPSysEmitterDeclinationCtlr::read_options(r, e, (v,))
                    .map(NiObject::NiPSysEmitterDeclinationCtlr)
            }
            "NiPSysEmitterDeclinationVarCtlr" => {
                NiPSysEmitterDeclinationVarCtlr::read_options(r, e, (v,))
                    .map(NiObject::NiPSysEmitterDeclinationVarCtlr)
            }
            "NiPSysEmitterInitialRadiusCtlr" => {
                NiPSysEmitterInitialRadiusCtlr::read_options(r, e, (v,))
                    .map(NiObject::NiPSysEmitterInitialRadiusCtlr)
            }
            "NiPSysEmitterLifeSpanCtlr" => NiPSysEmitterLifeSpanCtlr::read_options(r, e, (v,))
                .map(NiObject::NiPSysEmitterLifeSpanCtlr),
            "NiPSysEmitterSpeedCtlr" => NiPSysEmitterSpeedCtlr::read_options(r, e, (v,))
                .map(NiObject::NiPSysEmitterSpeedCtlr),
            "NiPSysGravityStrengthCtlr" => NiPSysGravityStrengthCtlr::read_options(r, e, (v,))
                .map(NiObject::NiPSysGravityStrengthCtlr),
            "NiFloatInterpController" => NiFloatInterpController::read_options(r, e, (v,))
                .map(NiObject::NiFloatInterpController),
            "NiFlipController" => {
                NiFlipController::read_options(r, e, (v,)).map(NiObject::NiFlipController)
            }
            "NiAlphaController" => {
                NiAlphaController::read_options(r, e, (v,)).map(NiObject::NiAlphaController)
            }
            "NiTextureTransformController" => {
                NiTextureTransformController::read_options(r, e, (v,))
                    .map(NiObject::NiTextureTransformController)
            }
            "NiLightDimmerController" => NiLightDimmerController::read_options(r, e, (v,))
                .map(NiObject::NiLightDimmerController),
            "NiBoolInterpController" => NiBoolInterpController::read_options(r, e, (v,))
                .map(NiObject::NiBoolInterpController),
            "NiVisController" => {
                NiVisController::read_options(r, e, (v,)).map(NiObject::NiVisController)
            }
            "NiPoint3InterpController" => NiPoint3InterpController::read_options(r, e, (v,))
                .map(NiObject::NiPoint3InterpController),
            "NiMaterialColorController" => NiMaterialColorController::read_options(r, e, (v,))
                .map(NiObject::NiMaterialColorController),
            "NiLightColorController" => NiLightColorController::read_options(r, e, (v,))
                .map(NiObject::NiLightColorController),
            "NiExtraDataController" => {
                NiExtraDataController::read_options(r, e, (v,)).map(NiObject::NiExtraDataController)
            }
            "NiColorExtraDataController" => NiColorExtraDataController::read_options(r, e, (v,))
                .map(NiObject::NiColorExtraDataController),
            "NiFloatExtraDataController" => NiFloatExtraDataController::read_options(r, e, (v,))
                .map(NiObject::NiFloatExtraDataController),
            "NiFloatsExtraDataController" => NiFloatsExtraDataController::read_options(r, e, (v,))
                .map(NiObject::NiFloatsExtraDataController),
            "NiFloatsExtraDataPoint3Controller" => {
                NiFloatsExtraDataPoint3Controller::read_options(r, e, (v,))
                    .map(NiObject::NiFloatsExtraDataPoint3Controller)
            }
            "NiBoneLODController" => {
                NiBoneLODController::read_options(r, e, (v,)).map(NiObject::NiBoneLODController)
            }
            "NiGeometry" => NiGeometry::read_options(r, e, (v,)).map(NiObject::NiGeometry),
            "NiTriBasedGeom" => {
                NiTriBasedGeom::read_options(r, e, (v,)).map(NiObject::NiTriBasedGeom)
            }
            "NiGeometryData" => {
                NiGeometryData::read_options(r, e, (v,)).map(NiObject::NiGeometryData)
            }
            "AbstractAdditionalGeometryData" => {
                AbstractAdditionalGeometryData::read_options(r, e, (v,))
                    .map(NiObject::AbstractAdditionalGeometryData)
            }
            "NiTriBasedGeomData" => {
                NiTriBasedGeomData::read_options(r, e, (v,)).map(NiObject::NiTriBasedGeomData)
            }
            "NiAlphaProperty" => {
                NiAlphaProperty::read_options(r, e, (v,)).map(NiObject::NiAlphaProperty)
            }
            "NiAmbientLight" => {
                NiAmbientLight::read_options(r, e, (v,)).map(NiObject::NiAmbientLight)
            }
            "NiParticlesData" => {
                NiParticlesData::read_options(r, e, (v,)).map(NiObject::NiParticlesData)
            }
            "NiRotatingParticlesData" => NiRotatingParticlesData::read_options(r, e, (v,))
                .map(NiObject::NiRotatingParticlesData),
            "NiAutoNormalParticlesData" => NiAutoNormalParticlesData::read_options(r, e, (v,))
                .map(NiObject::NiAutoNormalParticlesData),
            "NiPSysData" => NiPSysData::read_options(r, e, (v,)).map(NiObject::NiPSysData),
            "NiMeshPSysData" => {
                NiMeshPSysData::read_options(r, e, (v,)).map(NiObject::NiMeshPSysData)
            }
            "NiBinaryExtraData" => {
                NiBinaryExtraData::read_options(r, e, (v,)).map(NiObject::NiBinaryExtraData)
            }
            "NiBinaryVoxelExtraData" => NiBinaryVoxelExtraData::read_options(r, e, (v,))
                .map(NiObject::NiBinaryVoxelExtraData),
            "NiBinaryVoxelData" => {
                NiBinaryVoxelData::read_options(r, e, (v,)).map(NiObject::NiBinaryVoxelData)
            }
            "NiBlendBoolInterpolator" => NiBlendBoolInterpolator::read_options(r, e, (v,))
                .map(NiObject::NiBlendBoolInterpolator),
            "NiBlendFloatInterpolator" => NiBlendFloatInterpolator::read_options(r, e, (v,))
                .map(NiObject::NiBlendFloatInterpolator),
            "NiBlendPoint3Interpolator" => NiBlendPoint3Interpolator::read_options(r, e, (v,))
                .map(NiObject::NiBlendPoint3Interpolator),
            "NiBlendTransformInterpolator" => {
                NiBlendTransformInterpolator::read_options(r, e, (v,))
                    .map(NiObject::NiBlendTransformInterpolator)
            }
            "NiBoolData" => NiBoolData::read_options(r, e, (v,)).map(NiObject::NiBoolData),
            "NiBooleanExtraData" => {
                NiBooleanExtraData::read_options(r, e, (v,)).map(NiObject::NiBooleanExtraData)
            }
            "NiBSplineBasisData" => {
                NiBSplineBasisData::read_options(r, e, (v,)).map(NiObject::NiBSplineBasisData)
            }
            "NiBSplineFloatInterpolator" => NiBSplineFloatInterpolator::read_options(r, e, (v,))
                .map(NiObject::NiBSplineFloatInterpolator),
            "NiBSplineCompFloatInterpolator" => {
                NiBSplineCompFloatInterpolator::read_options(r, e, (v,))
                    .map(NiObject::NiBSplineCompFloatInterpolator)
            }
            "NiBSplinePoint3Interpolator" => NiBSplinePoint3Interpolator::read_options(r, e, (v,))
                .map(NiObject::NiBSplinePoint3Interpolator),
            "NiBSplineCompPoint3Interpolator" => {
                NiBSplineCompPoint3Interpolator::read_options(r, e, (v,))
                    .map(NiObject::NiBSplineCompPoint3Interpolator)
            }
            "NiBSplineTransformInterpolator" => {
                NiBSplineTransformInterpolator::read_options(r, e, (v,))
                    .map(NiObject::NiBSplineTransformInterpolator)
            }
            "NiBSplineCompTransformInterpolator" => {
                NiBSplineCompTransformInterpolator::read_options(r, e, (v,))
                    .map(NiObject::NiBSplineCompTransformInterpolator)
            }
            "NiBSplineData" => NiBSplineData::read_options(r, e, (v,)).map(NiObject::NiBSplineData),
            "NiCamera" => NiCamera::read_options(r, e, (v,)).map(NiObject::NiCamera),
            "NiColorData" => NiColorData::read_options(r, e, (v,)).map(NiObject::NiColorData),
            "NiColorExtraData" => {
                NiColorExtraData::read_options(r, e, (v,)).map(NiObject::NiColorExtraData)
            }
            "NiControllerManager" => {
                NiControllerManager::read_options(r, e, (v,)).map(NiObject::NiControllerManager)
            }
            "NiSequence" => NiSequence::read_options(r, e, (v,)).map(NiObject::NiSequence),
            "NiControllerSequence" => {
                NiControllerSequence::read_options(r, e, (v,)).map(NiObject::NiControllerSequence)
            }
            "NiAVObjectPalette" => {
                NiAVObjectPalette::read_options(r, e, (v,)).map(NiObject::NiAVObjectPalette)
            }
            "NiDefaultAVObjectPalette" => NiDefaultAVObjectPalette::read_options(r, e, (v,))
                .map(NiObject::NiDefaultAVObjectPalette),
            "NiDirectionalLight" => {
                NiDirectionalLight::read_options(r, e, (v,)).map(NiObject::NiDirectionalLight)
            }
            "NiDitherProperty" => {
                NiDitherProperty::read_options(r, e, (v,)).map(NiObject::NiDitherProperty)
            }
            "NiRollController" => {
                NiRollController::read_options(r, e, (v,)).map(NiObject::NiRollController)
            }
            "NiFloatData" => NiFloatData::read_options(r, e, (v,)).map(NiObject::NiFloatData),
            "NiFloatExtraData" => {
                NiFloatExtraData::read_options(r, e, (v,)).map(NiObject::NiFloatExtraData)
            }
            "NiFloatsExtraData" => {
                NiFloatsExtraData::read_options(r, e, (v,)).map(NiObject::NiFloatsExtraData)
            }
            "NiFogProperty" => NiFogProperty::read_options(r, e, (v,)).map(NiObject::NiFogProperty),
            "NiGravity" => NiGravity::read_options(r, e, (v,)).map(NiObject::NiGravity),
            "NiIntegerExtraData" => {
                NiIntegerExtraData::read_options(r, e, (v,)).map(NiObject::NiIntegerExtraData)
            }
            "NiIntegersExtraData" => {
                NiIntegersExtraData::read_options(r, e, (v,)).map(NiObject::NiIntegersExtraData)
            }
            "NiKeyframeData" => {
                NiKeyframeData::read_options(r, e, (v,)).map(NiObject::NiKeyframeData)
            }
            "NiLookAtController" => {
                NiLookAtController::read_options(r, e, (v,)).map(NiObject::NiLookAtController)
            }
            "NiLookAtInterpolator" => {
                NiLookAtInterpolator::read_options(r, e, (v,)).map(NiObject::NiLookAtInterpolator)
            }
            "NiMaterialProperty" => {
                NiMaterialProperty::read_options(r, e, (v,)).map(NiObject::NiMaterialProperty)
            }
            "NiMorphData" => NiMorphData::read_options(r, e, (v,)).map(NiObject::NiMorphData),
            "NiNode" => NiNode::read_options(r, e, (v,)).map(NiObject::NiNode),
            "NiBone" => NiBone::read_options(r, e, (v,)).map(NiObject::NiBone),
            "NiCollisionSwitch" => {
                NiCollisionSwitch::read_options(r, e, (v,)).map(NiObject::NiCollisionSwitch)
            }
            "NiBillboardNode" => {
                NiBillboardNode::read_options(r, e, (v,)).map(NiObject::NiBillboardNode)
            }
            "NiSwitchNode" => NiSwitchNode::read_options(r, e, (v,)).map(NiObject::NiSwitchNode),
            "NiLODNode" => NiLODNode::read_options(r, e, (v,)).map(NiObject::NiLODNode),
            "NiPalette" => NiPalette::read_options(r, e, (v,)).map(NiObject::NiPalette),
            "NiParticleBomb" => {
                NiParticleBomb::read_options(r, e, (v,)).map(NiObject::NiParticleBomb)
            }
            "NiParticleColorModifier" => NiParticleColorModifier::read_options(r, e, (v,))
                .map(NiObject::NiParticleColorModifier),
            "NiParticleGrowFade" => {
                NiParticleGrowFade::read_options(r, e, (v,)).map(NiObject::NiParticleGrowFade)
            }
            "NiParticleMeshModifier" => NiParticleMeshModifier::read_options(r, e, (v,))
                .map(NiObject::NiParticleMeshModifier),
            "NiParticleRotation" => {
                NiParticleRotation::read_options(r, e, (v,)).map(NiObject::NiParticleRotation)
            }
            "NiParticles" => NiParticles::read_options(r, e, (v,)).map(NiObject::NiParticles),
            "NiAutoNormalParticles" => {
                NiAutoNormalParticles::read_options(r, e, (v,)).map(NiObject::NiAutoNormalParticles)
            }
            "NiParticleMeshes" => {
                NiParticleMeshes::read_options(r, e, (v,)).map(NiObject::NiParticleMeshes)
            }
            "NiParticleMeshesData" => {
                NiParticleMeshesData::read_options(r, e, (v,)).map(NiObject::NiParticleMeshesData)
            }
            "NiParticleSystem" => {
                NiParticleSystem::read_options(r, e, (v,)).map(NiObject::NiParticleSystem)
            }
            "NiMeshParticleSystem" => {
                NiMeshParticleSystem::read_options(r, e, (v,)).map(NiObject::NiMeshParticleSystem)
            }
            "NiEmitterModifier" => {
                NiEmitterModifier::read_options(r, e, (v,)).map(NiObject::NiEmitterModifier)
            }
            "NiParticleSystemController" => NiParticleSystemController::read_options(r, e, (v,))
                .map(NiObject::NiParticleSystemController),
            "NiPathController" => {
                NiPathController::read_options(r, e, (v,)).map(NiObject::NiPathController)
            }
            "NiPixelFormat" => NiPixelFormat::read_options(r, e, (v,)).map(NiObject::NiPixelFormat),
            "NiPersistentSrcTextureRendererData" => {
                NiPersistentSrcTextureRendererData::read_options(r, e, (v,))
                    .map(NiObject::NiPersistentSrcTextureRendererData)
            }
            "NiPixelData" => NiPixelData::read_options(r, e, (v,)).map(NiObject::NiPixelData),
            "NiParticleCollider" => {
                NiParticleCollider::read_options(r, e, (v,)).map(NiObject::NiParticleCollider)
            }
            "NiPlanarCollider" => {
                NiPlanarCollider::read_options(r, e, (v,)).map(NiObject::NiPlanarCollider)
            }
            "NiPointLight" => NiPointLight::read_options(r, e, (v,)).map(NiObject::NiPointLight),
            "NiPosData" => NiPosData::read_options(r, e, (v,)).map(NiObject::NiPosData),
            "NiRotData" => NiRotData::read_options(r, e, (v,)).map(NiObject::NiRotData),
            "NiPSysAgeDeathModifier" => NiPSysAgeDeathModifier::read_options(r, e, (v,))
                .map(NiObject::NiPSysAgeDeathModifier),
            "NiPSysBombModifier" => {
                NiPSysBombModifier::read_options(r, e, (v,)).map(NiObject::NiPSysBombModifier)
            }
            "NiPSysBoundUpdateModifier" => NiPSysBoundUpdateModifier::read_options(r, e, (v,))
                .map(NiObject::NiPSysBoundUpdateModifier),
            "NiPSysBoxEmitter" => {
                NiPSysBoxEmitter::read_options(r, e, (v,)).map(NiObject::NiPSysBoxEmitter)
            }
            "NiPSysColliderManager" => {
                NiPSysColliderManager::read_options(r, e, (v,)).map(NiObject::NiPSysColliderManager)
            }
            "NiPSysColorModifier" => {
                NiPSysColorModifier::read_options(r, e, (v,)).map(NiObject::NiPSysColorModifier)
            }
            "NiPSysCylinderEmitter" => {
                NiPSysCylinderEmitter::read_options(r, e, (v,)).map(NiObject::NiPSysCylinderEmitter)
            }
            "NiPSysDragModifier" => {
                NiPSysDragModifier::read_options(r, e, (v,)).map(NiObject::NiPSysDragModifier)
            }
            "NiPSysEmitterCtlrData" => {
                NiPSysEmitterCtlrData::read_options(r, e, (v,)).map(NiObject::NiPSysEmitterCtlrData)
            }
            "NiPSysGravityModifier" => {
                NiPSysGravityModifier::read_options(r, e, (v,)).map(NiObject::NiPSysGravityModifier)
            }
            "NiPSysGrowFadeModifier" => NiPSysGrowFadeModifier::read_options(r, e, (v,))
                .map(NiObject::NiPSysGrowFadeModifier),
            "NiPSysMeshEmitter" => {
                NiPSysMeshEmitter::read_options(r, e, (v,)).map(NiObject::NiPSysMeshEmitter)
            }
            "NiPSysMeshUpdateModifier" => NiPSysMeshUpdateModifier::read_options(r, e, (v,))
                .map(NiObject::NiPSysMeshUpdateModifier),
            "NiPSysPlanarCollider" => {
                NiPSysPlanarCollider::read_options(r, e, (v,)).map(NiObject::NiPSysPlanarCollider)
            }
            "NiPSysSphericalCollider" => NiPSysSphericalCollider::read_options(r, e, (v,))
                .map(NiObject::NiPSysSphericalCollider),
            "NiPSysPositionModifier" => NiPSysPositionModifier::read_options(r, e, (v,))
                .map(NiObject::NiPSysPositionModifier),
            "NiPSysResetOnLoopCtlr" => {
                NiPSysResetOnLoopCtlr::read_options(r, e, (v,)).map(NiObject::NiPSysResetOnLoopCtlr)
            }
            "NiPSysRotationModifier" => NiPSysRotationModifier::read_options(r, e, (v,))
                .map(NiObject::NiPSysRotationModifier),
            "NiPSysSpawnModifier" => {
                NiPSysSpawnModifier::read_options(r, e, (v,)).map(NiObject::NiPSysSpawnModifier)
            }
            "NiPSysSphereEmitter" => {
                NiPSysSphereEmitter::read_options(r, e, (v,)).map(NiObject::NiPSysSphereEmitter)
            }
            "NiPSysUpdateCtlr" => {
                NiPSysUpdateCtlr::read_options(r, e, (v,)).map(NiObject::NiPSysUpdateCtlr)
            }
            "NiPSysFieldModifier" => {
                NiPSysFieldModifier::read_options(r, e, (v,)).map(NiObject::NiPSysFieldModifier)
            }
            "NiPSysVortexFieldModifier" => NiPSysVortexFieldModifier::read_options(r, e, (v,))
                .map(NiObject::NiPSysVortexFieldModifier),
            "NiPSysGravityFieldModifier" => NiPSysGravityFieldModifier::read_options(r, e, (v,))
                .map(NiObject::NiPSysGravityFieldModifier),
            "NiPSysDragFieldModifier" => NiPSysDragFieldModifier::read_options(r, e, (v,))
                .map(NiObject::NiPSysDragFieldModifier),
            "NiPSysTurbulenceFieldModifier" => {
                NiPSysTurbulenceFieldModifier::read_options(r, e, (v,))
                    .map(NiObject::NiPSysTurbulenceFieldModifier)
            }
            "NiPSysFieldMagnitudeCtlr" => NiPSysFieldMagnitudeCtlr::read_options(r, e, (v,))
                .map(NiObject::NiPSysFieldMagnitudeCtlr),
            "NiPSysFieldAttenuationCtlr" => NiPSysFieldAttenuationCtlr::read_options(r, e, (v,))
                .map(NiObject::NiPSysFieldAttenuationCtlr),
            "NiPSysFieldMaxDistanceCtlr" => NiPSysFieldMaxDistanceCtlr::read_options(r, e, (v,))
                .map(NiObject::NiPSysFieldMaxDistanceCtlr),
            "NiPSysAirFieldAirFrictionCtlr" => {
                NiPSysAirFieldAirFrictionCtlr::read_options(r, e, (v,))
                    .map(NiObject::NiPSysAirFieldAirFrictionCtlr)
            }
            "NiPSysAirFieldInheritVelocityCtlr" => {
                NiPSysAirFieldInheritVelocityCtlr::read_options(r, e, (v,))
                    .map(NiObject::NiPSysAirFieldInheritVelocityCtlr)
            }
            "NiPSysAirFieldSpreadCtlr" => NiPSysAirFieldSpreadCtlr::read_options(r, e, (v,))
                .map(NiObject::NiPSysAirFieldSpreadCtlr),
            "NiPSysInitialRotSpeedCtlr" => NiPSysInitialRotSpeedCtlr::read_options(r, e, (v,))
                .map(NiObject::NiPSysInitialRotSpeedCtlr),
            "NiPSysInitialRotSpeedVarCtlr" => {
                NiPSysInitialRotSpeedVarCtlr::read_options(r, e, (v,))
                    .map(NiObject::NiPSysInitialRotSpeedVarCtlr)
            }
            "NiPSysInitialRotAngleCtlr" => NiPSysInitialRotAngleCtlr::read_options(r, e, (v,))
                .map(NiObject::NiPSysInitialRotAngleCtlr),
            "NiPSysInitialRotAngleVarCtlr" => {
                NiPSysInitialRotAngleVarCtlr::read_options(r, e, (v,))
                    .map(NiObject::NiPSysInitialRotAngleVarCtlr)
            }
            "NiPSysEmitterPlanarAngleCtlr" => {
                NiPSysEmitterPlanarAngleCtlr::read_options(r, e, (v,))
                    .map(NiObject::NiPSysEmitterPlanarAngleCtlr)
            }
            "NiPSysEmitterPlanarAngleVarCtlr" => {
                NiPSysEmitterPlanarAngleVarCtlr::read_options(r, e, (v,))
                    .map(NiObject::NiPSysEmitterPlanarAngleVarCtlr)
            }
            "NiPSysAirFieldModifier" => NiPSysAirFieldModifier::read_options(r, e, (v,))
                .map(NiObject::NiPSysAirFieldModifier),
            "NiPSysTrailEmitter" => {
                NiPSysTrailEmitter::read_options(r, e, (v,)).map(NiObject::NiPSysTrailEmitter)
            }
            "NiLightIntensityController" => NiLightIntensityController::read_options(r, e, (v,))
                .map(NiObject::NiLightIntensityController),
            "NiPSysRadialFieldModifier" => NiPSysRadialFieldModifier::read_options(r, e, (v,))
                .map(NiObject::NiPSysRadialFieldModifier),
            "NiLODData" => NiLODData::read_options(r, e, (v,)).map(NiObject::NiLODData),
            "NiRangeLODData" => {
                NiRangeLODData::read_options(r, e, (v,)).map(NiObject::NiRangeLODData)
            }
            "NiScreenLODData" => {
                NiScreenLODData::read_options(r, e, (v,)).map(NiObject::NiScreenLODData)
            }
            "NiRotatingParticles" => {
                NiRotatingParticles::read_options(r, e, (v,)).map(NiObject::NiRotatingParticles)
            }
            "NiSequenceStreamHelper" => NiSequenceStreamHelper::read_options(r, e, (v,))
                .map(NiObject::NiSequenceStreamHelper),
            "NiShadeProperty" => {
                NiShadeProperty::read_options(r, e, (v,)).map(NiObject::NiShadeProperty)
            }
            "NiSkinData" => NiSkinData::read_options(r, e, (v,)).map(NiObject::NiSkinData),
            "NiSkinInstance" => {
                NiSkinInstance::read_options(r, e, (v,)).map(NiObject::NiSkinInstance)
            }
            "NiTriShapeSkinController" => NiTriShapeSkinController::read_options(r, e, (v,))
                .map(NiObject::NiTriShapeSkinController),
            "NiSkinPartition" => {
                NiSkinPartition::read_options(r, e, (v,)).map(NiObject::NiSkinPartition)
            }
            "NiTexture" => NiTexture::read_options(r, e, (v,)).map(NiObject::NiTexture),
            "NiSourceTexture" => {
                NiSourceTexture::read_options(r, e, (v,)).map(NiObject::NiSourceTexture)
            }
            "NiSpecularProperty" => {
                NiSpecularProperty::read_options(r, e, (v,)).map(NiObject::NiSpecularProperty)
            }
            "NiSphericalCollider" => {
                NiSphericalCollider::read_options(r, e, (v,)).map(NiObject::NiSphericalCollider)
            }
            "NiSpotLight" => NiSpotLight::read_options(r, e, (v,)).map(NiObject::NiSpotLight),
            "NiStencilProperty" => {
                NiStencilProperty::read_options(r, e, (v,)).map(NiObject::NiStencilProperty)
            }
            "NiStringExtraData" => {
                NiStringExtraData::read_options(r, e, (v,)).map(NiObject::NiStringExtraData)
            }
            "NiStringPalette" => {
                NiStringPalette::read_options(r, e, (v,)).map(NiObject::NiStringPalette)
            }
            "NiStringsExtraData" => {
                NiStringsExtraData::read_options(r, e, (v,)).map(NiObject::NiStringsExtraData)
            }
            "NiTextKeyExtraData" => {
                NiTextKeyExtraData::read_options(r, e, (v,)).map(NiObject::NiTextKeyExtraData)
            }
            "NiTextureEffect" => {
                NiTextureEffect::read_options(r, e, (v,)).map(NiObject::NiTextureEffect)
            }
            "NiTextureModeProperty" => {
                NiTextureModeProperty::read_options(r, e, (v,)).map(NiObject::NiTextureModeProperty)
            }
            "NiImage" => NiImage::read_options(r, e, (v,)).map(NiObject::NiImage),
            "NiTextureProperty" => {
                NiTextureProperty::read_options(r, e, (v,)).map(NiObject::NiTextureProperty)
            }
            "NiTexturingProperty" => {
                NiTexturingProperty::read_options(r, e, (v,)).map(NiObject::NiTexturingProperty)
            }
            "NiMultiTextureProperty" => NiMultiTextureProperty::read_options(r, e, (v,))
                .map(NiObject::NiMultiTextureProperty),
            "NiTransformData" => {
                NiTransformData::read_options(r, e, (v,)).map(NiObject::NiTransformData)
            }
            "NiTriShape" => NiTriShape::read_options(r, e, (v,)).map(NiObject::NiTriShape),
            "NiTriShapeData" => {
                NiTriShapeData::read_options(r, e, (v,)).map(NiObject::NiTriShapeData)
            }
            "NiTriStrips" => NiTriStrips::read_options(r, e, (v,)).map(NiObject::NiTriStrips),
            "NiTriStripsData" => {
                NiTriStripsData::read_options(r, e, (v,)).map(NiObject::NiTriStripsData)
            }
            "NiEnvMappedTriShape" => {
                NiEnvMappedTriShape::read_options(r, e, (v,)).map(NiObject::NiEnvMappedTriShape)
            }
            "NiEnvMappedTriShapeData" => NiEnvMappedTriShapeData::read_options(r, e, (v,))
                .map(NiObject::NiEnvMappedTriShapeData),
            "NiBezierTriangle4" => {
                NiBezierTriangle4::read_options(r, e, (v,)).map(NiObject::NiBezierTriangle4)
            }
            "NiBezierMesh" => NiBezierMesh::read_options(r, e, (v,)).map(NiObject::NiBezierMesh),
            "NiClod" => NiClod::read_options(r, e, (v,)).map(NiObject::NiClod),
            "NiClodData" => NiClodData::read_options(r, e, (v,)).map(NiObject::NiClodData),
            "NiClodSkinInstance" => {
                NiClodSkinInstance::read_options(r, e, (v,)).map(NiObject::NiClodSkinInstance)
            }
            "NiUVController" => {
                NiUVController::read_options(r, e, (v,)).map(NiObject::NiUVController)
            }
            "NiUVData" => NiUVData::read_options(r, e, (v,)).map(NiObject::NiUVData),
            "NiVectorExtraData" => {
                NiVectorExtraData::read_options(r, e, (v,)).map(NiObject::NiVectorExtraData)
            }
            "NiVertexColorProperty" => {
                NiVertexColorProperty::read_options(r, e, (v,)).map(NiObject::NiVertexColorProperty)
            }
            "NiVertWeightsExtraData" => NiVertWeightsExtraData::read_options(r, e, (v,))
                .map(NiObject::NiVertWeightsExtraData),
            "NiVisData" => NiVisData::read_options(r, e, (v,)).map(NiObject::NiVisData),
            "NiWireframeProperty" => {
                NiWireframeProperty::read_options(r, e, (v,)).map(NiObject::NiWireframeProperty)
            }
            "NiZBufferProperty" => {
                NiZBufferProperty::read_options(r, e, (v,)).map(NiObject::NiZBufferProperty)
            }
            "NiRawImageData" => {
                NiRawImageData::read_options(r, e, (v,)).map(NiObject::NiRawImageData)
            }
            "NiAccumulator" => NiAccumulator::read_options(r, e, (v,)).map(NiObject::NiAccumulator),
            "NiSortAdjustNode" => {
                NiSortAdjustNode::read_options(r, e, (v,)).map(NiObject::NiSortAdjustNode)
            }
            "NiSourceCubeMap" => {
                NiSourceCubeMap::read_options(r, e, (v,)).map(NiObject::NiSourceCubeMap)
            }
            "NiLines" => NiLines::read_options(r, e, (v,)).map(NiObject::NiLines),
            "NiLinesData" => NiLinesData::read_options(r, e, (v,)).map(NiObject::NiLinesData),
            "NiScreenElementsData" => {
                NiScreenElementsData::read_options(r, e, (v,)).map(NiObject::NiScreenElementsData)
            }
            "NiScreenElements" => {
                NiScreenElements::read_options(r, e, (v,)).map(NiObject::NiScreenElements)
            }
            "NiRoomGroup" => NiRoomGroup::read_options(r, e, (v,)).map(NiObject::NiRoomGroup),
            "NiWall" => NiWall::read_options(r, e, (v,)).map(NiObject::NiWall),
            "NiRoom" => NiRoom::read_options(r, e, (v,)).map(NiObject::NiRoom),
            "NiPortal" => NiPortal::read_options(r, e, (v,)).map(NiObject::NiPortal),
            "NiAdditionalGeometryData" => NiAdditionalGeometryData::read_options(r, e, (v,))
                .map(NiObject::NiAdditionalGeometryData),
            "NiDataStream" => NiDataStream::read_options(r, e, (v,)).map(NiObject::NiDataStream),
            "NiRenderObject" => {
                NiRenderObject::read_options(r, e, (v,)).map(NiObject::NiRenderObject)
            }
            "NiMeshModifier" => {
                NiMeshModifier::read_options(r, e, (v,)).map(NiObject::NiMeshModifier)
            }
            "NiMesh" => NiMesh::read_options(r, e, (v,)).map(NiObject::NiMesh),
            "NiMorphWeightsController" => NiMorphWeightsController::read_options(r, e, (v,))
                .map(NiObject::NiMorphWeightsController),
            "NiMorphMeshModifier" => {
                NiMorphMeshModifier::read_options(r, e, (v,)).map(NiObject::NiMorphMeshModifier)
            }
            "NiSkinningMeshModifier" => NiSkinningMeshModifier::read_options(r, e, (v,))
                .map(NiObject::NiSkinningMeshModifier),
            "NiMeshHWInstance" => {
                NiMeshHWInstance::read_options(r, e, (v,)).map(NiObject::NiMeshHWInstance)
            }
            "NiInstancingMeshModifier" => NiInstancingMeshModifier::read_options(r, e, (v,))
                .map(NiObject::NiInstancingMeshModifier),
            "NiSkinningLODController" => NiSkinningLODController::read_options(r, e, (v,))
                .map(NiObject::NiSkinningLODController),
            "NiPSParticleSystem" => {
                NiPSParticleSystem::read_options(r, e, (v,)).map(NiObject::NiPSParticleSystem)
            }
            "NiPSMeshParticleSystem" => NiPSMeshParticleSystem::read_options(r, e, (v,))
                .map(NiObject::NiPSMeshParticleSystem),
            "NiPSFacingQuadGenerator" => NiPSFacingQuadGenerator::read_options(r, e, (v,))
                .map(NiObject::NiPSFacingQuadGenerator),
            "NiPSAlignedQuadGenerator" => NiPSAlignedQuadGenerator::read_options(r, e, (v,))
                .map(NiObject::NiPSAlignedQuadGenerator),
            "NiPSSimulator" => NiPSSimulator::read_options(r, e, (v,)).map(NiObject::NiPSSimulator),
            "NiPSSimulatorStep" => {
                NiPSSimulatorStep::read_options(r, e, (v,)).map(NiObject::NiPSSimulatorStep)
            }
            "NiPSSimulatorGeneralStep" => NiPSSimulatorGeneralStep::read_options(r, e, (v,))
                .map(NiObject::NiPSSimulatorGeneralStep),
            "NiPSSimulatorForcesStep" => NiPSSimulatorForcesStep::read_options(r, e, (v,))
                .map(NiObject::NiPSSimulatorForcesStep),
            "NiPSSimulatorCollidersStep" => NiPSSimulatorCollidersStep::read_options(r, e, (v,))
                .map(NiObject::NiPSSimulatorCollidersStep),
            "NiPSSimulatorMeshAlignStep" => NiPSSimulatorMeshAlignStep::read_options(r, e, (v,))
                .map(NiObject::NiPSSimulatorMeshAlignStep),
            "NiPSSimulatorFinalStep" => NiPSSimulatorFinalStep::read_options(r, e, (v,))
                .map(NiObject::NiPSSimulatorFinalStep),
            "NiPSBoundUpdater" => {
                NiPSBoundUpdater::read_options(r, e, (v,)).map(NiObject::NiPSBoundUpdater)
            }
            "NiPSForce" => NiPSForce::read_options(r, e, (v,)).map(NiObject::NiPSForce),
            "NiPSFieldForce" => {
                NiPSFieldForce::read_options(r, e, (v,)).map(NiObject::NiPSFieldForce)
            }
            "NiPSDragForce" => NiPSDragForce::read_options(r, e, (v,)).map(NiObject::NiPSDragForce),
            "NiPSGravityForce" => {
                NiPSGravityForce::read_options(r, e, (v,)).map(NiObject::NiPSGravityForce)
            }
            "NiPSBombForce" => NiPSBombForce::read_options(r, e, (v,)).map(NiObject::NiPSBombForce),
            "NiPSAirFieldForce" => {
                NiPSAirFieldForce::read_options(r, e, (v,)).map(NiObject::NiPSAirFieldForce)
            }
            "NiPSGravityFieldForce" => {
                NiPSGravityFieldForce::read_options(r, e, (v,)).map(NiObject::NiPSGravityFieldForce)
            }
            "NiPSDragFieldForce" => {
                NiPSDragFieldForce::read_options(r, e, (v,)).map(NiObject::NiPSDragFieldForce)
            }
            "NiPSRadialFieldForce" => {
                NiPSRadialFieldForce::read_options(r, e, (v,)).map(NiObject::NiPSRadialFieldForce)
            }
            "NiPSTurbulenceFieldForce" => NiPSTurbulenceFieldForce::read_options(r, e, (v,))
                .map(NiObject::NiPSTurbulenceFieldForce),
            "NiPSVortexFieldForce" => {
                NiPSVortexFieldForce::read_options(r, e, (v,)).map(NiObject::NiPSVortexFieldForce)
            }
            "NiPSEmitter" => NiPSEmitter::read_options(r, e, (v,)).map(NiObject::NiPSEmitter),
            "NiPSVolumeEmitter" => {
                NiPSVolumeEmitter::read_options(r, e, (v,)).map(NiObject::NiPSVolumeEmitter)
            }
            "NiPSBoxEmitter" => {
                NiPSBoxEmitter::read_options(r, e, (v,)).map(NiObject::NiPSBoxEmitter)
            }
            "NiPSSphereEmitter" => {
                NiPSSphereEmitter::read_options(r, e, (v,)).map(NiObject::NiPSSphereEmitter)
            }
            "NiPSCylinderEmitter" => {
                NiPSCylinderEmitter::read_options(r, e, (v,)).map(NiObject::NiPSCylinderEmitter)
            }
            "NiPSTorusEmitter" => {
                NiPSTorusEmitter::read_options(r, e, (v,)).map(NiObject::NiPSTorusEmitter)
            }
            "NiPSMeshEmitter" => {
                NiPSMeshEmitter::read_options(r, e, (v,)).map(NiObject::NiPSMeshEmitter)
            }
            "NiPSCurveEmitter" => {
                NiPSCurveEmitter::read_options(r, e, (v,)).map(NiObject::NiPSCurveEmitter)
            }
            "NiPSEmitterCtlr" => {
                NiPSEmitterCtlr::read_options(r, e, (v,)).map(NiObject::NiPSEmitterCtlr)
            }
            "NiPSEmitterFloatCtlr" => {
                NiPSEmitterFloatCtlr::read_options(r, e, (v,)).map(NiObject::NiPSEmitterFloatCtlr)
            }
            "NiPSEmitParticlesCtlr" => {
                NiPSEmitParticlesCtlr::read_options(r, e, (v,)).map(NiObject::NiPSEmitParticlesCtlr)
            }
            "NiPSForceCtlr" => NiPSForceCtlr::read_options(r, e, (v,)).map(NiObject::NiPSForceCtlr),
            "NiPSForceBoolCtlr" => {
                NiPSForceBoolCtlr::read_options(r, e, (v,)).map(NiObject::NiPSForceBoolCtlr)
            }
            "NiPSForceFloatCtlr" => {
                NiPSForceFloatCtlr::read_options(r, e, (v,)).map(NiObject::NiPSForceFloatCtlr)
            }
            "NiPSForceActiveCtlr" => {
                NiPSForceActiveCtlr::read_options(r, e, (v,)).map(NiObject::NiPSForceActiveCtlr)
            }
            "NiPSGravityStrengthCtlr" => NiPSGravityStrengthCtlr::read_options(r, e, (v,))
                .map(NiObject::NiPSGravityStrengthCtlr),
            "NiPSFieldAttenuationCtlr" => NiPSFieldAttenuationCtlr::read_options(r, e, (v,))
                .map(NiObject::NiPSFieldAttenuationCtlr),
            "NiPSFieldMagnitudeCtlr" => NiPSFieldMagnitudeCtlr::read_options(r, e, (v,))
                .map(NiObject::NiPSFieldMagnitudeCtlr),
            "NiPSFieldMaxDistanceCtlr" => NiPSFieldMaxDistanceCtlr::read_options(r, e, (v,))
                .map(NiObject::NiPSFieldMaxDistanceCtlr),
            "NiPSEmitterSpeedCtlr" => {
                NiPSEmitterSpeedCtlr::read_options(r, e, (v,)).map(NiObject::NiPSEmitterSpeedCtlr)
            }
            "NiPSEmitterRadiusCtlr" => {
                NiPSEmitterRadiusCtlr::read_options(r, e, (v,)).map(NiObject::NiPSEmitterRadiusCtlr)
            }
            "NiPSEmitterDeclinationCtlr" => NiPSEmitterDeclinationCtlr::read_options(r, e, (v,))
                .map(NiObject::NiPSEmitterDeclinationCtlr),
            "NiPSEmitterDeclinationVarCtlr" => {
                NiPSEmitterDeclinationVarCtlr::read_options(r, e, (v,))
                    .map(NiObject::NiPSEmitterDeclinationVarCtlr)
            }
            "NiPSEmitterPlanarAngleCtlr" => NiPSEmitterPlanarAngleCtlr::read_options(r, e, (v,))
                .map(NiObject::NiPSEmitterPlanarAngleCtlr),
            "NiPSEmitterPlanarAngleVarCtlr" => {
                NiPSEmitterPlanarAngleVarCtlr::read_options(r, e, (v,))
                    .map(NiObject::NiPSEmitterPlanarAngleVarCtlr)
            }
            "NiPSEmitterRotAngleCtlr" => NiPSEmitterRotAngleCtlr::read_options(r, e, (v,))
                .map(NiObject::NiPSEmitterRotAngleCtlr),
            "NiPSEmitterRotAngleVarCtlr" => NiPSEmitterRotAngleVarCtlr::read_options(r, e, (v,))
                .map(NiObject::NiPSEmitterRotAngleVarCtlr),
            "NiPSEmitterRotSpeedCtlr" => NiPSEmitterRotSpeedCtlr::read_options(r, e, (v,))
                .map(NiObject::NiPSEmitterRotSpeedCtlr),
            "NiPSEmitterRotSpeedVarCtlr" => NiPSEmitterRotSpeedVarCtlr::read_options(r, e, (v,))
                .map(NiObject::NiPSEmitterRotSpeedVarCtlr),
            "NiPSEmitterLifeSpanCtlr" => NiPSEmitterLifeSpanCtlr::read_options(r, e, (v,))
                .map(NiObject::NiPSEmitterLifeSpanCtlr),
            "NiPSResetOnLoopCtlr" => {
                NiPSResetOnLoopCtlr::read_options(r, e, (v,)).map(NiObject::NiPSResetOnLoopCtlr)
            }
            "NiPSCollider" => NiPSCollider::read_options(r, e, (v,)).map(NiObject::NiPSCollider),
            "NiPSPlanarCollider" => {
                NiPSPlanarCollider::read_options(r, e, (v,)).map(NiObject::NiPSPlanarCollider)
            }
            "NiPSSphericalCollider" => {
                NiPSSphericalCollider::read_options(r, e, (v,)).map(NiObject::NiPSSphericalCollider)
            }
            "NiPSSpawner" => NiPSSpawner::read_options(r, e, (v,)).map(NiObject::NiPSSpawner),
            "NiEvaluator" => NiEvaluator::read_options(r, e, (v,)).map(NiObject::NiEvaluator),
            "NiKeyBasedEvaluator" => {
                NiKeyBasedEvaluator::read_options(r, e, (v,)).map(NiObject::NiKeyBasedEvaluator)
            }
            "NiBoolEvaluator" => {
                NiBoolEvaluator::read_options(r, e, (v,)).map(NiObject::NiBoolEvaluator)
            }
            "NiBoolTimelineEvaluator" => NiBoolTimelineEvaluator::read_options(r, e, (v,))
                .map(NiObject::NiBoolTimelineEvaluator),
            "NiColorEvaluator" => {
                NiColorEvaluator::read_options(r, e, (v,)).map(NiObject::NiColorEvaluator)
            }
            "NiFloatEvaluator" => {
                NiFloatEvaluator::read_options(r, e, (v,)).map(NiObject::NiFloatEvaluator)
            }
            "NiPoint3Evaluator" => {
                NiPoint3Evaluator::read_options(r, e, (v,)).map(NiObject::NiPoint3Evaluator)
            }
            "NiQuaternionEvaluator" => {
                NiQuaternionEvaluator::read_options(r, e, (v,)).map(NiObject::NiQuaternionEvaluator)
            }
            "NiTransformEvaluator" => {
                NiTransformEvaluator::read_options(r, e, (v,)).map(NiObject::NiTransformEvaluator)
            }
            "NiConstBoolEvaluator" => {
                NiConstBoolEvaluator::read_options(r, e, (v,)).map(NiObject::NiConstBoolEvaluator)
            }
            "NiConstColorEvaluator" => {
                NiConstColorEvaluator::read_options(r, e, (v,)).map(NiObject::NiConstColorEvaluator)
            }
            "NiConstFloatEvaluator" => {
                NiConstFloatEvaluator::read_options(r, e, (v,)).map(NiObject::NiConstFloatEvaluator)
            }
            "NiConstPoint3Evaluator" => NiConstPoint3Evaluator::read_options(r, e, (v,))
                .map(NiObject::NiConstPoint3Evaluator),
            "NiConstQuaternionEvaluator" => NiConstQuaternionEvaluator::read_options(r, e, (v,))
                .map(NiObject::NiConstQuaternionEvaluator),
            "NiConstTransformEvaluator" => NiConstTransformEvaluator::read_options(r, e, (v,))
                .map(NiObject::NiConstTransformEvaluator),
            "NiBSplineEvaluator" => {
                NiBSplineEvaluator::read_options(r, e, (v,)).map(NiObject::NiBSplineEvaluator)
            }
            "NiBSplineColorEvaluator" => NiBSplineColorEvaluator::read_options(r, e, (v,))
                .map(NiObject::NiBSplineColorEvaluator),
            "NiBSplineCompColorEvaluator" => NiBSplineCompColorEvaluator::read_options(r, e, (v,))
                .map(NiObject::NiBSplineCompColorEvaluator),
            "NiBSplineFloatEvaluator" => NiBSplineFloatEvaluator::read_options(r, e, (v,))
                .map(NiObject::NiBSplineFloatEvaluator),
            "NiBSplineCompFloatEvaluator" => NiBSplineCompFloatEvaluator::read_options(r, e, (v,))
                .map(NiObject::NiBSplineCompFloatEvaluator),
            "NiBSplinePoint3Evaluator" => NiBSplinePoint3Evaluator::read_options(r, e, (v,))
                .map(NiObject::NiBSplinePoint3Evaluator),
            "NiBSplineCompPoint3Evaluator" => {
                NiBSplineCompPoint3Evaluator::read_options(r, e, (v,))
                    .map(NiObject::NiBSplineCompPoint3Evaluator)
            }
            "NiBSplineTransformEvaluator" => NiBSplineTransformEvaluator::read_options(r, e, (v,))
                .map(NiObject::NiBSplineTransformEvaluator),
            "NiBSplineCompTransformEvaluator" => {
                NiBSplineCompTransformEvaluator::read_options(r, e, (v,))
                    .map(NiObject::NiBSplineCompTransformEvaluator)
            }
            "NiLookAtEvaluator" => {
                NiLookAtEvaluator::read_options(r, e, (v,)).map(NiObject::NiLookAtEvaluator)
            }
            "NiPathEvaluator" => {
                NiPathEvaluator::read_options(r, e, (v,)).map(NiObject::NiPathEvaluator)
            }
            "NiSequenceData" => {
                NiSequenceData::read_options(r, e, (v,)).map(NiObject::NiSequenceData)
            }
            "NiShadowGenerator" => {
                NiShadowGenerator::read_options(r, e, (v,)).map(NiObject::NiShadowGenerator)
            }
            str if str.starts_with("NiDataStream") => {
                let mut parts = str.split('_');

                let _ = parts.next();
                match (parts.next(), parts.next(), parts.next()) {
                    (Some(usage), Some(access), None) => {
                        let usage = usage.parse::<u32>().map_err(|e| Error::Custom {
                            pos,
                            err: Box::new(e),
                        })?;
                        let access = access.parse::<u32>().map_err(|e| Error::Custom {
                            pos,
                            err: Box::new(e),
                        })?;

                        NiDataStreamTheSadWay::read_options(r, e, (usage, access))
                            .map(|o| NiObject::NiDataStream(o.into()))
                    }
                    _ => Err(Error::Custom {
                        pos,
                        err: Box::new("unknown NiDataStream type encountered"),
                    }),
                }
            }
            _ => Err(Error::Custom {
                pos,
                err: Box::new("unknown block type encountered"),
            }),
        }
    }
}

/// LEGACY (pre-10.1). Abstract base class for particle system modifiers.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiParticleModifier {
    pub next_modifier: Ref<NiParticleModifier>,
    pub controller: Ptr<NiParticleSystemController>,
}

/// Particle system collider.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysCollider {
    pub bounce: f32,
    #[br(map = |b: u8| b != 0)]
    pub spawn_on_collide: bool,
    #[br(map = |b: u8| b != 0)]
    pub die_on_collide: bool,
    pub spawn_modifier: Ref<NiPSysSpawnModifier>,
    pub parent: Ptr<NiPSysColliderManager>,
    pub next_collider: Ref<NiPSysCollider>,
    pub collider_object: Ptr<NiAVObject>,
}

/// A generic extra data object.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiExtraData {
    pub name: NiString,
}

/// Abstract base class for all interpolators of bool, float, NiQuaternion, NiPoint3, NiColorA, and NiQuatTransform data.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiInterpolator {}

/// Abstract base class for interpolators that use NiAnimationKeys (Key, KeyGrp) for interpolation.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiKeyBasedInterpolator {
    pub base: NiInterpolator,
}

/// Animates a color value over time.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiColorInterpolator {
    #[br(args(_header_version))]
    pub base: NiKeyBasedInterpolator,
    pub value: Color4,
    pub data: Ref<NiColorData>,
}

/// Uses NiFloatKeys to animate a float value over time.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiFloatInterpolator {
    pub base: NiKeyBasedInterpolator,
    pub value: f32,
    pub data: Ref<NiFloatData>,
}

/// An interpolator for transform keyframes.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiTransformInterpolator {
    #[br(args(_header_version))]
    pub base: NiKeyBasedInterpolator,
    pub transform: NiQuatTransform,
    pub data: Ref<NiTransformData>,
}

/// Uses NiPosKeys to animate an NiPoint3 value over time.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPoint3Interpolator {
    #[br(args(_header_version))]
    pub base: NiKeyBasedInterpolator,
    pub value: Vector3,
    pub data: Ref<NiPosData>,
}

/// Used to make an object follow a predefined spline path.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPathInterpolator {
    #[br(args(_header_version))]
    pub base: NiKeyBasedInterpolator,
    pub flags: PathFlags,
    pub bank_dir: i32,
    pub max_bank_angle: f32,
    pub smoothing: f32,
    pub follow_axis: i16,
    pub path_data: Ref<NiPosData>,
    pub percent_data: Ref<NiFloatData>,
}

/// Uses NiBoolKeys to animate a bool value over time.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiBoolInterpolator {
    #[br(args(_header_version))]
    pub base: NiKeyBasedInterpolator,
    #[br(map = |b: u8| b != 0)]
    pub value: bool,
    pub data: Ref<NiBoolData>,
}

/// Uses NiBoolKeys to animate a bool value over time.
/// Unlike NiBoolInterpolator, it ensures that keys have not been missed between two updates.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiBoolTimelineInterpolator {
    #[br(args(_header_version))]
    pub base: NiBoolInterpolator,
}

/// Abstract base class for all NiInterpolators that blend the results of sub-interpolators together to compute a final weighted value.
#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiBlendInterpolator {
    #[br(args(_header_version))]
    pub base: NiInterpolator,
    pub flags: InterpBlendFlags,
    #[br(temp)]
    array_size: u8,
    pub weight_threshold: f32,
    #[br(if(flags as u8 & InterpBlendFlags::MANAGER_CONTROLLED as u8 == 0))]
    pub interp_count: Option<u8>,
    #[br(if(flags as u8 & InterpBlendFlags::MANAGER_CONTROLLED as u8 == 0))]
    pub single_index: Option<u8>,
    #[br(if(flags as u8 & InterpBlendFlags::MANAGER_CONTROLLED as u8 == 0))]
    pub high_priority: Option<i8>,
    #[br(if(flags as u8 & InterpBlendFlags::MANAGER_CONTROLLED as u8 == 0))]
    pub next_high_priority: Option<i8>,
    #[br(if(flags as u8 & InterpBlendFlags::MANAGER_CONTROLLED as u8 == 0))]
    pub single_time: Option<f32>,
    #[br(if(flags as u8 & InterpBlendFlags::MANAGER_CONTROLLED as u8 == 0))]
    pub high_weights_sum: Option<f32>,
    #[br(if(flags as u8 & InterpBlendFlags::MANAGER_CONTROLLED as u8 == 0))]
    pub next_high_weights_sum: Option<f32>,
    #[br(if(flags as u8 & InterpBlendFlags::MANAGER_CONTROLLED as u8 == 0))]
    pub high_ease_spinner: Option<f32>,
    #[br(if(flags as u8 & InterpBlendFlags::MANAGER_CONTROLLED as u8 == 0))]
    #[br(count = array_size)]
    pub interp_array_items: Option<Vec<InterpBlendItem>>,
}

/// Abstract base class for interpolators storing data via a B-spline.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiBSplineInterpolator {
    #[br(args(_header_version))]
    pub base: NiInterpolator,
    pub start_time: f32,
    pub stop_time: f32,
    pub spline_data: Ref<NiBSplineData>,
    pub basis_data: Ref<NiBSplineBasisData>,
}

/// Abstract base class for NiObjects that support names, extra data, and time controllers.
#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiObjectNET {
    pub name: NiString,
    #[br(temp)]
    num_extra_data_list: u32,
    #[br(count = num_extra_data_list)]
    pub extra_data_list: Vec<Ref<NiExtraData>>,
    pub controller: Ref<NiTimeController>,
}

/// This is the most common collision object found in NIF files. It acts as a real object that
/// is visible and possibly (if the body allows for it) interactive. The node itself
/// is simple, it only has three properties.
/// For this type of collision object, bhkRigidBody or bhkRigidBodyT is generally used.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiCollisionObject {
    pub target: Ptr<NiAVObject>,
}

/// Collision box.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiCollisionData {
    #[br(args(_header_version))]
    pub base: NiCollisionObject,
    pub propagation_mode: PropagationMode,
    pub collision_mode: CollisionMode,
    pub use_abv: u8,
    #[br(if(use_abv == 1))]
    pub bounding_volume: Option<BoundingVolume>,
}

/// Abstract audio-visual base class from which all of Gamebryo's scene graph objects inherit.
#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiAVObject {
    #[br(args(_header_version))]
    pub base: NiObjectNET,
    pub flags: u16,
    pub translation: Vector3,
    pub rotation: Matrix33,
    pub scale: f32,
    #[br(temp)]
    num_properties: u32,
    #[br(count = num_properties)]
    pub properties: Vec<Ref<NiProperty>>,
    pub collision_object: Ref<NiCollisionObject>,
}

/// Abstract base class for dynamic effects such as NiLights or projected texture effects.
#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiDynamicEffect {
    #[br(args(_header_version))]
    pub base: NiAVObject,
    #[br(map = |b: u8| b != 0)]
    pub switch_state: bool,
    #[br(temp)]
    num_affected_nodes: u32,
    #[br(count = num_affected_nodes)]
    pub affected_nodes: Vec<Ptr<NiNode>>,
}

/// Abstract base class that represents light sources in a scene graph.
/// For Bethesda Stream 130 (FO4), NiLight now directly inherits from NiAVObject.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiLight {
    #[br(args(_header_version))]
    pub base: NiDynamicEffect,
    pub dimmer: f32,
    pub ambient_color: Color3,
    pub diffuse_color: Color3,
    pub specular_color: Color3,
}

/// Abstract base class representing all rendering properties. Subclasses are attached to NiAVObjects to control their rendering.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiProperty {
    #[br(args(_header_version))]
    pub base: NiObjectNET,
}

/// Unknown
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiTransparentProperty {
    #[br(args(_header_version))]
    pub base: NiProperty,
    pub unknown: [u8; 6],
}

/// Abstract base class for all particle system modifiers.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysModifier {
    pub name: NiString,
    pub order: NiPSysModifierOrder,
    pub target: Ptr<NiParticleSystem>,
    #[br(map = |b: u8| b != 0)]
    pub active: bool,
}

/// Abstract base class for all particle system emitters.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysEmitter {
    #[br(args(_header_version))]
    pub base: NiPSysModifier,
    pub speed: f32,
    pub speed_variation: f32,
    pub declination: f32,
    pub declination_variation: f32,
    pub planar_angle: f32,
    pub planar_angle_variation: f32,
    pub initial_color: Color4,
    pub initial_radius: f32,
    pub radius_variation: f32,
    pub life_span: f32,
    pub life_span_variation: f32,
}

/// Abstract base class for particle emitters that emit particles from a volume.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysVolumeEmitter {
    #[br(args(_header_version))]
    pub base: NiPSysEmitter,
    pub emitter_object: Ptr<NiNode>,
}

/// Abstract base class that provides the base timing and update functionality for all the Gamebryo animation controllers.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiTimeController {
    pub next_controller: Ref<NiTimeController>,
    pub flags: TimeControllerFlags,
    pub frequency: f32,
    pub phase: f32,
    pub start_time: f32,
    pub stop_time: f32,
    pub target: Ptr<NiObjectNET>,
}

/// Abstract base class for all NiTimeController objects using NiInterpolator objects to animate their target objects.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiInterpController {
    #[br(args(_header_version))]
    pub base: NiTimeController,
}

/// DEPRECATED (20.6)
#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiMultiTargetTransformController {
    #[br(args(_header_version))]
    pub base: NiInterpController,
    #[br(temp)]
    num_extra_targets: u16,
    #[br(count = num_extra_targets)]
    pub extra_targets: Vec<Ptr<NiAVObject>>,
}

/// DEPRECATED (20.5), replaced by NiMorphMeshModifier.
/// Time controller for geometry morphing.
#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiGeomMorpherController {
    #[br(args(_header_version))]
    pub base: NiInterpController,
    pub morpher_flags: GeomMorpherFlags,
    pub data: Ref<NiMorphData>,
    pub always_update: u8,
    #[br(temp)]
    num_interpolators: u32,
    #[br(if(FileVersion(20,1,0,3) <= _header_version))]
    #[br(count = num_interpolators)]
    pub interpolator_weights: Vec<MorphWeight>,
}

/// Unknown! Used by Daoc->'healing.nif'.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiMorphController {
    #[br(args(_header_version))]
    pub base: NiInterpController,
}

/// Unknown! Used by Daoc.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiMorpherController {
    #[br(args(_header_version))]
    pub base: NiInterpController,
    pub data: Ref<NiMorphData>,
}

/// Uses a single NiInterpolator to animate its target value.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiSingleInterpController {
    #[br(args(_header_version))]
    pub base: NiInterpController,
    pub interpolator: Ref<NiInterpolator>,
}

/// DEPRECATED (10.2), RENAMED (10.2) to NiTransformController
/// A time controller object for animation key frames.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiKeyframeController {
    #[br(args(_header_version))]
    pub base: NiSingleInterpController,
}

/// NiTransformController replaces NiKeyframeController.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiTransformController {
    #[br(args(_header_version))]
    pub base: NiKeyframeController,
}

/// A particle system modifier controller.
/// NiInterpController::GetCtlrID() string format:
/// '%s'
/// Where %s = Value of "Modifier Name"
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysModifierCtlr {
    #[br(args(_header_version))]
    pub base: NiSingleInterpController,
    pub modifier_name: NiString,
}

/// Particle system emitter controller.
/// NiInterpController::GetInterpolatorID() string format:
/// ['BirthRate', 'EmitterActive'] (for "Interpolator" and "Visibility Interpolator" respectively)
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysEmitterCtlr {
    #[br(args(_header_version))]
    pub base: NiPSysModifierCtlr,
    pub visibility_interpolator: Ref<NiInterpolator>,
}

/// A particle system modifier controller that animates a boolean value for particles.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysModifierBoolCtlr {
    #[br(args(_header_version))]
    pub base: NiPSysModifierCtlr,
}

/// A particle system modifier controller that animates active/inactive state for particles.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysModifierActiveCtlr {
    #[br(args(_header_version))]
    pub base: NiPSysModifierBoolCtlr,
}

/// A particle system modifier controller that animates a floating point value for particles.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysModifierFloatCtlr {
    #[br(args(_header_version))]
    pub base: NiPSysModifierCtlr,
}

/// Animates the declination value on an NiPSysEmitter object.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysEmitterDeclinationCtlr {
    #[br(args(_header_version))]
    pub base: NiPSysModifierFloatCtlr,
}

/// Animates the declination variation value on an NiPSysEmitter object.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysEmitterDeclinationVarCtlr {
    #[br(args(_header_version))]
    pub base: NiPSysModifierFloatCtlr,
}

/// Animates the size value on an NiPSysEmitter object.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysEmitterInitialRadiusCtlr {
    #[br(args(_header_version))]
    pub base: NiPSysModifierFloatCtlr,
}

/// Animates the lifespan value on an NiPSysEmitter object.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysEmitterLifeSpanCtlr {
    #[br(args(_header_version))]
    pub base: NiPSysModifierFloatCtlr,
}

/// Animates the speed value on an NiPSysEmitter object.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysEmitterSpeedCtlr {
    #[br(args(_header_version))]
    pub base: NiPSysModifierFloatCtlr,
}

/// Animates the strength value of an NiPSysGravityModifier.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysGravityStrengthCtlr {
    #[br(args(_header_version))]
    pub base: NiPSysModifierFloatCtlr,
}

/// Abstract base class for all NiInterpControllers that use an NiInterpolator to animate their target float value.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiFloatInterpController {
    #[br(args(_header_version))]
    pub base: NiSingleInterpController,
}

/// Changes the image a Map (TexDesc) will use. Uses a float interpolator to animate the texture index.
/// Often used for performing flipbook animation.
#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiFlipController {
    #[br(args(_header_version))]
    pub base: NiFloatInterpController,
    pub texture_slot: TexType,
    #[br(temp)]
    num_sources: u32,
    #[br(count = num_sources)]
    pub sources: Vec<Ref<NiSourceTexture>>,
}

/// Animates the alpha value of a property using an interpolator.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiAlphaController {
    #[br(args(_header_version))]
    pub base: NiFloatInterpController,
}

/// Used to animate a single member of an NiTextureTransform.
/// NiInterpController::GetCtlrID() string formats:
/// ['%1-%2-TT_TRANSLATE_U', '%1-%2-TT_TRANSLATE_V', '%1-%2-TT_ROTATE', '%1-%2-TT_SCALE_U', '%1-%2-TT_SCALE_V']
/// (Depending on "Operation" enumeration, %1 = Value of "Shader Map", %2 = Value of "Texture Slot")
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiTextureTransformController {
    #[br(args(_header_version))]
    pub base: NiFloatInterpController,
    #[br(map = |b: u8| b != 0)]
    pub shader_map: bool,
    pub texture_slot: TexType,
    pub operation: TransformMember,
}

/// Animates the dimmer value of an NiLight.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiLightDimmerController {
    #[br(args(_header_version))]
    pub base: NiFloatInterpController,
}

/// Abstract base class for all NiInterpControllers that use a NiInterpolator to animate their target boolean value.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiBoolInterpController {
    #[br(args(_header_version))]
    pub base: NiSingleInterpController,
}

/// Animates the visibility of an NiAVObject.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiVisController {
    #[br(args(_header_version))]
    pub base: NiBoolInterpController,
}

/// Abstract base class for all NiInterpControllers that use an NiInterpolator to animate their target NiPoint3 value.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPoint3InterpController {
    #[br(args(_header_version))]
    pub base: NiSingleInterpController,
}

/// Time controller for material color. Flags are used for color selection in versions below 10.1.0.0.
/// Bits 4-5: Target Color (00 = Ambient, 01 = Diffuse, 10 = Specular, 11 = Emissive)
/// NiInterpController::GetCtlrID() string formats:
/// ['AMB', 'DIFF', 'SPEC', 'SELF_ILLUM'] (Depending on "Target Color")
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiMaterialColorController {
    #[br(args(_header_version))]
    pub base: NiPoint3InterpController,
    pub target_color: MaterialColor,
}

/// Animates the ambient, diffuse and specular colors of an NiLight.
/// NiInterpController::GetCtlrID() string formats:
/// ['Diffuse', 'Ambient'] (Depending on "Target Color")
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiLightColorController {
    #[br(args(_header_version))]
    pub base: NiPoint3InterpController,
    pub target_color: LightColor,
}

/// Abstract base class for all extra data controllers.
/// NiInterpController::GetCtlrID() string format:
/// '%s'
/// Where %s = Value of "Extra Data Name"
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiExtraDataController {
    #[br(args(_header_version))]
    pub base: NiSingleInterpController,
    pub extra_data_name: NiString,
}

/// Animates an NiColorExtraData object attached to an NiAVObject.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiColorExtraDataController {
    #[br(args(_header_version))]
    pub base: NiExtraDataController,
}

/// Animates an NiFloatExtraData object attached to an NiAVObject.
/// NiInterpController::GetCtlrID() string format is same as parent.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiFloatExtraDataController {
    #[br(args(_header_version))]
    pub base: NiExtraDataController,
}

/// Animates an NiFloatsExtraData object attached to an NiAVObject.
/// NiInterpController::GetCtlrID() string format:
/// '%s[%d]'
/// Where %s = Value of "Extra Data Name", %d = Value of "Floats Extra Data Index"
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiFloatsExtraDataController {
    #[br(args(_header_version))]
    pub base: NiExtraDataController,
    pub floats_extra_data_index: i32,
}

/// Animates an NiFloatsExtraData object attached to an NiAVObject.
/// NiInterpController::GetCtlrID() string format:
/// '%s[%d]'
/// Where %s = Value of "Extra Data Name", %d = Value of "Floats Extra Data Index"
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiFloatsExtraDataPoint3Controller {
    #[br(args(_header_version))]
    pub base: NiExtraDataController,
    pub floats_extra_data_index: i32,
}

/// DEPRECATED (20.5), Replaced by NiSkinningLODController.
/// Level of detail controller for bones.  Priority is arranged from low to high.
#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiBoneLODController {
    #[br(args(_header_version))]
    pub base: NiTimeController,
    pub lod: u32,
    #[br(temp)]
    num_lods: u32,
    pub num_node_groups: u32,
    #[br(count = num_lods)]
    pub node_groups: Vec<NodeSet>,
    #[br(temp)]
    num_shape_groups: u32,
    #[br(count = num_shape_groups)]
    pub shape_groups_1: Vec<SkinInfoSet>,
    #[br(temp)]
    num_shape_groups_2: u32,
    #[br(count = num_shape_groups_2)]
    pub shape_groups_2: Vec<Ref<NiTriBasedGeom>>,
}

/// Describes a visible scene element with vertices like a mesh, a particle system, lines, etc.
/// Bethesda 20.2.0.7 NIFs: NiGeometry was changed to BSGeometry.
/// Most new blocks (e.g. BSTriShape) do not refer to NiGeometry except NiParticleSystem was changed to use BSGeometry.
/// This causes massive inheritance problems so the rows below are doubled up to exclude NiParticleSystem for Bethesda Stream 100+
/// and to add data exclusive to BSGeometry.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiGeometry {
    #[br(args(_header_version))]
    pub base: NiAVObject,
    pub data: Ref<NiGeometryData>,
    pub skin_instance: Ref<NiSkinInstance>,
    #[br(args(_header_version))]
    pub material_data: MaterialData,
}

/// Describes a mesh, built from triangles.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiTriBasedGeom {
    #[br(args(_header_version))]
    pub base: NiGeometry,
}

/// Mesh data: vertices, vertex normals, etc.
/// Bethesda 20.2.0.7 NIFs: NiParticlesData no longer inherits from NiGeometryData and inherits NiObject directly.
/// "Num Vertices" is renamed to "BS Max Vertices" for Bethesda 20.2 because Vertices, Normals, Tangents, Colors, and UV arrays
/// do not have length for NiPSysData regardless of "Num" or booleans.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiGeometryData {
    pub group_id: i32,
    pub num_vertices: u16,
    pub keep_flags: u8,
    pub compress_flags: u8,
    #[br(map = |b: u8| b != 0)]
    pub has_vertices: bool,
    #[br(if(has_vertices))]
    #[br(count = num_vertices)]
    pub vertices: Option<Vec<Vector3>>,
    pub data_flags: NiGeometryDataFlags,
    #[br(map = |b: u8| b != 0)]
    pub has_normals: bool,
    #[br(if(has_normals))]
    #[br(count = num_vertices)]
    pub normals: Option<Vec<Vector3>>,
    #[br(if(has_normals && data_flags.0 & 4096 != 0))]
    #[br(count = num_vertices)]
    pub tangents: Option<Vec<Vector3>>,
    #[br(if(has_normals && data_flags.0 & 4096 != 0))]
    #[br(count = num_vertices)]
    pub bitangents: Option<Vec<Vector3>>,
    pub bounding_sphere: NiBound,
    #[br(map = |b: u8| b != 0)]
    pub has_vertex_colors: bool,
    #[br(if(has_vertex_colors))]
    #[br(count = num_vertices)]
    pub vertex_colors: Option<Vec<Color4>>,
    #[br(
        args(data_flags.0 as usize & 63, num_vertices as usize),
        parse_with = parse::fixed_vec_vec,
    )]
    pub uv_sets: Vec<Vec<TexCoord>>,
    pub consistency_flags: ConsistencyType,
    pub additional_data: Ref<AbstractAdditionalGeometryData>,
}

#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct AbstractAdditionalGeometryData {}

/// Describes a mesh, built from triangles.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiTriBasedGeomData {
    #[br(args(_header_version))]
    pub base: NiGeometryData,
    pub num_triangles: u16,
}

/// Transparency. Flags 0x00ED.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiAlphaProperty {
    #[br(args(_header_version))]
    pub base: NiProperty,
    pub flags: AlphaFlags,
    pub threshold: u8,
}

/// Ambient light source.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiAmbientLight {
    #[br(args(_header_version))]
    pub base: NiLight,
}

/// Generic rotating particles data object.
/// Bethesda 20.2.0.7 NIFs: NiParticlesData no longer inherits from NiGeometryData and inherits NiObject directly.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiParticlesData {
    #[br(args(_header_version))]
    pub base: NiGeometryData,
    #[br(map = |b: u8| b != 0)]
    pub has_radii: bool,
    #[br(if(has_radii))]
    #[br(count = base.num_vertices)]
    pub radii: Option<Vec<f32>>,
    pub num_active: u16,
    #[br(map = |b: u8| b != 0)]
    pub has_sizes: bool,
    #[br(if(has_sizes))]
    #[br(count = base.num_vertices)]
    pub sizes: Option<Vec<f32>>,
    #[br(map = |b: u8| b != 0)]
    pub has_rotations: bool,
    #[br(if(has_rotations))]
    #[br(count = base.num_vertices)]
    pub rotations: Option<Vec<Quaternion>>,
    #[br(map = |b: u8| b != 0)]
    pub has_rotation_angles: bool,
    #[br(if(has_rotation_angles))]
    #[br(count = base.num_vertices)]
    pub rotation_angles: Option<Vec<f32>>,
    #[br(map = |b: u8| b != 0)]
    pub has_rotation_axes: bool,
    #[br(if(has_rotation_axes))]
    #[br(count = base.num_vertices)]
    pub rotation_axes: Option<Vec<Vector3>>,
}

/// Rotating particles data object.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiRotatingParticlesData {
    #[br(args(_header_version))]
    pub base: NiParticlesData,
}

/// Particle system data object (with automatic normals?).
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiAutoNormalParticlesData {
    #[br(args(_header_version))]
    pub base: NiParticlesData,
}

/// Particle system data.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysData {
    #[br(args(_header_version))]
    pub base: NiParticlesData,
    #[br(count = base.base.num_vertices)]
    pub particle_info: Vec<NiParticleInfo>,
    #[br(map = |b: u8| b != 0)]
    pub has_rotation_speeds: bool,
    #[br(if(has_rotation_speeds))]
    #[br(count = base.base.num_vertices)]
    pub rotation_speeds: Option<Vec<f32>>,
    pub num_added_particles: u16,
    pub added_particles_base: u16,
}

/// Particle meshes data.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiMeshPSysData {
    #[br(args(_header_version))]
    pub base: NiPSysData,
    pub default_pool_size: u32,
    #[br(map = |b: u8| b != 0)]
    pub fill_pools_on_load: bool,
    pub num_generations: u32,
    #[br(count = num_generations)]
    pub generations: Vec<u32>,
    pub particle_meshes: Ref<NiNode>,
}

/// Binary extra data object. Used to store tangents and bitangents in Oblivion.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiBinaryExtraData {
    #[br(args(_header_version))]
    pub base: NiExtraData,
    pub binary_data: ByteArray,
}

/// Voxel extra data object.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiBinaryVoxelExtraData {
    #[br(args(_header_version))]
    pub base: NiExtraData,
    pub data: Ref<NiBinaryVoxelData>,
}

/// Voxel data object.
#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiBinaryVoxelData {
    pub unknown_short_1: u16,
    pub unknown_short_2: u16,
    pub unknown_short_3: u16,
    pub unknown_7_floats: [f32; 7],
    pub unknown_bytes_1: [u8; 7 + 12],
    #[br(temp)]
    num_unknown_vectors: u32,
    #[br(count = num_unknown_vectors)]
    pub unknown_vectors: Vec<Vector4>,
    #[br(temp)]
    num_unknown_bytes_2: u32,
    #[br(count = num_unknown_bytes_2)]
    pub unknown_bytes_2: Vec<u8>,
    pub unknown_5_ints: [u32; 5],
}

/// Blends bool values together.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiBlendBoolInterpolator {
    #[br(args(_header_version))]
    pub base: NiBlendInterpolator,
    pub value: u8,
}

/// Blends float values together.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiBlendFloatInterpolator {
    #[br(args(_header_version))]
    pub base: NiBlendInterpolator,
    pub value: f32,
}

/// Blends NiPoint3 values together.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiBlendPoint3Interpolator {
    #[br(args(_header_version))]
    pub base: NiBlendInterpolator,
    pub value: Vector3,
}

/// Blends NiQuatTransform values together.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiBlendTransformInterpolator {
    #[br(args(_header_version))]
    pub base: NiBlendInterpolator,
}

/// Wrapper for boolean animation keys.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiBoolData {
    pub data: KeyGroup<u8>,
}

/// Boolean extra data.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiBooleanExtraData {
    #[br(args(_header_version))]
    pub base: NiExtraData,
    pub boolean_data: u8,
}

/// Contains an NiBSplineBasis for use in interpolation of open, uniform B-Splines.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiBSplineBasisData {
    pub num_control_points: u32,
}

/// Uses B-Splines to animate a float value over time.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiBSplineFloatInterpolator {
    #[br(args(_header_version))]
    pub base: NiBSplineInterpolator,
    pub value: f32,
    pub handle: u32,
}

/// NiBSplineFloatInterpolator plus the information required for using compact control points.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiBSplineCompFloatInterpolator {
    #[br(args(_header_version))]
    pub base: NiBSplineFloatInterpolator,
    pub float_offset: f32,
    pub float_half_range: f32,
}

/// Uses B-Splines to animate an NiPoint3 value over time.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiBSplinePoint3Interpolator {
    #[br(args(_header_version))]
    pub base: NiBSplineInterpolator,
    pub value: Vector3,
    pub handle: u32,
}

/// NiBSplinePoint3Interpolator plus the information required for using compact control points.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiBSplineCompPoint3Interpolator {
    #[br(args(_header_version))]
    pub base: NiBSplinePoint3Interpolator,
    pub position_offset: f32,
    pub position_half_range: f32,
}

/// Supports the animation of position, rotation, and scale using an NiQuatTransform.
/// The NiQuatTransform can be an unchanging pose or interpolated from B-Spline control point channels.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiBSplineTransformInterpolator {
    #[br(args(_header_version))]
    pub base: NiBSplineInterpolator,
    pub transform: NiQuatTransform,
    pub translation_handle: u32,
    pub rotation_handle: u32,
    pub scale_handle: u32,
}

/// NiBSplineTransformInterpolator plus the information required for using compact control points.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiBSplineCompTransformInterpolator {
    #[br(args(_header_version))]
    pub base: NiBSplineTransformInterpolator,
    pub translation_offset: f32,
    pub translation_half_range: f32,
    pub rotation_offset: f32,
    pub rotation_half_range: f32,
    pub scale_offset: f32,
    pub scale_half_range: f32,
}

/// Contains one or more sets of control points for use in interpolation of open, uniform B-Splines, stored as either float or compact.
#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiBSplineData {
    #[br(temp)]
    num_float_control_points: u32,
    #[br(count = num_float_control_points)]
    pub float_control_points: Vec<f32>,
    #[br(temp)]
    num_compact_control_points: u32,
    #[br(count = num_compact_control_points)]
    pub compact_control_points: Vec<i16>,
}

/// Camera object.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiCamera {
    #[br(args(_header_version))]
    pub base: NiAVObject,
    pub camera_flags: u16,
    pub frustum_left: f32,
    pub frustum_right: f32,
    pub frustum_top: f32,
    pub frustum_bottom: f32,
    pub frustum_near: f32,
    pub frustum_far: f32,
    #[br(map = |b: u8| b != 0)]
    pub use_orthographic_projection: bool,
    pub viewport_left: f32,
    pub viewport_right: f32,
    pub viewport_top: f32,
    pub viewport_bottom: f32,
    pub lod_adjust: f32,
    pub scene: Ref<NiAVObject>,
    pub num_screen_polygons: u32,
    pub num_screen_textures: u32,
}

/// Wrapper for color animation keys.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiColorData {
    pub data: KeyGroup<Color4>,
}

/// Extra data in the form of NiColorA (red, green, blue, alpha).
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiColorExtraData {
    #[br(args(_header_version))]
    pub base: NiExtraData,
    pub data: Color4,
}

/// Controls animation sequences on a specific branch of the scene graph.
#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiControllerManager {
    #[br(args(_header_version))]
    pub base: NiTimeController,
    #[br(map = |b: u8| b != 0)]
    pub cumulative: bool,
    #[br(temp)]
    num_controller_sequences: u32,
    #[br(count = num_controller_sequences)]
    pub controller_sequences: Vec<Ref<NiControllerSequence>>,
    pub object_palette: Ref<NiDefaultAVObjectPalette>,
}

/// Root node in NetImmerse .kf files (until version 10.0).
#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiSequence {
    pub name: NiString,
    #[br(temp)]
    num_controlled_blocks: u32,
    pub array_grow_by: u32,
    #[br(args { count: num_controlled_blocks as usize, inner: (_header_version,) })]
    pub controlled_blocks: Vec<ControlledBlock>,
}

/// Root node in Gamebryo .kf files (version 10.0.1.0 and up).
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiControllerSequence {
    #[br(args(_header_version))]
    pub base: NiSequence,
    pub weight: f32,
    pub text_keys: Ref<NiTextKeyExtraData>,
    pub cycle_type: CycleType,
    pub frequency: f32,
    pub start_time: f32,
    pub stop_time: f32,
    pub manager: Ptr<NiControllerManager>,
    pub accum_root_name: NiString,
    #[br(if((FileVersion(20,3,0,8) <= _header_version)))]
    pub accum_flags: Option<AccumFlags>,
}

/// Abstract base class for indexing NiAVObject by name.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiAVObjectPalette {}

/// NiAVObjectPalette implementation. Used to quickly look up objects by name.
#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiDefaultAVObjectPalette {
    #[br(args(_header_version))]
    pub base: NiAVObjectPalette,
    pub scene: Ptr<NiAVObject>,
    #[br(temp)]
    num_objs: u32,
    #[br(count = num_objs)]
    pub objs: Vec<AVObject>,
}

/// Directional light source.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiDirectionalLight {
    #[br(args(_header_version))]
    pub base: NiLight,
}

/// NiDitherProperty allows the application to turn the dithering of interpolated colors and fog values on and off.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiDitherProperty {
    pub base: NiProperty,
    pub flags: DitherFlags,
}

/// DEPRECATED (10.2), REMOVED (20.5). Replaced by NiTransformController and NiLookAtInterpolator.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiRollController {
    #[br(args(_header_version))]
    pub base: NiSingleInterpController,
    pub data: Ref<NiFloatData>,
}

/// Wrapper for 1D (one-dimensional) floating point animation keys.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiFloatData {
    pub data: KeyGroup<f32>,
}

/// Extra float data.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiFloatExtraData {
    #[br(args(_header_version))]
    pub base: NiExtraData,
    pub float_data: f32,
}

/// Extra float array data.
#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiFloatsExtraData {
    #[br(args(_header_version))]
    pub base: NiExtraData,
    #[br(temp)]
    num_floats: u32,
    #[br(count = num_floats)]
    pub data: Vec<f32>,
}

/// NiFogProperty allows the application to enable, disable and control the appearance of fog.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiFogProperty {
    #[br(args(_header_version))]
    pub base: NiProperty,
    pub flags: FogFlags,
    pub fog_depth: f32,
    pub fog_color: Color3,
}

/// LEGACY (pre-10.1) particle modifier. Applies a gravitational field on the particles.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiGravity {
    #[br(args(_header_version))]
    pub base: NiParticleModifier,
    pub decay: f32,
    pub force: f32,
    pub r#type: FieldType,
    pub position: Vector3,
    pub direction: Vector3,
}

/// Extra integer data.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiIntegerExtraData {
    #[br(args(_header_version))]
    pub base: NiExtraData,
    pub integer_data: u32,
}

/// Extra integer array data.
#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiIntegersExtraData {
    #[br(args(_header_version))]
    pub base: NiExtraData,
    #[br(temp)]
    num_integers: u32,
    #[br(count = num_integers)]
    pub data: Vec<u32>,
}

/// DEPRECATED (10.2), RENAMED (10.2) to NiTransformData.
/// Wrapper for transformation animation keys.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiKeyframeData {
    pub num_rotation_keys: u32,
    #[br(if(num_rotation_keys != 0))]
    pub rotation_type: Option<KeyType>,
    #[br(if(rotation_type != Some(KeyType::XYZ_ROTATION_KEY)))]
    #[br(args { count: num_rotation_keys as usize, inner: (rotation_type,) })]
    pub quaternion_keys: Option<Vec<QuatKey<Quaternion>>>,
    #[br(if(rotation_type == Some(KeyType::XYZ_ROTATION_KEY)))]
    pub xyz_rotations: Option<[KeyGroup<f32>; 3]>,
    pub translations: KeyGroup<Vector3>,
    pub scales: KeyGroup<f32>,
}

/// DEPRECATED (10.2), REMOVED (20.5)
/// Replaced by NiTransformController and NiLookAtInterpolator.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiLookAtController {
    #[br(args(_header_version))]
    pub base: NiTimeController,
    pub look_at_flags: LookAtFlags,
    pub look_at: Ptr<NiNode>,
}

/// NiLookAtInterpolator rotates an object so that it always faces a target object.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiLookAtInterpolator {
    #[br(args(_header_version))]
    pub base: NiInterpolator,
    pub flags: LookAtFlags,
    pub look_at: Ptr<NiNode>,
    pub look_at_name: NiString,
    #[br(if(_header_version <= FileVersion(20,4,0,12)))]
    pub transform: Option<NiQuatTransform>,
    pub interpolator_translation: Ref<NiPoint3Interpolator>,
    pub interpolator_roll: Ref<NiFloatInterpolator>,
    pub interpolator_scale: Ref<NiFloatInterpolator>,
}

/// Describes the surface properties of an object e.g. translucency, ambient color, diffuse color, emissive color, and specular color.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiMaterialProperty {
    #[br(args(_header_version))]
    pub base: NiProperty,
    pub ambient_color: Color3,
    pub diffuse_color: Color3,
    pub specular_color: Color3,
    pub emissive_color: Color3,
    pub glossiness: f32,
    pub alpha: f32,
}

/// DEPRECATED (20.5), replaced by NiMorphMeshModifier.
/// Geometry morphing data.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiMorphData {
    pub num_morphs: u32,
    pub num_vertices: u32,
    pub relative_targets: u8,
    #[br(args { count: num_morphs as usize, inner: (num_vertices,) })]
    pub morphs: Vec<Morph>,
}

/// Generic node object for grouping.
#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiNode {
    #[br(args(_header_version))]
    pub base: NiAVObject,
    #[br(temp)]
    num_children: u32,
    #[br(count = num_children)]
    pub children: Vec<Ref<NiAVObject>>,
    #[br(temp)]
    num_effects: u32,
    #[br(count = num_effects)]
    pub effects: Vec<Ref<NiDynamicEffect>>,
}

/// A NiNode used as a skeleton bone?
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiBone {
    #[br(args(_header_version))]
    pub base: NiNode,
}

/// Found in Munch's Oddysee
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiCollisionSwitch {
    #[br(args(_header_version))]
    pub base: NiNode,
}

/// These nodes will always be rotated to face the camera creating a billboard effect for any attached objects.
///
/// In pre-10.1.0.0 the Flags field is used for BillboardMode.
/// Bit 0: hidden
/// Bits 1-2: collision mode
/// Bit 3: unknown (set in most official meshes)
/// Bits 5-6: billboard mode
///
/// Collision modes:
/// 00 NONE
/// 01 USE_TRIANGLES
/// 10 USE_OBBS
/// 11 CONTINUE
///
/// Billboard modes:
/// 00 ALWAYS_FACE_CAMERA
/// 01 ROTATE_ABOUT_UP
/// 10 RIGID_FACE_CAMERA
/// 11 ALWAYS_FACE_CENTER
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiBillboardNode {
    #[br(args(_header_version))]
    pub base: NiNode,
    pub billboard_mode: u16, // BillboardMode
}

/// Represents groups of multiple scenegraph subtrees, only one of which (the "active child") is drawn at any given time.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiSwitchNode {
    #[br(args(_header_version))]
    pub base: NiNode,
    pub switch_node_flags: NiSwitchFlags,
    pub index: u32,
}

/// Level of detail selector. Links to different levels of detail of the same model, used to switch a geometry at a specified distance.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiLODNode {
    #[br(args(_header_version))]
    pub base: NiSwitchNode,
    pub lod_level_data: Ref<NiLODData>,
}

/// NiPalette objects represent mappings from 8-bit indices to 24-bit RGB or 32-bit RGBA colors.
#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiPalette {
    pub has_alpha: u8,
    #[br(temp)]
    num_entries: u32,
    #[br(count = if num_entries == 16 { 16 } else { 256 })]
    pub palette: Vec<ByteColor4>,
}

/// LEGACY (pre-10.1) particle modifier.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiParticleBomb {
    #[br(args(_header_version))]
    pub base: NiParticleModifier,
    pub decay: f32,
    pub duration: f32,
    pub deltav: f32,
    pub start: f32,
    pub decay_type: DecayType,
    pub symmetry_type: SymmetryType,
    pub position: Vector3,
    pub direction: Vector3,
}

/// LEGACY (pre-10.1) particle modifier.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiParticleColorModifier {
    #[br(args(_header_version))]
    pub base: NiParticleModifier,
    pub color_data: Ref<NiColorData>,
}

/// LEGACY (pre-10.1) particle modifier.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiParticleGrowFade {
    #[br(args(_header_version))]
    pub base: NiParticleModifier,
    pub grow: f32,
    pub fade: f32,
}

/// LEGACY (pre-10.1) particle modifier.
#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiParticleMeshModifier {
    #[br(args(_header_version))]
    pub base: NiParticleModifier,
    #[br(temp)]
    num_particle_meshes: u32,
    #[br(count = num_particle_meshes)]
    pub particle_meshes: Vec<Ref<NiAVObject>>,
}

/// LEGACY (pre-10.1) particle modifier.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiParticleRotation {
    #[br(args(_header_version))]
    pub base: NiParticleModifier,
    pub random_initial_axis: u8,
    pub initial_axis: Vector3,
    pub rotation_speed: f32,
}

/// Generic particle system node.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiParticles {
    #[br(args(_header_version))]
    pub base: NiGeometry,
}

/// LEGACY (pre-10.1). NiParticles which do not house normals and generate them at runtime.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiAutoNormalParticles {
    #[br(args(_header_version))]
    pub base: NiParticles,
}

/// LEGACY (pre-10.1). Particle meshes.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiParticleMeshes {
    #[br(args(_header_version))]
    pub base: NiParticles,
}

/// LEGACY (pre-10.1). Particle meshes data.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiParticleMeshesData {
    #[br(args(_header_version))]
    pub base: NiRotatingParticlesData,
    pub container_node: Ref<NiNode>,
}

/// A particle system.
/// Contains members to mimic inheritance shifts for Bethesda 20.2, where NiParticles switched to inheriting BSGeometry.
/// Until inheritance shifts are supported, the members are on NiParticleSystem instead of NiParticles for module reasons.
#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiParticleSystem {
    #[br(args(_header_version))]
    pub base: NiParticles,
    #[br(map = |b: u8| b != 0)]
    pub world_space: bool,
    #[br(temp)]
    num_modifiers: u32,
    #[br(count = num_modifiers)]
    pub modifiers: Vec<Ref<NiPSysModifier>>,
}

/// Particle system.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiMeshParticleSystem {
    #[br(args(_header_version))]
    pub base: NiParticleSystem,
}

#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiEmitterModifier {
    pub next_modifier: Ref<NiEmitterModifier>,
    pub controller: Ptr<NiParticleSystemController>,
}

/// A generic particle system time controller object.
#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiParticleSystemController {
    #[br(args(_header_version))]
    pub base: NiTimeController,
    pub speed: f32,
    pub speed_variation: f32,
    pub declination: f32,
    pub declination_variation: f32,
    pub planar_angle: f32,
    pub planar_angle_variation: f32,
    pub initial_normal: Vector3,
    pub initial_color: Color4,
    pub initial_size: f32,
    pub emit_start_time: f32,
    pub emit_stop_time: f32,
    pub reset_particle_system: u8,
    pub birth_rate: f32,
    pub lifetime: f32,
    pub lifetime_variation: f32,
    pub use_birth_rate: u8,
    pub spawn_on_death: u8,
    pub emitter_dimensions: Vector3,
    pub emitter: Ptr<NiAVObject>,
    pub num_spawn_generations: u16,
    pub percentage_spawned: f32,
    pub spawn_multiplier: u16,
    pub spawn_speed_chaos: f32,
    pub spawn_dir_chaos: f32,
    #[br(temp)]
    num_particles: u16,
    pub num_valid: u16,
    #[br(count = num_particles)]
    pub particles: Vec<NiParticleInfo>,
    pub emitter_modifier: Ref<NiEmitterModifier>,
    pub particle_modifier: Ref<NiParticleModifier>,
    pub particle_collider: Ref<NiParticleCollider>,
    pub static_target_bound: u8,
}

/// DEPRECATED (10.2), REMOVED (20.5). Replaced by NiTransformController and NiPathInterpolator.
/// Time controller for a path.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPathController {
    #[br(args(_header_version))]
    pub base: NiTimeController,
    pub path_flags: PathFlags,
    pub bank_dir: i32,
    pub max_bank_angle: f32,
    pub smoothing: f32,
    pub follow_axis: i16,
    pub path_data: Ref<NiPosData>,
    pub percent_data: Ref<NiFloatData>,
}

/// NiPixelFormat is not the parent to NiPixelData/NiPersistentSrcTextureRendererData,
/// but actually a member class loaded at the top of each. The two classes are not related.
/// However, faking this inheritance is useful for several things.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPixelFormat {
    pub pixel_format: PixelFormat,
    pub bits_per_pixel: u8,
    pub renderer_hint: u32,
    pub extra_data: u32,
    pub flags: u8,
    pub tiling: PixelTiling,
    #[br(if(FileVersion(20,3,0,4) <= _header_version))]
    #[br(map = |b: Option<u8>| b.map(|b| b != 0))]
    pub srgb_space: Option<bool>,
    pub channels: [PixelFormatComponent; 4],
}

#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiPersistentSrcTextureRendererData {
    #[br(args(_header_version))]
    pub base: NiPixelFormat,
    pub palette: Ref<NiPalette>,
    #[br(temp)]
    num_mipmaps: u32,
    pub bytes_per_pixel: u32,
    #[br(count = num_mipmaps)]
    pub mipmaps: Vec<MipMap>,
    #[br(temp)]
    num_pixels: u32,
    #[br(if(FileVersion(20,2,0,6) <= _header_version), temp)]
    pad_num_pixels: Option<u32>,
    #[br(temp)]
    num_faces: u32,
    pub platform: PlatformID,
    #[br(count = num_pixels * num_faces)]
    pub pixel_data: Vec<u8>,
}

/// A texture.
#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiPixelData {
    #[br(args(_header_version))]
    pub base: NiPixelFormat,
    pub palette: Ref<NiPalette>,
    #[br(temp)]
    num_mipmaps: u32,
    pub bytes_per_pixel: u32,
    #[br(count = num_mipmaps)]
    pub mipmaps: Vec<MipMap>,
    #[br(temp)]
    num_pixels: u32,
    #[br(temp)]
    num_faces: u32,
    #[br(count = num_pixels * num_faces)]
    pub pixel_data: Vec<u8>,
}

#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiParticleCollider {
    #[br(args(_header_version))]
    pub base: NiParticleModifier,
    pub bounce: f32,
    #[br(map = |b: u8| b != 0)]
    pub spawn_on_collide: bool,
    #[br(map = |b: u8| b != 0)]
    pub die_on_collide: bool,
}

/// LEGACY (pre-10.1) particle modifier.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPlanarCollider {
    #[br(args(_header_version))]
    pub base: NiParticleCollider,
    pub height: f32,
    pub width: f32,
    pub position: Vector3,
    pub x_vector: Vector3,
    pub y_vector: Vector3,
    pub plane: NiPlane,
}

/// A point light.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPointLight {
    #[br(args(_header_version))]
    pub base: NiLight,
    pub constant_attenuation: f32,
    pub linear_attenuation: f32,
    pub quadratic_attenuation: f32,
}

/// Wrapper for position animation keys.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPosData {
    pub data: KeyGroup<Vector3>,
}

/// Wrapper for rotation animation keys.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiRotData {
    pub num_rotation_keys: u32,
    #[br(if(num_rotation_keys != 0))]
    pub rotation_type: Option<KeyType>,
    #[br(if(rotation_type != Some(KeyType::XYZ_ROTATION_KEY)))]
    #[br(args { count: num_rotation_keys as usize, inner: (rotation_type,) })]
    pub quaternion_keys: Option<Vec<QuatKey<Quaternion>>>,
    #[br(if(rotation_type == Some(KeyType::XYZ_ROTATION_KEY)))]
    pub xyz_rotations: Option<[KeyGroup<f32>; 3]>,
}

/// Particle modifier that controls and updates the age of particles in the system.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysAgeDeathModifier {
    #[br(args(_header_version))]
    pub base: NiPSysModifier,
    #[br(map = |b: u8| b != 0)]
    pub spawn_on_death: bool,
    pub spawn_modifier: Ref<NiPSysSpawnModifier>,
}

/// Particle modifier that applies an explosive force to particles.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysBombModifier {
    #[br(args(_header_version))]
    pub base: NiPSysModifier,
    pub bomb_object: Ptr<NiNode>,
    pub bomb_axis: Vector3,
    pub decay: f32,
    pub delta_v: f32,
    pub decay_type: DecayType,
    pub symmetry_type: SymmetryType,
}

/// Particle modifier that creates and updates bound volumes.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysBoundUpdateModifier {
    #[br(args(_header_version))]
    pub base: NiPSysModifier,
    pub update_skip: u16,
}

/// Particle emitter that uses points within a defined Box shape to emit from.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysBoxEmitter {
    #[br(args(_header_version))]
    pub base: NiPSysVolumeEmitter,
    pub width: f32,
    pub height: f32,
    pub depth: f32,
}

/// Particle modifier that adds a defined shape to act as a collision object for particles to interact with.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysColliderManager {
    #[br(args(_header_version))]
    pub base: NiPSysModifier,
    pub collider: Ref<NiPSysCollider>,
}

/// Particle modifier that adds keyframe data to modify color/alpha values of particles over time.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysColorModifier {
    #[br(args(_header_version))]
    pub base: NiPSysModifier,
    pub data: Ref<NiColorData>,
}

/// Particle emitter that uses points within a defined Cylinder shape to emit from.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysCylinderEmitter {
    #[br(args(_header_version))]
    pub base: NiPSysVolumeEmitter,
    pub radius: f32,
    pub height: f32,
}

/// Particle modifier that applies a linear drag force to particles.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysDragModifier {
    #[br(args(_header_version))]
    pub base: NiPSysModifier,
    pub drag_object: Ptr<NiAVObject>,
    pub drag_axis: Vector3,
    pub percentage: f32,
    pub range: f32,
    pub range_falloff: f32,
}

/// DEPRECATED (10.2). Particle system emitter controller data.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysEmitterCtlrData {
    pub birth_rate_keys: KeyGroup<f32>,
    pub num_active_keys: u32,
    #[br(args { count: num_active_keys as usize, inner: (Some(KeyType::LINEAR_KEY),) })]
    pub active_keys: Vec<Key<u8>>,
}

/// Particle modifier that applies a gravitational force to particles.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysGravityModifier {
    #[br(args(_header_version))]
    pub base: NiPSysModifier,
    pub gravity_object: Ptr<NiAVObject>,
    pub gravity_axis: Vector3,
    pub decay: f32,
    pub strength: f32,
    pub force_type: ForceType,
    pub turbulence: f32,
    pub turbulence_scale: f32,
    #[br(map = |b: u8| b != 0)]
    pub world_aligned: bool,
}

/// Particle modifier that controls the time it takes to grow and shrink a particle.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysGrowFadeModifier {
    #[br(args(_header_version))]
    pub base: NiPSysModifier,
    pub grow_time: f32,
    pub grow_generation: u16,
    pub fade_time: f32,
    pub fade_generation: u16,
}

/// Particle emitter that uses points on a specified mesh to emit from.
#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysMeshEmitter {
    #[br(args(_header_version))]
    pub base: NiPSysEmitter,
    #[br(temp)]
    num_emitter_meshes: u32,
    #[br(count = num_emitter_meshes)]
    pub emitter_meshes: Vec<Ptr<NiAVObject>>,
    pub initial_velocity_type: VelocityType,
    pub emission_type: EmitFrom,
    pub emission_axis: Vector3,
}

/// Particle modifier that updates mesh particles using the age of each particle.
#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysMeshUpdateModifier {
    #[br(args(_header_version))]
    pub base: NiPSysModifier,
    #[br(temp)]
    num_meshes: u32,
    #[br(count = num_meshes)]
    pub meshes: Vec<Ref<NiAVObject>>,
}

/// Particle Collider object which particles will interact with.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysPlanarCollider {
    #[br(args(_header_version))]
    pub base: NiPSysCollider,
    pub width: f32,
    pub height: f32,
    pub x_axis: Vector3,
    pub y_axis: Vector3,
}

/// Particle Collider object which particles will interact with.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysSphericalCollider {
    #[br(args(_header_version))]
    pub base: NiPSysCollider,
    pub radius: f32,
}

/// Particle modifier that updates the particle positions based on velocity and last update time.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysPositionModifier {
    #[br(args(_header_version))]
    pub base: NiPSysModifier,
}

/// Particle modifier that calls reset on a target upon looping.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysResetOnLoopCtlr {
    #[br(args(_header_version))]
    pub base: NiTimeController,
}

/// Particle modifier that adds rotations to particles.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysRotationModifier {
    #[br(args(_header_version))]
    pub base: NiPSysModifier,
    pub rotation_speed: f32,
    pub rotation_speed_variation: f32,
    pub rotation_angle: f32,
    pub rotation_angle_variation: f32,
    #[br(map = |b: u8| b != 0)]
    pub random_rot_speed_sign: bool,
    #[br(map = |b: u8| b != 0)]
    pub random_axis: bool,
    pub axis: Vector3,
}

/// Particle modifier that spawns additional copies of a particle.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysSpawnModifier {
    #[br(args(_header_version))]
    pub base: NiPSysModifier,
    pub num_spawn_generations: u16,
    pub percentage_spawned: f32,
    pub min_num_to_spawn: u16,
    pub max_num_to_spawn: u16,
    pub spawn_speed_variation: f32,
    pub spawn_dir_variation: f32,
    pub life_span: f32,
    pub life_span_variation: f32,
}

/// Particle emitter that uses points within a sphere shape to emit from.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysSphereEmitter {
    #[br(args(_header_version))]
    pub base: NiPSysVolumeEmitter,
    pub radius: f32,
}

/// Particle system controller, tells the system to update its simulation.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysUpdateCtlr {
    #[br(args(_header_version))]
    pub base: NiTimeController,
}

/// Base for all force field particle modifiers.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysFieldModifier {
    #[br(args(_header_version))]
    pub base: NiPSysModifier,
    pub field_object: Ref<NiAVObject>,
    pub magnitude: f32,
    pub attenuation: f32,
    #[br(map = |b: u8| b != 0)]
    pub use_max_distance: bool,
    pub max_distance: f32,
}

/// Particle system modifier, implements a vortex field force for particles.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysVortexFieldModifier {
    #[br(args(_header_version))]
    pub base: NiPSysFieldModifier,
    pub direction: Vector3,
}

/// Particle system modifier, implements a gravity field force for particles.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysGravityFieldModifier {
    #[br(args(_header_version))]
    pub base: NiPSysFieldModifier,
    pub direction: Vector3,
}

/// Particle system modifier, implements a drag field force for particles.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysDragFieldModifier {
    #[br(args(_header_version))]
    pub base: NiPSysFieldModifier,
    #[br(map = |b: u8| b != 0)]
    pub use_direction: bool,
    pub direction: Vector3,
}

/// Particle system modifier, implements a turbulence field force for particles.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysTurbulenceFieldModifier {
    #[br(args(_header_version))]
    pub base: NiPSysFieldModifier,
    pub frequency: f32,
}

/// Particle system controller for force field magnitude.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysFieldMagnitudeCtlr {
    #[br(args(_header_version))]
    pub base: NiPSysModifierFloatCtlr,
}

/// Particle system controller for force field attenuation.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysFieldAttenuationCtlr {
    #[br(args(_header_version))]
    pub base: NiPSysModifierFloatCtlr,
}

/// Particle system controller for force field maximum distance.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysFieldMaxDistanceCtlr {
    #[br(args(_header_version))]
    pub base: NiPSysModifierFloatCtlr,
}

/// Particle system controller for air field air friction.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysAirFieldAirFrictionCtlr {
    #[br(args(_header_version))]
    pub base: NiPSysModifierFloatCtlr,
}

/// Particle system controller for air field inherit velocity.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysAirFieldInheritVelocityCtlr {
    #[br(args(_header_version))]
    pub base: NiPSysModifierFloatCtlr,
}

/// Particle system controller for air field spread.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysAirFieldSpreadCtlr {
    #[br(args(_header_version))]
    pub base: NiPSysModifierFloatCtlr,
}

/// Particle system controller for emitter initial rotation speed.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysInitialRotSpeedCtlr {
    #[br(args(_header_version))]
    pub base: NiPSysModifierFloatCtlr,
}

/// Particle system controller for emitter initial rotation speed variation.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysInitialRotSpeedVarCtlr {
    #[br(args(_header_version))]
    pub base: NiPSysModifierFloatCtlr,
}

/// Particle system controller for emitter initial rotation angle.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysInitialRotAngleCtlr {
    #[br(args(_header_version))]
    pub base: NiPSysModifierFloatCtlr,
}

/// Particle system controller for emitter initial rotation angle variation.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysInitialRotAngleVarCtlr {
    #[br(args(_header_version))]
    pub base: NiPSysModifierFloatCtlr,
}

/// Particle system controller for emitter planar angle.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysEmitterPlanarAngleCtlr {
    #[br(args(_header_version))]
    pub base: NiPSysModifierFloatCtlr,
}

/// Particle system controller for emitter planar angle variation.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysEmitterPlanarAngleVarCtlr {
    #[br(args(_header_version))]
    pub base: NiPSysModifierFloatCtlr,
}

/// Particle system modifier, updates the particle velocity to simulate the effects of air movements like wind, fans, or wake.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysAirFieldModifier {
    #[br(args(_header_version))]
    pub base: NiPSysFieldModifier,
    pub direction: Vector3,
    pub air_friction: f32,
    pub inherit_velocity: f32,
    #[br(map = |b: u8| b != 0)]
    pub inherit_rotation: bool,
    #[br(map = |b: u8| b != 0)]
    pub component_only: bool,
    #[br(map = |b: u8| b != 0)]
    pub enable_spread: bool,
    pub spread: f32,
}

/// Guild 2-Specific node
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysTrailEmitter {
    #[br(args(_header_version))]
    pub base: NiPSysSphereEmitter,
    pub trail_life_span: f32,
    pub trail_life_span_var: f32,
    pub num_trails: i32,
    pub gravity_force: f32,
    pub gravity_dir: Vector3,
    pub turbulence: f32,
    pub repeat_time: f32,
}

/// Unknown controller
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiLightIntensityController {
    #[br(args(_header_version))]
    pub base: NiFloatInterpController,
}

/// Particle system modifier, updates the particle velocity to simulate the effects of point gravity.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSysRadialFieldModifier {
    #[br(args(_header_version))]
    pub base: NiPSysFieldModifier,
    pub radial_type: f32,
}

/// Abstract class used for different types of LOD selections.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiLODData {}

/// NiRangeLODData controls switching LOD levels based on Z depth from the camera to the NiLODNode.
#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiRangeLODData {
    #[br(args(_header_version))]
    pub base: NiLODData,
    pub lod_center: Vector3,
    #[br(temp)]
    num_lod_levels: u32,
    #[br(count = num_lod_levels)]
    pub lod_levels: Vec<LODRange>,
}

/// NiScreenLODData controls switching LOD levels based on proportion of the screen that a bound would include.
#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiScreenLODData {
    #[br(args(_header_version))]
    pub base: NiLODData,
    pub bounding_sphere: NiBound,
    pub world_bounding_sphere: NiBound,
    #[br(temp)]
    num_proportions: u32,
    #[br(count = num_proportions)]
    pub proportion_levels: Vec<f32>,
}

/// Unknown.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiRotatingParticles {
    #[br(args(_header_version))]
    pub base: NiParticles,
}

/// DEPRECATED (pre-10.1), REMOVED (20.3).
/// Keyframe animation root node, in .kf files.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiSequenceStreamHelper {
    #[br(args(_header_version))]
    pub base: NiObjectNET,
}

/// Determines whether flat shading or smooth shading is used on a shape.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiShadeProperty {
    #[br(args(_header_version))]
    pub base: NiProperty,
    pub flags: ShadeFlags,
}

/// Skinning data.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiSkinData {
    pub skin_transform: NiTransform,
    pub num_bones: u32,
    pub has_vertex_weights: u8,
    #[br(args { count: num_bones as usize, inner: (has_vertex_weights != 0,) })]
    pub bone_list: Vec<BoneData>,
}

/// Skinning instance.
#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiSkinInstance {
    pub data: Ref<NiSkinData>,
    pub skin_partition: Ref<NiSkinPartition>,
    pub skeleton_root: Ptr<NiNode>,
    #[br(temp)]
    num_bones: u32,
    #[br(count = num_bones)]
    pub bones: Vec<Ptr<NiNode>>,
}

/// Old version of skinning instance.
#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiTriShapeSkinController {
    #[br(args(_header_version))]
    pub base: NiTimeController,
    #[br(temp)]
    num_bones: u32,
    #[br(count = num_bones)]
    pub vertex_counts: Vec<u32>,
    #[br(count = num_bones)]
    pub bones: Vec<Ptr<NiBone>>,
    #[br(count = num_bones)]
    pub bone_data: Vec<OldSkinData>,
}

/// Skinning data, optimized for hardware skinning. The mesh is partitioned in submeshes such that each vertex of a submesh is influenced only by a limited and fixed number of bones.
#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiSkinPartition {
    #[br(temp)]
    num_partitions: u32,
    #[br(count = num_partitions)]
    pub partitions: Vec<SkinPartition>,
}

/// A texture.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiTexture {
    #[br(args(_header_version))]
    pub base: NiObjectNET,
}

/// Describes texture source and properties.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiSourceTexture {
    #[br(args(_header_version))]
    pub base: NiTexture,
    pub use_external: u8,
    pub file_name: FilePath,
    pub pixel_data: Ref<NiPixelFormat>,
    pub format_prefs: FormatPrefs,
    pub is_static: u8,
    #[br(map = |b: u8| b != 0)]
    pub direct_render: bool,
    #[br(if(FileVersion(20,2,0,4) <= _header_version))]
    #[br(map = |b: Option<u8>| b.map(|b| b != 0))]
    pub persist_render_data: Option<bool>,
}

/// Gives specularity to a shape. Flags 0x0001.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiSpecularProperty {
    #[br(args(_header_version))]
    pub base: NiProperty,
    pub flags: SpecularFlags,
}

/// LEGACY (pre-10.1) particle modifier.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiSphericalCollider {
    #[br(args(_header_version))]
    pub base: NiParticleCollider,
    pub radius: f32,
    pub position: Vector3,
}

/// A spot.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiSpotLight {
    #[br(args(_header_version))]
    pub base: NiPointLight,
    pub outer_spot_angle: f32,
    #[br(if(FileVersion(20,2,0,5) <= _header_version))]
    pub inner_spot_angle: Option<f32>,
    pub exponent: f32,
}

/// Allows control of stencil testing.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiStencilProperty {
    #[br(args(_header_version))]
    pub base: NiProperty,
    pub flags: StencilFlags,
    pub stencil_ref: u32,
    pub stencil_mask: u32,
}

/// Extra data in the form of text.
/// Used in various official or user-defined ways, e.g. preventing optimization on objects ("NiOptimizeKeep", "sgoKeep").
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiStringExtraData {
    #[br(args(_header_version))]
    pub base: NiExtraData,
    pub string_data: NiString,
}

/// List of 0x00-seperated strings, which are names of controlled objects and controller types. Used in .kf files in conjunction with NiControllerSequence.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiStringPalette {
    pub palette: StringPalette,
}

/// Extra data in the form of a list of strings.
#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiStringsExtraData {
    #[br(args(_header_version))]
    pub base: NiExtraData,
    #[br(temp)]
    num_strings: u32,
    #[br(count = num_strings)]
    pub data: Vec<SizedString>,
}

/// Extra data that holds an array of NiTextKey objects for use in animation sequences.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiTextKeyExtraData {
    #[br(args(_header_version))]
    pub base: NiExtraData,
    pub num_text_keys: u32,
    #[br(args { count: num_text_keys as usize, inner: (Some(KeyType::LINEAR_KEY),) })]
    pub text_keys: Vec<Key<NiString>>,
}

/// Represents an effect that uses projected textures such as projected lights (gobos), environment maps, and fog maps.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiTextureEffect {
    #[br(args(_header_version))]
    pub base: NiDynamicEffect,
    pub model_projection_matrix: Matrix33,
    pub model_projection_translation: Vector3,
    pub texture_filtering: TexFilterMode,
    #[br(if((FileVersion(20,5,0,4) <= _header_version)))]
    pub max_anisotropy: Option<u16>,
    pub texture_clamping: TexClampMode,
    pub texture_type: TextureType,
    pub coordinate_generation_type: CoordGenType,
    pub source_texture: Ref<NiSourceTexture>,
    pub enable_plane: u8,
    pub plane: NiPlane,
}

/// LEGACY (pre-10.1)
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiTextureModeProperty {
    #[br(args(_header_version))]
    pub base: NiProperty,
    pub flags: u16,
}

/// LEGACY (pre-10.1)
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiImage {
    pub use_external: u8,
    #[br(if(use_external != 0))]
    pub file_name: Option<FilePath>,
    #[br(if(use_external == 0))]
    pub image_data: Option<Ref<NiRawImageData>>,
    pub unknown_int: u32,
    pub unknown_float: f32,
}

/// LEGACY (pre-10.1)
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiTextureProperty {
    #[br(args(_header_version))]
    pub base: NiProperty,
    pub flags: u16,
    pub image: Ref<NiImage>,
}

/// Describes how a fragment shader should be configured for a given piece of geometry.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiTexturingProperty {
    #[br(args(_header_version))]
    pub base: NiProperty,
    pub flags: TexturingFlags,
    pub texture_count: u32,
    #[br(map = |b: u8| b != 0)]
    pub has_base_texture: bool,
    #[br(if(has_base_texture))]
    #[br(args(_header_version))]
    pub base_texture: Option<TexDesc>,
    #[br(map = |b: u8| b != 0)]
    pub has_dark_texture: bool,
    #[br(if(has_dark_texture))]
    #[br(args(_header_version))]
    pub dark_texture: Option<TexDesc>,
    #[br(map = |b: u8| b != 0)]
    pub has_detail_texture: bool,
    #[br(if(has_detail_texture))]
    #[br(args(_header_version))]
    pub detail_texture: Option<TexDesc>,
    #[br(map = |b: u8| b != 0)]
    pub has_gloss_texture: bool,
    #[br(if(has_gloss_texture))]
    #[br(args(_header_version))]
    pub gloss_texture: Option<TexDesc>,
    #[br(map = |b: u8| b != 0)]
    pub has_glow_texture: bool,
    #[br(if(has_glow_texture))]
    #[br(args(_header_version))]
    pub glow_texture: Option<TexDesc>,
    #[br(if(texture_count > 5))]
    #[br(map = |b: Option<u8>| b.map(|b| b != 0))]
    pub has_bump_map_texture: Option<bool>,
    #[br(if(has_bump_map_texture.unwrap_or(false)))]
    #[br(args(_header_version))]
    pub bump_map_texture: Option<TexDesc>,
    #[br(if(has_bump_map_texture.unwrap_or(false)))]
    pub bump_map_luma_scale: Option<f32>,
    #[br(if(has_bump_map_texture.unwrap_or(false)))]
    pub bump_map_luma_offset: Option<f32>,
    #[br(if(has_bump_map_texture.unwrap_or(false)))]
    pub bump_map_matrix: Option<Matrix22>,
    #[br(if(FileVersion(20,2,0,5) <= _header_version && texture_count > 6))]
    #[br(map = |b: Option<u8>| b.map(|b| b != 0))]
    pub has_normal_texture: Option<bool>,
    #[br(if(has_normal_texture.unwrap_or(false)))]
    #[br(args(_header_version))]
    pub normal_texture: Option<TexDesc>,
    #[br(if(FileVersion(20,2,0,5) <= _header_version && texture_count > 7))]
    #[br(map = |b: Option<u8>| b.map(|b| b != 0))]
    pub has_parallax_texture: Option<bool>,
    #[br(if(has_parallax_texture.unwrap_or(false)))]
    #[br(args(_header_version))]
    pub parallax_texture: Option<TexDesc>,
    #[br(if(has_parallax_texture.unwrap_or(false)))]
    pub parallax_offset: Option<f32>,
    #[br(if(if _header_version <= FileVersion(20,2,0,4) { texture_count > 6 } else { texture_count > 8 }))]
    #[br(map = |b: Option<u8>| b.map(|b| b != 0))]
    pub has_decal_0_texture: Option<bool>,
    #[br(if(has_decal_0_texture.unwrap_or(false)))]
    #[br(args(_header_version))]
    pub decal_0_texture: Option<TexDesc>,
    #[br(if(if _header_version <= FileVersion(20,2,0,4) { texture_count > 7 } else { texture_count > 9 }))]
    #[br(map = |b: Option<u8>| b.map(|b| b != 0))]
    pub has_decal_1_texture: Option<bool>,
    #[br(if(has_decal_1_texture.unwrap_or(false)))]
    #[br(args(_header_version))]
    pub decal_1_texture: Option<TexDesc>,
    #[br(if(if _header_version <= FileVersion(20,2,0,4) { texture_count > 8 } else { texture_count > 10 }))]
    #[br(map = |b: Option<u8>| b.map(|b| b != 0))]
    pub has_decal_2_texture: Option<bool>,
    #[br(if(has_decal_2_texture.unwrap_or(false)))]
    #[br(args(_header_version))]
    pub decal_2_texture: Option<TexDesc>,
    #[br(if(if _header_version <= FileVersion(20,2,0,4)  { texture_count > 9 } else { texture_count > 11 }))]
    #[br(map = |b: Option<u8>| b.map(|b| b != 0))]
    pub has_decal_3_texture: Option<bool>,
    #[br(if(has_decal_3_texture.unwrap_or(false)))]
    #[br(args(_header_version))]
    pub decal_3_texture: Option<TexDesc>,
    pub num_shader_textures: u32,
    #[br(args { count: num_shader_textures as usize, inner: (_header_version,) })]
    pub shader_textures: Vec<ShaderTexDesc>,
}

#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiMultiTextureProperty {
    #[br(args(_header_version))]
    pub base: NiTexturingProperty,
}

/// Wrapper for transformation animation keys.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiTransformData {
    #[br(args(_header_version))]
    pub base: NiKeyframeData,
}

/// A shape node that refers to singular triangle data.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiTriShape {
    #[br(args(_header_version))]
    pub base: NiTriBasedGeom,
}

/// Holds mesh data using a list of singular triangles.
#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiTriShapeData {
    #[br(args(_header_version))]
    pub base: NiTriBasedGeomData,
    pub num_triangle_points: u32,
    #[br(map = |b: u8| b != 0)]
    pub has_triangles: bool,
    #[br(if(has_triangles))]
    #[br(count = base.num_triangles)]
    pub triangles: Option<Vec<Triangle>>,
    #[br(temp)]
    num_match_groups: u16,
    #[br(count = num_match_groups)]
    pub match_groups: Vec<MatchGroup>,
}

/// A shape node that refers to data organized into strips of triangles
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiTriStrips {
    #[br(args(_header_version))]
    pub base: NiTriBasedGeom,
}

/// Holds mesh data using strips of triangles.
#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiTriStripsData {
    #[br(args(_header_version))]
    pub base: NiTriBasedGeomData,
    #[br(temp)]
    num_strips: u16,
    #[br(count = num_strips)]
    pub strip_lengths: Vec<u16>,
    #[br(map = |b: u8| b != 0)]
    pub has_points: bool,
    #[br(if(has_points))]
    #[br(count = num_strips)]
    pub points: Option<Vec<u16>>,
}

/// Unknown
#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiEnvMappedTriShape {
    #[br(args(_header_version))]
    pub base: NiObjectNET,
    pub unknown_1: u16,
    pub unknown_matrix: Matrix44,
    #[br(temp)]
    num_children: u32,
    #[br(count = num_children)]
    pub children: Vec<Ref<NiAVObject>>,
    pub child_2: Ref<NiObject>,
    pub child_3: Ref<NiObject>,
}

/// Holds mesh data using a list of singular triangles.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiEnvMappedTriShapeData {
    #[br(args(_header_version))]
    pub base: NiTriShapeData,
}

/// LEGACY (pre-10.1)
/// Sub data of NiBezierMesh
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiBezierTriangle4 {
    pub unknown_1: [u32; 6],
    pub unknown_2: u16,
    pub matrix: Matrix33,
    pub vector_1: Vector3,
    pub vector_2: Vector3,
    pub unknown_3: [i16; 4],
    pub unknown_4: u8,
    pub unknown_5: u32,
    pub unknown_6: [i16; 24],
}

/// LEGACY (pre-10.1)
/// Unknown
#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiBezierMesh {
    #[br(args(_header_version))]
    pub base: NiAVObject,
    #[br(temp)]
    num_bezier_triangles: u32,
    #[br(count = num_bezier_triangles)]
    pub bezier_triangle: Vec<Ref<NiBezierTriangle4>>,
    pub unknown_3: u32,
    #[br(temp)]
    count_1: u16,
    pub unknown_4: u16,
    #[br(count = count_1)]
    pub points_1: Vec<Vector3>,
    pub unknown_5: u32,
    #[br(count = count_1)]
    pub points_2: Vec<f32>,
    pub unknown_6: u32,
    #[br(temp)]
    count_2: u16,
    #[br(count = count_2)]
    pub data_2: Vec<u16>,
}

/// A shape node that holds continuous level of detail information.
/// Seems to be specific to Freedom Force.
/// Found in: Freedom Force, Spellbinder
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiClod {
    #[br(args(_header_version))]
    pub base: NiTriBasedGeom,
}

/// Holds mesh data for continuous level of detail shapes.
/// Presumably a progressive mesh with triangles specified by edge splits.
/// Found in: Freedom Force, Spellbinder
#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiClodData {
    pub base: NiTriBasedGeomData,
    pub unknown_shorts: u16,
    #[br(temp)]
    unknown_count_1: u16,
    #[br(temp)]
    unknown_count_2: u16,
    #[br(temp)]
    unknown_count_3: u16,
    pub unknown_float: f32,
    pub unknown_short: u16,
    #[br(count = unknown_count_1)]
    pub unknown_clod_shorts_1: Vec<u16>,
    #[br(count = unknown_count_2)]
    pub unknown_clod_shorts_2: Vec<u16>,
    #[br(count = unknown_count_3)]
    pub unknown_clod_shorts_3: Vec<u16>,
}

/// A copy of NiSkinInstance for use with NiClod meshes.
/// Found in: Freedom Force, Spellbinder
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiClodSkinInstance {
    pub base: NiSkinInstance,
}

/// DEPRECATED (pre-10.1), REMOVED (20.3).
/// Time controller for texture coordinates.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiUVController {
    pub base: NiTimeController,
    pub texture_set: u16,
    pub data: Ref<NiUVData>,
}

/// DEPRECATED (pre-10.1), REMOVED (20.3)
/// Texture coordinate data.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiUVData {
    pub uv_groups: [KeyGroup<f32>; 4],
}

/// DEPRECATED (20.5).
/// Extra data in the form of a vector (as x, y, z, w components).
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiVectorExtraData {
    #[br(args(_header_version))]
    pub base: NiExtraData,
    pub vector_data: Vector4,
}

/// Property of vertex colors. This object is referred to by the root object of the NIF file whenever some NiTriShapeData object has vertex colors with non-default settings; if not present, vertex colors have vertex_mode=2 and lighting_mode=1.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiVertexColorProperty {
    #[br(args(_header_version))]
    pub base: NiProperty,
    pub flags: VertexColorFlags,
}

/// DEPRECATED (10.x), REMOVED (?)
/// Not used in skinning.
/// Unsure of use - perhaps for morphing animation or gravity.
#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiVertWeightsExtraData {
    #[br(args(_header_version))]
    pub base: NiExtraData,
    #[br(temp)]
    num_vertices: u16,
    #[br(count = num_vertices)]
    pub weight: Vec<f32>,
}

/// DEPRECATED (10.2), REMOVED (?), Replaced by NiBoolData.
/// Visibility data for a controller.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiVisData {
    pub num_keys: u32,
    #[br(args { count: num_keys as usize, inner: (Some(KeyType::LINEAR_KEY),) })]
    pub keys: Vec<Key<u8>>,
}

/// Allows applications to switch between drawing solid geometry or wireframe outlines.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiWireframeProperty {
    #[br(args(_header_version))]
    pub base: NiProperty,
    pub flags: WireframeFlags,
}

/// Allows applications to set the test and write modes of the renderer's Z-buffer and to set the comparison function used for the Z-buffer test.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiZBufferProperty {
    #[br(args(_header_version))]
    pub base: NiProperty,
    pub flags: ZBufferFlags,
}

/// LEGACY (pre-10.1)
/// Raw image data.
#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiRawImageData {
    #[br(temp)]
    width: u32,
    #[br(temp)]
    height: u32,
    pub image_type: ImageType,
    #[br(
        args(image_type == ImageType::RGB, width as usize, height as usize),
        parse_with = parse::fixed_option_vec_vec
    )]
    pub rgb_image_data: Option<Vec<Vec<ByteColor3>>>,
    #[br(
        args(image_type == ImageType::RGBA, width as usize, height as usize),
        parse_with = parse::fixed_option_vec_vec
    )]
    pub rgba_image_data: Option<Vec<Vec<ByteColor4>>>,
}

#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiAccumulator {}

/// Used to turn sorting off for individual subtrees in a scene. Useful if objects must be drawn in a fixed order.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiSortAdjustNode {
    #[br(args(_header_version))]
    pub base: NiNode,
    pub sorting_mode: SortingMode,
}

/// Represents cube maps that are created from either a set of six image files, six blocks of pixel data, or a single pixel data with six faces.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiSourceCubeMap {
    #[br(args(_header_version))]
    pub base: NiSourceTexture,
}

/// Wireframe geometry.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiLines {
    #[br(args(_header_version))]
    pub base: NiTriBasedGeom,
}

/// Wireframe geometry data.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiLinesData {
    #[br(args(_header_version))]
    pub base: NiGeometryData,
    #[br(args(base.num_vertices as usize), parse_with = parse::vec_of_bools)]
    pub lines: Vec<bool>,
}

/// DEPRECATED (20.5), functionality included in NiMeshScreenElements.
/// Two dimensional screen elements.
#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiScreenElementsData {
    #[br(args(_header_version))]
    pub base: NiTriShapeData,
    #[br(temp)]
    max_polygons: u16,
    #[br(count = max_polygons)]
    pub polygons: Vec<Polygon>,
    #[br(count = max_polygons)]
    pub polygon_indices: Vec<u16>,
    pub polygon_grow_by: u16,
    pub num_polygons: u16,
    pub max_vertices: u16,
    pub vertices_grow_by: u16,
    pub max_indices: u16,
    pub indices_grow_by: u16,
}

/// DEPRECATED (20.5), replaced by NiMeshScreenElements.
/// Two dimensional screen elements.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiScreenElements {
    #[br(args(_header_version))]
    pub base: NiTriShape,
}

/// NiRoomGroup represents a set of connected rooms i.e. a game level.
#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiRoomGroup {
    #[br(args(_header_version))]
    pub base: NiNode,
    pub shell: Ptr<NiNode>,
    #[br(temp)]
    num_rooms: u32,
    #[br(count = num_rooms)]
    pub rooms: Vec<Ptr<NiRoom>>,
}

#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiWall {
    #[br(args(_header_version))]
    pub base: NiNode,
    pub wall_plane: NiPlane,
}

/// NiRoom objects represent cells in a cell-portal culling system.
#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiRoom {
    #[br(args(_header_version))]
    pub base: NiNode,
    #[br(temp)]
    num_walls: u32,
    #[br(count = num_walls)]
    pub wall_planes: Vec<NiPlane>,
    #[br(temp)]
    num_in_portals: u32,
    #[br(count = num_in_portals)]
    pub in_portals: Vec<Ptr<NiPortal>>,
    #[br(temp)]
    num_out_portals: u32,
    #[br(count = num_out_portals)]
    pub out_portals: Vec<Ptr<NiPortal>>,
    #[br(temp)]
    num_fixtures: u32,
    #[br(count = num_fixtures)]
    pub fixtures: Vec<Ptr<NiAVObject>>,
}

/// NiPortal objects are grouping nodes that support aggressive visibility culling.
/// They represent flat polygonal regions through which a part of a scene graph can be viewed.
#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiPortal {
    #[br(args(_header_version))]
    pub base: NiAVObject,
    pub portal_flags: u16,
    pub plane_count: u16,
    #[br(temp)]
    num_vertices: u16,
    #[br(count = num_vertices)]
    pub vertices: Vec<Vector3>,
    pub adjoiner: Ptr<NiNode>,
}

#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiAdditionalGeometryData {
    #[br(args(_header_version))]
    pub base: AbstractAdditionalGeometryData,
    #[br(temp)]
    num_vertices: u16,
    #[br(temp)]
    num_block_infos: u32,
    #[br(count = num_block_infos)]
    pub block_infos: Vec<NiAGDDataStream>,
    pub num_blocks: u32,
    #[br(args { count: num_blocks as usize, inner: (0,) })]
    pub blocks: Vec<NiAGDDataBlocks>,
}

#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiDataStream {
    pub usage: DataStreamUsage,
    pub access: DataStreamAccess,
    #[br(temp)]
    num_bytes: u32,
    pub cloning_behavior: CloningBehavior,
    #[br(temp)]
    num_regions: u32,
    #[br(count = num_regions)]
    pub regions: Vec<Region>,
    #[br(temp)]
    num_components: u32,
    #[br(count = num_components)]
    pub component_formats: Vec<ComponentFormat>,
    #[br(count = num_bytes)]
    pub data: Vec<u8>,
    #[br(map = |b: u8| b != 0)]
    pub streamable: bool,
}

/// An object that can be rendered.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiRenderObject {
    #[br(args(_header_version))]
    pub base: NiAVObject,
    #[br(args(_header_version))]
    pub material_data: MaterialData,
}

/// Base class for mesh modifiers.
#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiMeshModifier {
    #[br(temp)]
    num_submit_points: u32,
    #[br(count = num_submit_points)]
    pub submit_points: Vec<SyncPoint>,
    #[br(temp)]
    num_complete_points: u32,
    #[br(count = num_complete_points)]
    pub complete_points: Vec<SyncPoint>,
}

#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiMesh {
    #[br(args(_header_version))]
    pub base: NiRenderObject,
    pub primitive_type: MeshPrimitiveType,
    pub num_submeshes: u16,
    #[br(map = |b: u8| b != 0)]
    pub instancing_enabled: bool,
    pub bounding_sphere: NiBound,
    #[br(temp)]
    num_datastreams: u32,
    #[br(count = num_datastreams)]
    pub datastreams: Vec<DataStreamRef>,
    #[br(temp)]
    num_modifiers: u32,
    #[br(count = num_modifiers)]
    pub modifiers: Vec<Ref<NiMeshModifier>>,
}

/// Manipulates a mesh with the semantic MORPHWEIGHTS using an NiMorphMeshModifier.
#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiMorphWeightsController {
    #[br(args(_header_version))]
    pub base: NiInterpController,
    pub count: u32,
    #[br(temp)]
    num_interpolators: u32,
    #[br(count = num_interpolators)]
    pub interpolators: Vec<Ref<NiInterpolator>>,
    #[br(temp)]
    num_targets: u32,
    #[br(count = num_targets)]
    pub target_names: Vec<NiFixedString>,
}

/// Performs linear-weighted blending between a set of target data streams.
#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiMorphMeshModifier {
    #[br(args(_header_version))]
    pub base: NiMeshModifier,
    pub flags: u8,
    pub num_targets: u16,
    #[br(temp)]
    num_elements: u32,
    #[br(count = num_elements)]
    pub elements: Vec<ElementReference>,
}

#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiSkinningMeshModifier {
    #[br(args(_header_version))]
    pub base: NiMeshModifier,
    pub flags: u16,
    pub skeleton_root: Ptr<NiAVObject>,
    pub skeleton_transform: NiTransform,
    #[br(temp)]
    num_bones: u32,
    #[br(count = num_bones)]
    pub bones: Vec<Ptr<NiAVObject>>,
    #[br(count = num_bones)]
    pub bone_transforms: Vec<NiTransform>,
    #[br(if(flags & 2 != 0))]
    #[br(count = num_bones)]
    pub bone_bounds: Option<Vec<NiBound>>,
}

/// An instance of a hardware-instanced mesh in a scene graph.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiMeshHWInstance {
    #[br(args(_header_version))]
    pub base: NiAVObject,
    pub master_mesh: Ref<NiMesh>,
    pub mesh_modifier: Ref<NiInstancingMeshModifier>,
}

/// Mesh modifier that provides per-frame instancing capabilities in Gamebryo.
#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiInstancingMeshModifier {
    #[br(args(_header_version))]
    pub base: NiMeshModifier,
    #[br(map = |b: u8| b != 0, temp)]
    has_instance_nodes: bool,
    #[br(map = |b: u8| b != 0)]
    pub per_instance_culling: bool,
    #[br(map = |b: u8| b != 0, temp)]
    has_static_bounds: bool,
    pub affected_mesh: Ref<NiMesh>,
    #[br(if(has_static_bounds))]
    pub bounding_sphere: Option<NiBound>,
    #[br(if(has_instance_nodes), temp)]
    num_instance_nodes: Option<u32>,
    #[br(if(has_instance_nodes))]
    #[br(count = num_instance_nodes.unwrap_or(0))]
    pub instance_nodes: Option<Vec<Ref<NiMeshHWInstance>>>,
}

/// Defines the levels of detail for a given character and dictates the character's current LOD.
#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiSkinningLODController {
    #[br(args(_header_version))]
    pub base: NiTimeController,
    pub current_lod: u32,
    #[br(temp)]
    num_bones: u32,
    #[br(count = num_bones)]
    pub bones: Vec<Ref<NiNode>>,
    #[br(temp)]
    num_skins: u32,
    #[br(count = num_skins)]
    pub skins: Vec<Ref<NiMesh>>,
    #[br(temp)]
    num_lod_levels: u32,
    #[br(count = num_lod_levels)]
    pub lods: Vec<LODInfo>,
}

/// Represents a particle system.
#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSParticleSystem {
    #[br(args(_header_version))]
    pub base: NiMesh,
    pub simulator: Ref<NiPSSimulator>,
    pub generator: Ref<NiPSBoundUpdater>,
    #[br(temp)]
    num_emitters: u32,
    #[br(count = num_emitters)]
    pub emitters: Vec<Ref<NiPSEmitter>>,
    #[br(temp)]
    num_spawners: u32,
    #[br(count = num_spawners)]
    pub spawners: Vec<Ref<NiPSSpawner>>,
    pub death_spawner: Ref<NiPSSpawner>,
    pub max_num_particles: u32,
    #[br(map = |b: u8| b != 0)]
    pub has_colors: bool,
    #[br(map = |b: u8| b != 0)]
    pub has_rotations: bool,
    #[br(map = |b: u8| b != 0)]
    pub has_rotation_axes: bool,
    #[br(map = |b: u8| b != 0)]
    pub world_space: bool,
}

/// Represents a particle system that uses mesh particles instead of sprite-based particles.
#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSMeshParticleSystem {
    #[br(args(_header_version))]
    pub base: NiPSParticleSystem,
    #[br(temp)]
    num_generations: u32,
    #[br(count = num_generations)]
    pub master_particles: Vec<Ref<NiAVObject>>,
    pub pool_size: u32,
    #[br(map = |b: u8| b != 0)]
    pub auto_fill_pools: bool,
}

/// A mesh modifier that uses particle system data to generate camera-facing quads.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSFacingQuadGenerator {
    #[br(args(_header_version))]
    pub base: NiMeshModifier,
}

/// A mesh modifier that uses particle system data to generate aligned quads for each particle.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSAlignedQuadGenerator {
    #[br(args(_header_version))]
    pub base: NiMeshModifier,
    pub scale_amount_u: f32,
    pub scale_limit_u: f32,
    pub scale_rest_u: f32,
    pub scale_amount_v: f32,
    pub scale_limit_v: f32,
    pub scale_rest_v: f32,
    pub center_u: f32,
    pub center_v: f32,
    #[br(map = |b: u8| b != 0)]
    pub uv_scrolling: bool,
    pub num_frames_across: u16,
    pub num_frames_down: u16,
    #[br(map = |b: u8| b != 0)]
    pub ping_pong: bool,
    pub initial_frame: u16,
    pub initial_frame_variation: f32,
    pub num_frames: u16,
    pub num_frames_variation: f32,
    pub initial_time: f32,
    pub final_time: f32,
}

/// The mesh modifier that performs all particle system simulation.
#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSSimulator {
    #[br(args(_header_version))]
    pub base: NiMeshModifier,
    #[br(temp)]
    num_simulation_steps: u32,
    #[br(count = num_simulation_steps)]
    pub simulation_steps: Vec<Ref<NiPSSimulatorStep>>,
}

/// Abstract base class for a single step in the particle system simulation process.  It has no seralized data.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSSimulatorStep {}

/// Encapsulates a floodgate kernel that updates particle size, colors, and rotations.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSSimulatorGeneralStep {
    #[br(args(_header_version))]
    pub base: NiPSSimulatorStep,
    pub num_color_keys: u8,
    #[br(args { count: num_color_keys as usize, inner: (Some(KeyType::LINEAR_KEY),) })]
    pub color_keys: Vec<Key<ByteColor4>>,
    pub grow_time: f32,
    pub shrink_time: f32,
    pub grow_generation: u16,
    pub shrink_generation: u16,
}

/// Encapsulates a floodgate kernel that simulates particle forces.
#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSSimulatorForcesStep {
    #[br(args(_header_version))]
    pub base: NiPSSimulatorStep,
    #[br(temp)]
    num_forces: u32,
    #[br(count = num_forces)]
    pub forces: Vec<Ref<NiPSForce>>,
}

/// Encapsulates a floodgate kernel that simulates particle colliders.
#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSSimulatorCollidersStep {
    #[br(args(_header_version))]
    pub base: NiPSSimulatorStep,
    #[br(temp)]
    num_colliders: u32,
    #[br(count = num_colliders)]
    pub colliders: Vec<Ref<NiPSCollider>>,
}

/// Encapsulates a floodgate kernel that updates mesh particle alignment and transforms.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSSimulatorMeshAlignStep {
    #[br(args(_header_version))]
    pub base: NiPSSimulatorStep,
    pub num_rotation_keys: u8,
    #[br(args { count: num_rotation_keys as usize, inner: (Some(KeyType::LINEAR_KEY),) })]
    pub rotation_keys: Vec<QuatKey<Quaternion>>,
    pub rotation_loop_behavior: PSLoopBehavior,
}

/// Encapsulates a floodgate kernel that updates particle positions and ages. As indicated by its name, this step should be attached last in the NiPSSimulator mesh modifier.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSSimulatorFinalStep {
    #[br(args(_header_version))]
    pub base: NiPSSimulatorStep,
}

/// Updates the bounding volume for an NiPSParticleSystem object.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSBoundUpdater {
    pub update_skip: u16,
}

/// Abstract base class for all particle forces.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSForce {
    pub name: NiFixedString,
    pub r#type: PSForceType,
    #[br(map = |b: u8| b != 0)]
    pub active: bool,
}

/// Abstract base class for all particle field forces.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSFieldForce {
    #[br(args(_header_version))]
    pub base: NiPSForce,
    pub field_object: Ref<NiAVObject>,
    pub magnitude: f32,
    pub attenuation: f32,
    #[br(map = |b: u8| b != 0)]
    pub use_max_distance: bool,
    pub max_distance: f32,
}

/// Applies a linear drag force to particles.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSDragForce {
    #[br(args(_header_version))]
    pub base: NiPSForce,
    pub drag_axis: Vector3,
    pub percentage: f32,
    pub range: f32,
    pub range_falloff: f32,
    pub drag_object: Ptr<NiAVObject>,
}

/// Applies a gravitational force to particles.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSGravityForce {
    #[br(args(_header_version))]
    pub base: NiPSForce,
    pub gravity_axis: Vector3,
    pub decay: f32,
    pub strength: f32,
    pub force_type: ForceType,
    pub turbulence: f32,
    pub turbulence_scale: f32,
    pub gravity_object: Ptr<NiAVObject>,
}

/// Applies an explosive force to particles.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSBombForce {
    #[br(args(_header_version))]
    pub base: NiPSForce,
    pub bomb_axis: Vector3,
    pub decay: f32,
    pub delta_v: f32,
    pub decay_type: DecayType,
    pub symmetry_type: SymmetryType,
    pub bomb_object: Ptr<NiAVObject>,
}

/// Inside a field, updates particle velocity to simulate the effects of air movements.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSAirFieldForce {
    #[br(args(_header_version))]
    pub base: NiPSFieldForce,
    pub direction: Vector3,
    pub air_friction: f32,
    pub inherited_velocity: f32,
    #[br(map = |b: u8| b != 0)]
    pub inherit_rotation: bool,
    #[br(map = |b: u8| b != 0)]
    pub enable_spread: bool,
    pub spread: f32,
}

/// Inside a field, updates particle velocity to simulate the effects of directional gravity.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSGravityFieldForce {
    #[br(args(_header_version))]
    pub base: NiPSFieldForce,
    pub direction: Vector3,
}

/// Inside a field, updates particle velocity to simulate the effects of drag.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSDragFieldForce {
    #[br(args(_header_version))]
    pub base: NiPSFieldForce,
    #[br(map = |b: u8| b != 0)]
    pub use_direction: bool,
    pub direction: Vector3,
}

/// Inside a field, updates particle velocity to simulate the effects of point gravity.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSRadialFieldForce {
    #[br(args(_header_version))]
    pub base: NiPSFieldForce,
    pub radial_factor: f32,
}

/// Inside a field, updates particle velocity to simulate the effects of turbulence.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSTurbulenceFieldForce {
    #[br(args(_header_version))]
    pub base: NiPSFieldForce,
    pub frequency: f32,
}

/// Inside a field, updates particle velocity to simulate the effects of a vortex.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSVortexFieldForce {
    #[br(args(_header_version))]
    pub base: NiPSFieldForce,
    pub direction: Vector3,
}

/// Abstract base class for all particle emitters.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSEmitter {
    pub name: NiFixedString,
    pub speed: f32,
    pub speed_var: f32,
    pub declination: f32,
    pub declination_var: f32,
    pub planar_angle: f32,
    pub planar_angle_var: f32,
    #[br(if((_header_version <= FileVersion(20,6,0,0))))]
    pub color: Option<ByteColor4>,
    pub size: f32,
    pub size_var: f32,
    pub lifespan: f32,
    pub lifespan_var: f32,
    pub rotation_angle: f32,
    pub rotation_angle_var: f32,
    pub rotation_speed: f32,
    pub rotation_speed_var: f32,
    pub rotation_axis: Vector3,
    #[br(map = |b: u8| b != 0)]
    pub random_rot_speed_sign: bool,
    #[br(map = |b: u8| b != 0)]
    pub random_rot_axis: bool,
}

/// Abstract base class for particle emitters that emit particles from a volume.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSVolumeEmitter {
    #[br(args(_header_version))]
    pub base: NiPSEmitter,
    pub emitter_object: Ptr<NiAVObject>,
}

/// A particle emitter that emits particles from a rectangular volume.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSBoxEmitter {
    #[br(args(_header_version))]
    pub base: NiPSVolumeEmitter,
    pub emitter_width: f32,
    pub emitter_height: f32,
    pub emitter_depth: f32,
}

/// A particle emitter that emits particles from a spherical volume.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSSphereEmitter {
    #[br(args(_header_version))]
    pub base: NiPSVolumeEmitter,
    pub emitter_radius: f32,
}

/// A particle emitter that emits particles from a cylindrical volume.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSCylinderEmitter {
    #[br(args(_header_version))]
    pub base: NiPSVolumeEmitter,
    pub emitter_radius: f32,
    pub emitter_height: f32,
}

/// A particle emitter that emits particles from a toroidal volume.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSTorusEmitter {
    #[br(args(_header_version))]
    pub base: NiPSVolumeEmitter,
    pub emitter_radius: f32,
    pub emitter_section_radius: f32,
}

/// Emits particles from one or more NiMesh objects. A random mesh emitter is selected for each particle emission.
#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSMeshEmitter {
    #[br(args(_header_version))]
    pub base: NiPSEmitter,
    #[br(temp)]
    num_mesh_emitters: u32,
    #[br(count = num_mesh_emitters)]
    pub mesh_emitters: Vec<Ptr<NiMesh>>,
    #[br(if((_header_version <= FileVersion(20,6,0,0))))]
    pub emit_axis: Option<Vector3>,
    pub mesh_emission_type: EmitFrom,
    pub initial_velocity_type: VelocityType,
}

/// Emits particles from a curve.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSCurveEmitter {
    #[br(args(_header_version))]
    pub base: NiPSEmitter,
    #[br(map = |b: u8| b != 0)]
    pub has_curve: bool,
    #[br(if(has_curve))]
    pub curve: Option<NiCurve3>,
    pub curve_parent: Ptr<NiAVObject>,
    pub emitter_object: Ptr<NiAVObject>,
}

/// Abstract base class for all particle emitter time controllers.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSEmitterCtlr {
    #[br(args(_header_version))]
    pub base: NiSingleInterpController,
    pub emitter_name: NiFixedString,
}

/// Abstract base class for controllers that animate a floating point value on an NiPSEmitter object.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSEmitterFloatCtlr {
    #[br(args(_header_version))]
    pub base: NiPSEmitterCtlr,
}

/// Animates particle emission and birth rate.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSEmitParticlesCtlr {
    #[br(args(_header_version))]
    pub base: NiPSEmitterCtlr,
    pub emitter_active_interpolator: Ref<NiInterpolator>,
}

/// Abstract base class for all particle force time controllers.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSForceCtlr {
    #[br(args(_header_version))]
    pub base: NiSingleInterpController,
    pub force_name: NiFixedString,
}

/// Abstract base class for controllers that animate a Boolean value on an NiPSForce object.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSForceBoolCtlr {
    #[br(args(_header_version))]
    pub base: NiPSForceCtlr,
}

/// Abstract base class for controllers that animate a floating point value on an NiPSForce object.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSForceFloatCtlr {
    #[br(args(_header_version))]
    pub base: NiPSForceCtlr,
}

/// Animates whether or not an NiPSForce object is active.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSForceActiveCtlr {
    #[br(args(_header_version))]
    pub base: NiPSForceBoolCtlr,
}

/// Animates the strength value of an NiPSGravityForce object.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSGravityStrengthCtlr {
    #[br(args(_header_version))]
    pub base: NiPSForceFloatCtlr,
}

/// Animates the attenuation value of an NiPSFieldForce object.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSFieldAttenuationCtlr {
    #[br(args(_header_version))]
    pub base: NiPSForceFloatCtlr,
}

/// Animates the magnitude value of an NiPSFieldForce object.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSFieldMagnitudeCtlr {
    #[br(args(_header_version))]
    pub base: NiPSForceFloatCtlr,
}

/// Animates the max distance value of an NiPSFieldForce object.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSFieldMaxDistanceCtlr {
    #[br(args(_header_version))]
    pub base: NiPSForceFloatCtlr,
}

/// Animates the speed value on an NiPSEmitter object.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSEmitterSpeedCtlr {
    #[br(args(_header_version))]
    pub base: NiPSEmitterFloatCtlr,
}

/// Animates the size value on an NiPSEmitter object.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSEmitterRadiusCtlr {
    #[br(args(_header_version))]
    pub base: NiPSEmitterFloatCtlr,
}

/// Animates the declination value on an NiPSEmitter object.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSEmitterDeclinationCtlr {
    #[br(args(_header_version))]
    pub base: NiPSEmitterFloatCtlr,
}

/// Animates the declination variation value on an NiPSEmitter object.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSEmitterDeclinationVarCtlr {
    #[br(args(_header_version))]
    pub base: NiPSEmitterFloatCtlr,
}

/// Animates the planar angle value on an NiPSEmitter object.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSEmitterPlanarAngleCtlr {
    #[br(args(_header_version))]
    pub base: NiPSEmitterFloatCtlr,
}

/// Animates the planar angle variation value on an NiPSEmitter object.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSEmitterPlanarAngleVarCtlr {
    #[br(args(_header_version))]
    pub base: NiPSEmitterFloatCtlr,
}

/// Animates the rotation angle value on an NiPSEmitter object.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSEmitterRotAngleCtlr {
    #[br(args(_header_version))]
    pub base: NiPSEmitterFloatCtlr,
}

/// Animates the rotation angle variation value on an NiPSEmitter object.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSEmitterRotAngleVarCtlr {
    #[br(args(_header_version))]
    pub base: NiPSEmitterFloatCtlr,
}

/// Animates the rotation speed value on an NiPSEmitter object.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSEmitterRotSpeedCtlr {
    #[br(args(_header_version))]
    pub base: NiPSEmitterFloatCtlr,
}

/// Animates the rotation speed variation value on an NiPSEmitter object.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSEmitterRotSpeedVarCtlr {
    #[br(args(_header_version))]
    pub base: NiPSEmitterFloatCtlr,
}

/// Animates the lifespan value on an NiPSEmitter object.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSEmitterLifeSpanCtlr {
    #[br(args(_header_version))]
    pub base: NiPSEmitterFloatCtlr,
}

/// Calls ResetParticleSystem on an NiPSParticleSystem target upon looping.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSResetOnLoopCtlr {
    #[br(args(_header_version))]
    pub base: NiTimeController,
}

/// Abstract base class for all particle colliders.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSCollider {
    pub spawner: Ref<NiPSSpawner>,
    pub r#type: ColliderType,
    #[br(map = |b: u8| b != 0)]
    pub active: bool,
    pub bounce: f32,
    #[br(map = |b: u8| b != 0)]
    pub spawn_on_collide: bool,
    #[br(map = |b: u8| b != 0)]
    pub die_on_collide: bool,
}

/// A planar collider for particles.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSPlanarCollider {
    #[br(args(_header_version))]
    pub base: NiPSCollider,
    pub width: f32,
    pub height: f32,
    pub x_axis: Vector3,
    pub y_axis: Vector3,
    pub collider_object: Ptr<NiAVObject>,
}

/// A spherical collider for particles.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSSphericalCollider {
    #[br(args(_header_version))]
    pub base: NiPSCollider,
    pub radius: f32,
    pub collider_object: Ptr<NiAVObject>,
}

/// Creates a new particle whose initial parameters are based on an existing particle.
#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPSSpawner {
    pub percentage_spawned: f32,
    pub spawn_speed_factor_var: f32,
    pub spawn_dir_chaos: f32,
    pub life_span: f32,
    pub life_span_var: f32,
    pub num_spawn_generations: u16,
    pub min_to_spawn: u32,
    pub max_to_spawn: u32,
}

#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiEvaluator {
    pub node_name: NiFixedString,
    pub property_type: NiFixedString,
    pub controller_type: NiFixedString,
    pub controller_id: NiFixedString,
    pub interpolator_id: NiFixedString,
    pub channel_types: [u8; 4],
}

#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiKeyBasedEvaluator {
    #[br(args(_header_version))]
    pub base: NiEvaluator,
}

#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiBoolEvaluator {
    #[br(args(_header_version))]
    pub base: NiKeyBasedEvaluator,
    pub data: Ref<NiBoolData>,
}

#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiBoolTimelineEvaluator {
    #[br(args(_header_version))]
    pub base: NiBoolEvaluator,
}

#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiColorEvaluator {
    #[br(args(_header_version))]
    pub base: NiKeyBasedEvaluator,
    pub data: Ref<NiColorData>,
}

#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiFloatEvaluator {
    #[br(args(_header_version))]
    pub base: NiKeyBasedEvaluator,
    pub data: Ref<NiFloatData>,
}

#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPoint3Evaluator {
    #[br(args(_header_version))]
    pub base: NiKeyBasedEvaluator,
    pub data: Ref<NiPosData>,
}

#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiQuaternionEvaluator {
    #[br(args(_header_version))]
    pub base: NiKeyBasedEvaluator,
    pub data: Ref<NiRotData>,
}

#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiTransformEvaluator {
    #[br(args(_header_version))]
    pub base: NiKeyBasedEvaluator,
    pub value: NiQuatTransform,
    pub data: Ref<NiTransformData>,
}

#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiConstBoolEvaluator {
    #[br(args(_header_version))]
    pub base: NiEvaluator,
    pub value: f32,
}

#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiConstColorEvaluator {
    #[br(args(_header_version))]
    pub base: NiEvaluator,
    pub value: Color4,
}

#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiConstFloatEvaluator {
    #[br(args(_header_version))]
    pub base: NiEvaluator,
    pub value: f32,
}

#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiConstPoint3Evaluator {
    #[br(args(_header_version))]
    pub base: NiEvaluator,
    pub value: Vector3,
}

#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiConstQuaternionEvaluator {
    #[br(args(_header_version))]
    pub base: NiEvaluator,
    pub value: Quaternion,
}

#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiConstTransformEvaluator {
    #[br(args(_header_version))]
    pub base: NiEvaluator,
    pub value: NiQuatTransform,
}

#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiBSplineEvaluator {
    #[br(args(_header_version))]
    pub base: NiEvaluator,
    pub start_time: f32,
    pub end_time: f32,
    pub data: Ref<NiBSplineData>,
    pub basis_data: Ref<NiBSplineBasisData>,
}

#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiBSplineColorEvaluator {
    #[br(args(_header_version))]
    pub base: NiBSplineEvaluator,
    pub handle: u32,
}

#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiBSplineCompColorEvaluator {
    #[br(args(_header_version))]
    pub base: NiBSplineColorEvaluator,
    pub offset: f32,
    pub half_range: f32,
}

#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiBSplineFloatEvaluator {
    #[br(args(_header_version))]
    pub base: NiBSplineEvaluator,
    pub handle: u32,
}

#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiBSplineCompFloatEvaluator {
    #[br(args(_header_version))]
    pub base: NiBSplineFloatEvaluator,
    pub offset: f32,
    pub half_range: f32,
}

#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiBSplinePoint3Evaluator {
    #[br(args(_header_version))]
    pub base: NiBSplineEvaluator,
    pub handle: u32,
}

#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiBSplineCompPoint3Evaluator {
    #[br(args(_header_version))]
    pub base: NiBSplinePoint3Evaluator,
    pub offset: f32,
    pub half_range: f32,
}

#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiBSplineTransformEvaluator {
    #[br(args(_header_version))]
    pub base: NiBSplineEvaluator,
    pub transform: NiQuatTransform,
    pub translation_handle: u32,
    pub rotation_handle: u32,
    pub scale_handle: u32,
}

#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiBSplineCompTransformEvaluator {
    #[br(args(_header_version))]
    pub base: NiBSplineTransformEvaluator,
    pub translation_offset: f32,
    pub translation_half_range: f32,
    pub rotation_offset: f32,
    pub rotation_half_range: f32,
    pub scale_offset: f32,
    pub scale_half_range: f32,
}

#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiLookAtEvaluator {
    #[br(args(_header_version))]
    pub base: NiEvaluator,
    pub flags: LookAtFlags,
    pub look_at_name: NiFixedString,
    pub driven_name: NiFixedString,
    pub interpolator_translation: Ref<NiPoint3Interpolator>,
    pub interpolator_roll: Ref<NiFloatInterpolator>,
    pub interpolator_scale: Ref<NiFloatInterpolator>,
}

#[derive(Clone, Debug, PartialEq, BinRead)]
#[br(import(_header_version: FileVersion))]
pub struct NiPathEvaluator {
    #[br(args(_header_version))]
    pub base: NiKeyBasedEvaluator,
    pub flags: PathFlags,
    pub bank_dir: i32,
    pub max_bank_angle: f32,
    pub smoothing: f32,
    pub follow_axis: i16,
    pub path_data: Ref<NiPosData>,
    pub percent_data: Ref<NiFloatData>,
}

/// Root node in Gamebryo .kf files (20.5.0.1 and up).
/// For 20.5.0.0, "NiSequenceData" is an alias for "NiControllerSequence" and this is not handled in nifxml.
/// This was not found in any 20.5.0.0 KFs available and they instead use NiControllerSequence directly.
/// After 20.5.0.1, Controlled Blocks are no longer used and instead the sequences uses NiEvaluator.
#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiSequenceData {
    pub name: NiFixedString,
    #[br(if(_header_version <= FileVersion(20,5,0,1)), temp)]
    num_controlled_blocks: Option<u32>,
    #[br(if(_header_version <= FileVersion(20,5,0,1)))]
    pub array_grow_by: Option<u32>,
    #[br(if(_header_version <= FileVersion(20,5,0,1)))]
    #[br(args { count: num_controlled_blocks.unwrap_or(0) as usize, inner: (_header_version,) })]
    pub controlled_blocks: Option<Vec<ControlledBlock>>,
    #[br(if(FileVersion(20,5,0,2) <= _header_version), temp)]
    num_evaluators: Option<u32>,
    #[br(if(FileVersion(20,5,0,2) <= _header_version))]
    #[br(count = num_evaluators.unwrap_or(0))]
    pub evaluators: Option<Vec<Ref<NiEvaluator>>>,
    pub text_keys: Ref<NiTextKeyExtraData>,
    pub duration: f32,
    pub cycle_type: CycleType,
    pub frequency: f32,
    pub accum_root_name: NiFixedString,
    pub accum_flags: AccumFlags,
}

/// An NiShadowGenerator object is attached to an NiDynamicEffect object to inform the shadowing system that the effect produces shadows.
#[binread]
#[derive(Clone, Debug, PartialEq)]
#[br(import(_header_version: FileVersion))]
pub struct NiShadowGenerator {
    pub name: NiString,
    pub flags: NiShadowGeneratorFlags,
    #[br(temp)]
    num_shadow_casters: u32,
    #[br(count = num_shadow_casters)]
    pub shadow_casters: Vec<Ref<NiNode>>,
    #[br(temp)]
    num_shadow_receivers: u32,
    #[br(count = num_shadow_receivers)]
    pub shadow_receivers: Vec<Ref<NiNode>>,
    pub target: Ptr<NiDynamicEffect>,
    pub depth_bias: f32,
    pub size_hint: u16,
    #[br(if(FileVersion(20,3,0,7) <= _header_version))]
    pub near_clipping_distance: Option<f32>,
    #[br(if((FileVersion(20,3,0,7) <= _header_version)))]
    pub far_clipping_distance: Option<f32>,
    #[br(if((FileVersion(20,3,0,7) <= _header_version)))]
    pub directional_light_frustum_width: Option<f32>,
}
