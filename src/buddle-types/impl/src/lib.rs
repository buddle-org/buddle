//! Dynamic Rust code generation for shared C++ types.

#![deny(rust_2018_idioms, rustdoc::broken_intra_doc_links)]
#![forbid(unsafe_code)]

use std::{
    collections::HashSet,
    fs::File,
    io::{self, Write},
    path::Path,
};

use buddle_utils::{
    ahash::RandomState,
    hash::{string_id, StringIdBuilder},
};

mod codegen;

mod translation;

mod type_list;
use type_list::TypeList;

/// Builds Rust structs from type definitions in JSON format and writes
/// them to a given output file.
pub struct Builder {
    types: TypeList,
    ignored: HashSet<&'static str, RandomState>,
    output: io::BufWriter<File>,
}

impl Builder {
    pub fn new<P: AsRef<Path>>(types: P, output: P) -> anyhow::Result<Self> {
        let reader = io::BufReader::new(File::open(types)?);
        let output = io::BufWriter::new(File::create(output)?);

        let mut this = Self {
            types: TypeList::from_reader(reader)?,
            ignored: HashSet::default(),
            output,
        };
        this.write_prologue()?;

        Ok(this)
    }

    fn write_prologue(&mut self) -> anyhow::Result<()> {
        writeln!(self.output, "// This file is auto-generated by Buddle.")?;
        writeln!(self.output, "// Do not edit manually.\n")?;

        writeln!(self.output, "use buddle_object_property::{{*, cpp::*}};")?;

        Ok(())
    }

    /// Ignores a dependency on a certain base type during codegen.
    pub fn ignore(mut self, name: &'static str) -> Self {
        self.ignored.insert(name);
        self
    }

    /// Generates a type with the given `name` to the output file.
    pub fn build(mut self, name: &str) -> anyhow::Result<Self> {
        // Try to look up the requested type by hash.
        let hash = string_id(name);
        let type_def = self
            .types
            .classes
            .get(&hash)
            .ok_or_else(|| anyhow::anyhow!("failed to find type named '{name}'"))?;

        // Recursively generate the base types first.
        for base in type_def
            .bases
            .iter()
            .filter(|b| !self.ignored.contains(b.as_str()))
        {
            let base_hash = StringIdBuilder::new()
                .feed(b"class ")
                .feed_str(base)
                .finish();
            let base_def = self.types.classes.get(&base_hash).unwrap();

            codegen::generate_struct(&mut self.output, base_def)?;
        }

        // Generate the actual type.
        codegen::generate_struct(&mut self.output, type_def)?;

        Ok(self)
    }

    /// Finishes codegen and flushes remaining data to the output file.
    pub fn finish(mut self) -> anyhow::Result<()> {
        self.output.flush().map_err(Into::into)
    }
}
